<div style='display: none'>
@tableofcontents @section README

To view this file in the Firefox web browser, download readmeviewer.html from https://www.genivia.com/files/readmeviewer.html.zip, unzip and copy it to the same directory where this soapReadme.md file is located, then open it in Firefox to view the contents of soapReadme.md.

This markdown file is compatible with Doxygen.
</div>

## Overview {#doc-overview}

This report was generated by soapcpp2 v2.8.103 for interface header file [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) with options -r  -C -L -j -w 

### Tools

The **wsdl2h** command line tool takes a set of WSDL and XSD files to generate a data binding interface header file.  This interface header file is similar to a C/C++ header file and contains declarations of C/C++ types and functions with explanatory comments, directives, and annotations.  Types are declared in this interface header file as serializable.  Functions are declared as Web service operations for the client and server sides.

The **soapcpp2** command line tool takes an interface header file (i.e. a header file) such as [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) to generate the data binding implementation.  This implementation includes XML serializers and source code for the client and server side.  An interface header file for soapcpp2 can be a regular C/C++ header file with type and function declarations (without code), and include annotations to declare XML schema-related properties.

### Files

The following c++ source code files were generated by soapcpp2 for interface header file [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h):

- [soapStub.h](soapStub.h) contains an annotated copy of [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) and of the imported files (if any), where most of the information in this report [soapReadme.md](soapReadme.md) is sourced from (this header file also #includes "stdsoap2.h")
- [soapH.h](soapH.h) declares allocation and (de)serialization functions for each C/C++ type, to #include in projects (this header file also #includes "soapStub.h")
- [soapC.cpp](soapC.cpp) defines allocation and (de)serialization functions for each C/C++ type, to compile with a project
- See [Web client proxy class](#doc-client) for the client-side source code files to use

Also compile stdsoap2.cpp (and dom.cpp if XML DOM is used) with a project (or link libgsoapssl++.a) and use the following compile-time options:

- `-DWITH_OPENSSL` to enable HTTPS with OpenSSL
- `-DWITH_GNUTLS` to enable HTTPS with GNUTLS
- `-DWITH_DOM` is required when using the WS-Security plugin
- `-DWITH_GZIP` to enable message compression

See the gSOAP documentation for additional options.

### Contents

This report has the following contents describing the data binding interface types, and the client- and the server-side operations (if any):

- [enumeration types](#doc-enums)
- [class, struct and union types](#doc-classes)
- [typedefs](#doc-typedefs)
- [summary of serializable types](#doc-types)
- [schemas and namespaces](#doc-namespaces)
- [Web client proxy class](#doc-client) lists the methods to invoke

[![][1] To top](#)


## Enumeration Types {#doc-enums}

<table class="doxtable">
<tr><th> Type </th><th> Declared </th><th> Serializable </th><th> Bitmask </th><th> Values </th></tr>
<tr><td><code><a href="#wsu__tTimestampFault"> enum wsu__tTimestampFault </a></code></td><td> wsu.h:67 </td><td> yes </td><td>  </td><td> <code> wsu__MessageExpired </code> </td></tr>
<tr><td><code><a href="#wsse__FaultcodeEnum"> enum wsse__FaultcodeEnum </a></code></td><td> wsse.h:117 </td><td> yes </td><td>  </td><td> <code> wsse__UnsupportedSecurityToken </code>, <code> wsse__UnsupportedAlgorithm </code>, <code> wsse__InvalidSecurity </code>, <code> wsse__InvalidSecurityToken </code>, <code> wsse__FailedAuthentication </code>, <code> wsse__FailedCheck </code>, <code> wsse__SecurityTokenUnavailable </code> </td></tr>
<tr><td><code><a href="#wsc__FaultCodeType"> enum wsc__FaultCodeType </a></code></td><td> wsc.h:63 </td><td> yes </td><td>  </td><td> <code> wsc__BadContextToken </code>, <code> wsc__UnsupportedContextToken </code>, <code> wsc__UnknownDerivationSource </code>, <code> wsc__RenewNeeded </code>, <code> wsc__UnableToRenew </code> </td></tr>
<tr><td><code><a href="#saml1__DecisionType"> enum saml1__DecisionType </a></code></td><td> saml1.h:146 </td><td> yes </td><td>  </td><td> <code> saml1__DecisionType__Permit </code>, <code> saml1__DecisionType__Deny </code>, <code> saml1__DecisionType__Indeterminate </code> </td></tr>
<tr><td><code><a href="#saml2__DecisionType"> enum saml2__DecisionType </a></code></td><td> saml2.h:155 </td><td> yes </td><td>  </td><td> <code> saml2__DecisionType__Permit </code>, <code> saml2__DecisionType__Deny </code>, <code> saml2__DecisionType__Indeterminate </code> </td></tr>
</table>

<a name="wsu__tTimestampFault"></a>

### `enum wsu__tTimestampFault`

This enum type is declared in [wsu.h](wsu.h) at line 67 and has values  `wsu__MessageExpired` (= 0).

- `enum wsu__tTimestampFault *soap_new_wsu__tTimestampFault(struct soap*)` managed allocation with default initialization
- `enum wsu__tTimestampFault *soap_new_wsu__tTimestampFault(struct soap*, int n)` managed allocation with default initialization of array `enum wsu__tTimestampFault[n]`
- `void soap_default_wsu__tTimestampFault(struct soap*, enum wsu__tTimestampFault *value)` set to default value
- `const char *soap_wsu__tTimestampFault2s(struct soap*, enum wsu__tTimestampFault value)` returns string-converted value in temporary string buffer
- `int soap_s2wsu__tTimestampFault(struct soap*, const char*, enum wsu__tTimestampFault *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="wsse__FaultcodeEnum"></a>

### `enum wsse__FaultcodeEnum`

This enum type is declared in [wsse.h](wsse.h) at line 117 and has values  `wsse__UnsupportedSecurityToken` (= 0), `wsse__UnsupportedAlgorithm` (= 1), `wsse__InvalidSecurity` (= 2), `wsse__InvalidSecurityToken` (= 3), `wsse__FailedAuthentication` (= 4), `wsse__FailedCheck` (= 5), `wsse__SecurityTokenUnavailable` (= 6).

- `enum wsse__FaultcodeEnum *soap_new_wsse__FaultcodeEnum(struct soap*)` managed allocation with default initialization
- `enum wsse__FaultcodeEnum *soap_new_wsse__FaultcodeEnum(struct soap*, int n)` managed allocation with default initialization of array `enum wsse__FaultcodeEnum[n]`
- `void soap_default_wsse__FaultcodeEnum(struct soap*, enum wsse__FaultcodeEnum *value)` set to default value
- `const char *soap_wsse__FaultcodeEnum2s(struct soap*, enum wsse__FaultcodeEnum value)` returns string-converted value in temporary string buffer
- `int soap_s2wsse__FaultcodeEnum(struct soap*, const char*, enum wsse__FaultcodeEnum *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="wsc__FaultCodeType"></a>

### `enum wsc__FaultCodeType`

This enum type is declared in [wsc.h](wsc.h) at line 63 and has values  `wsc__BadContextToken` (= 0), `wsc__UnsupportedContextToken` (= 1), `wsc__UnknownDerivationSource` (= 2), `wsc__RenewNeeded` (= 3), `wsc__UnableToRenew` (= 4).

- `enum wsc__FaultCodeType *soap_new_wsc__FaultCodeType(struct soap*)` managed allocation with default initialization
- `enum wsc__FaultCodeType *soap_new_wsc__FaultCodeType(struct soap*, int n)` managed allocation with default initialization of array `enum wsc__FaultCodeType[n]`
- `void soap_default_wsc__FaultCodeType(struct soap*, enum wsc__FaultCodeType *value)` set to default value
- `const char *soap_wsc__FaultCodeType2s(struct soap*, enum wsc__FaultCodeType value)` returns string-converted value in temporary string buffer
- `int soap_s2wsc__FaultCodeType(struct soap*, const char*, enum wsc__FaultCodeType *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__DecisionType"></a>

### `enum saml1__DecisionType`

This enum type is declared in [saml1.h](saml1.h) at line 146 and has values  `saml1__DecisionType__Permit` (= 0), `saml1__DecisionType__Deny` (= 1), `saml1__DecisionType__Indeterminate` (= 2).

- `enum saml1__DecisionType *soap_new_saml1__DecisionType(struct soap*)` managed allocation with default initialization
- `enum saml1__DecisionType *soap_new_saml1__DecisionType(struct soap*, int n)` managed allocation with default initialization of array `enum saml1__DecisionType[n]`
- `void soap_default_saml1__DecisionType(struct soap*, enum saml1__DecisionType *value)` set to default value
- `const char *soap_saml1__DecisionType2s(struct soap*, enum saml1__DecisionType value)` returns string-converted value in temporary string buffer
- `int soap_s2saml1__DecisionType(struct soap*, const char*, enum saml1__DecisionType *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__DecisionType"></a>

### `enum saml2__DecisionType`

This enum type is declared in [saml2.h](saml2.h) at line 155 and has values  `saml2__DecisionType__Permit` (= 0), `saml2__DecisionType__Deny` (= 1), `saml2__DecisionType__Indeterminate` (= 2).

- `enum saml2__DecisionType *soap_new_saml2__DecisionType(struct soap*)` managed allocation with default initialization
- `enum saml2__DecisionType *soap_new_saml2__DecisionType(struct soap*, int n)` managed allocation with default initialization of array `enum saml2__DecisionType[n]`
- `void soap_default_saml2__DecisionType(struct soap*, enum saml2__DecisionType *value)` set to default value
- `const char *soap_saml2__DecisionType2s(struct soap*, enum saml2__DecisionType value)` returns string-converted value in temporary string buffer
- `int soap_s2saml2__DecisionType(struct soap*, const char*, enum saml2__DecisionType *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


## Class, Struct and Union Types {#doc-classes}

The table below lists the classes, structs and unions declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) or that are imported:

<table class="doxtable">
<tr><th> Type </th><th> Declared </th><th> Serializable </th></tr>
<tr><td><code><a href="#xsd__anyType"> xsd__anyType </a></code></td><td> CCMovelDigitalSignature.h:171 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code></td><td> CCMovelDigitalSignature.h:181 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__ID__"> xsd__ID__ </a></code></td><td> CCMovelDigitalSignature.h:199 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__IDREF__"> xsd__IDREF__ </a></code></td><td> CCMovelDigitalSignature.h:209 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__QName__"> xsd__QName__ </a></code></td><td> CCMovelDigitalSignature.h:216 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__anyURI__"> xsd__anyURI__ </a></code></td><td> CCMovelDigitalSignature.h:226 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__base64Binary__"> xsd__base64Binary__ </a></code></td><td> CCMovelDigitalSignature.h:233 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__boolean_"> xsd__boolean_ </a></code></td><td> CCMovelDigitalSignature.h:240 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__byte__"> xsd__byte__ </a></code></td><td> CCMovelDigitalSignature.h:247 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__dateTime_"> xsd__dateTime_ </a></code></td><td> CCMovelDigitalSignature.h:254 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__decimal__"> xsd__decimal__ </a></code></td><td> CCMovelDigitalSignature.h:264 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__double_"> xsd__double_ </a></code></td><td> CCMovelDigitalSignature.h:271 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__duration__"> xsd__duration__ </a></code></td><td> CCMovelDigitalSignature.h:281 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__float_"> xsd__float_ </a></code></td><td> CCMovelDigitalSignature.h:288 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__int_"> xsd__int_ </a></code></td><td> CCMovelDigitalSignature.h:295 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__long_"> xsd__long_ </a></code></td><td> CCMovelDigitalSignature.h:302 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__short_"> xsd__short_ </a></code></td><td> CCMovelDigitalSignature.h:309 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__string_"> xsd__string_ </a></code></td><td> CCMovelDigitalSignature.h:316 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedByte__"> xsd__unsignedByte__ </a></code></td><td> CCMovelDigitalSignature.h:323 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedInt_"> xsd__unsignedInt_ </a></code></td><td> CCMovelDigitalSignature.h:330 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedLong_"> xsd__unsignedLong_ </a></code></td><td> CCMovelDigitalSignature.h:337 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedShort_"> xsd__unsignedShort_ </a></code></td><td> CCMovelDigitalSignature.h:344 </td><td> yes </td></tr>
<tr><td><code><a href="#ns4__char__"> ns4__char__ </a></code></td><td> CCMovelDigitalSignature.h:432 </td><td> yes </td></tr>
<tr><td><code><a href="#ns4__duration__"> ns4__duration__ </a></code></td><td> CCMovelDigitalSignature.h:446 </td><td> yes </td></tr>
<tr><td><code><a href="#ns4__guid__"> ns4__guid__ </a></code></td><td> CCMovelDigitalSignature.h:459 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__CCMovelSign"> _ns3__CCMovelSign </a></code></td><td> CCMovelDigitalSignature.h:357 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__CCMovelSignResponse"> _ns3__CCMovelSignResponse </a></code></td><td> CCMovelDigitalSignature.h:359 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__GetCertificate"> _ns3__GetCertificate </a></code></td><td> CCMovelDigitalSignature.h:361 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__GetCertificateResponse"> _ns3__GetCertificateResponse </a></code></td><td> CCMovelDigitalSignature.h:363 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__ValidateOtp"> _ns3__ValidateOtp </a></code></td><td> CCMovelDigitalSignature.h:365 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__ValidateOtpResponse"> _ns3__ValidateOtpResponse </a></code></td><td> CCMovelDigitalSignature.h:367 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__CCMovelMultipleSign"> _ns3__CCMovelMultipleSign </a></code></td><td> CCMovelDigitalSignature.h:369 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__CCMovelMultipleSignResponse"> _ns3__CCMovelMultipleSignResponse </a></code></td><td> CCMovelDigitalSignature.h:371 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__ForceSMS"> _ns3__ForceSMS </a></code></td><td> CCMovelDigitalSignature.h:373 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__ForceSMSResponse"> _ns3__ForceSMSResponse </a></code></td><td> CCMovelDigitalSignature.h:375 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__GetCertificateWithPin"> _ns3__GetCertificateWithPin </a></code></td><td> CCMovelDigitalSignature.h:377 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns3__GetCertificateWithPinResponse"> _ns3__GetCertificateWithPinResponse </a></code></td><td> CCMovelDigitalSignature.h:379 </td><td> yes </td></tr>
<tr><td><code><a href="#ns5__SignRequest"> ns5__SignRequest </a></code></td><td> CCMovelDigitalSignature.h:381 </td><td> yes </td></tr>
<tr><td><code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code></td><td> CCMovelDigitalSignature.h:383 </td><td> yes </td></tr>
<tr><td><code><a href="#ns5__SignResponse"> ns5__SignResponse </a></code></td><td> CCMovelDigitalSignature.h:385 </td><td> yes </td></tr>
<tr><td><code><a href="#ns5__ArrayOfHashStructure"> ns5__ArrayOfHashStructure </a></code></td><td> CCMovelDigitalSignature.h:387 </td><td> yes </td></tr>
<tr><td><code><a href="#ns5__HashStructure"> ns5__HashStructure </a></code></td><td> CCMovelDigitalSignature.h:389 </td><td> yes </td></tr>
<tr><td><code><a href="#ns5__MultipleSignRequest"> ns5__MultipleSignRequest </a></code></td><td> CCMovelDigitalSignature.h:391 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__CCMovelSign"> struct __ns1__CCMovelSign </a></code></td><td> CCMovelDigitalSignature.h:1233 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__GetCertificate"> struct __ns1__GetCertificate </a></code></td><td> CCMovelDigitalSignature.h:1303 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__ValidateOtp"> struct __ns1__ValidateOtp </a></code></td><td> CCMovelDigitalSignature.h:1373 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__CCMovelMultipleSign"> struct __ns1__CCMovelMultipleSign </a></code></td><td> CCMovelDigitalSignature.h:1443 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__ForceSMS"> struct __ns1__ForceSMS </a></code></td><td> CCMovelDigitalSignature.h:1513 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__GetCertificateWithPin"> struct __ns1__GetCertificateWithPin </a></code></td><td> CCMovelDigitalSignature.h:1583 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsu__Timestamp"> struct _wsu__Timestamp </a></code></td><td> wsu.h:77 </td><td> yes </td></tr>
<tr><td><code><a href="#wsse__EncodedString"> struct wsse__EncodedString </a></code></td><td> wsse.h:74 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__UsernameToken"> struct _wsse__UsernameToken </a></code></td><td> wsse.h:145 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__BinarySecurityToken"> struct _wsse__BinarySecurityToken </a></code></td><td> wsse.h:158 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__Reference"> struct _wsse__Reference </a></code></td><td> wsse.h:168 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__Embedded"> struct _wsse__Embedded </a></code></td><td> wsse.h:176 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__KeyIdentifier"> struct _wsse__KeyIdentifier </a></code></td><td> wsse.h:185 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__SecurityTokenReference"> struct _wsse__SecurityTokenReference </a></code></td><td> wsse.h:195 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__KeyInfoType"> struct ds__KeyInfoType </a></code></td><td> xenc.h:38 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__SignatureType"> struct ds__SignatureType </a></code></td><td> ds.h:50 </td><td> yes </td></tr>
<tr><td><code><a href="#_c14n__InclusiveNamespaces"> struct _c14n__InclusiveNamespaces </a></code></td><td> c14n.h:24 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__TransformType"> struct ds__TransformType </a></code></td><td> ds.h:77 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__SignedInfoType"> struct ds__SignedInfoType </a></code></td><td> ds.h:50 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__CanonicalizationMethodType"> struct ds__CanonicalizationMethodType </a></code></td><td> ds.h:63 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__SignatureMethodType"> struct ds__SignatureMethodType </a></code></td><td> ds.h:66 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__ReferenceType"> struct ds__ReferenceType </a></code></td><td> ds.h:69 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__TransformsType"> struct ds__TransformsType </a></code></td><td> ds.h:72 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__DigestMethodType"> struct ds__DigestMethodType </a></code></td><td> ds.h:83 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__KeyValueType"> struct ds__KeyValueType </a></code></td><td> ds.h:88 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__RetrievalMethodType"> struct ds__RetrievalMethodType </a></code></td><td> ds.h:89 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__X509DataType"> struct ds__X509DataType </a></code></td><td> wsse.h:198 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__X509IssuerSerialType"> struct ds__X509IssuerSerialType </a></code></td><td> ds.h:106 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__DSAKeyValueType"> struct ds__DSAKeyValueType </a></code></td><td> ds.h:127 </td><td> yes </td></tr>
<tr><td><code><a href="#ds__RSAKeyValueType"> struct ds__RSAKeyValueType </a></code></td><td> ds.h:130 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__EncryptionPropertyType"> struct xenc__EncryptionPropertyType </a></code></td><td> xenc.h:101 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__EncryptedType"> struct xenc__EncryptedType </a></code></td><td> xenc.h:70 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__EncryptionMethodType"> struct xenc__EncryptionMethodType </a></code></td><td> xenc.h:73 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__CipherDataType"> struct xenc__CipherDataType </a></code></td><td> xenc.h:76 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__CipherReferenceType"> struct xenc__CipherReferenceType </a></code></td><td> xenc.h:79 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__TransformsType"> struct xenc__TransformsType </a></code></td><td> xenc.h:82 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__AgreementMethodType"> struct xenc__AgreementMethodType </a></code></td><td> xenc.h:91 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__ReferenceType"> struct xenc__ReferenceType </a></code></td><td> xenc.h:94 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__EncryptionPropertiesType"> struct xenc__EncryptionPropertiesType </a></code></td><td> xenc.h:97 </td><td> yes </td></tr>
<tr><td><code><a href="#__xenc__union_ReferenceList"> struct __xenc__union_ReferenceList </a></code></td><td> xenc.h:253 </td><td> yes </td></tr>
<tr><td><code><a href="#_xenc__ReferenceList"> struct _xenc__ReferenceList </a></code></td><td> xenc.h:106 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__EncryptedDataType"> struct xenc__EncryptedDataType </a></code></td><td> xenc.h:85 </td><td> yes </td></tr>
<tr><td><code><a href="#xenc__EncryptedKeyType"> struct xenc__EncryptedKeyType </a></code></td><td> xenc.h:39 </td><td> yes </td></tr>
<tr><td><code><a href="#wsc__SecurityContextTokenType"> struct wsc__SecurityContextTokenType </a></code></td><td> wsc.h:88 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsc__union_DerivedKeyTokenType"> union _wsc__union_DerivedKeyTokenType </a></code></td><td> wsc.h:121 </td><td> yes </td></tr>
<tr><td><code><a href="#__wsc__DerivedKeyTokenType_sequence"> struct __wsc__DerivedKeyTokenType_sequence </a></code></td><td> wsc.h:117 </td><td> yes </td></tr>
<tr><td><code><a href="#wsc__DerivedKeyTokenType"> struct wsc__DerivedKeyTokenType </a></code></td><td> wsc.h:110 </td><td> yes </td></tr>
<tr><td><code><a href="#wsc__PropertiesType"> struct wsc__PropertiesType </a></code></td><td> wsc.h:114 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml1__union_AssertionType"> struct __saml1__union_AssertionType </a></code></td><td> saml1.h:181 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AssertionType"> struct saml1__AssertionType </a></code></td><td> saml1.h:75 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml1__union_ConditionsType"> struct __saml1__union_ConditionsType </a></code></td><td> saml1.h:224 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__ConditionsType"> struct saml1__ConditionsType </a></code></td><td> saml1.h:78 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__ConditionAbstractType"> struct saml1__ConditionAbstractType </a></code></td><td> saml1.h:81 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml1__union_AdviceType"> struct __saml1__union_AdviceType </a></code></td><td> saml1.h:270 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AdviceType"> struct saml1__AdviceType </a></code></td><td> saml1.h:90 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__StatementAbstractType"> struct saml1__StatementAbstractType </a></code></td><td> saml1.h:93 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__SubjectType"> struct saml1__SubjectType </a></code></td><td> saml1.h:99 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__SubjectConfirmationType"> struct saml1__SubjectConfirmationType </a></code></td><td> saml1.h:105 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__SubjectLocalityType"> struct saml1__SubjectLocalityType </a></code></td><td> saml1.h:111 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AuthorityBindingType"> struct saml1__AuthorityBindingType </a></code></td><td> saml1.h:114 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml1__union_EvidenceType"> struct __saml1__union_EvidenceType </a></code></td><td> saml1.h:395 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__EvidenceType"> struct saml1__EvidenceType </a></code></td><td> saml1.h:123 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AttributeDesignatorType"> struct saml1__AttributeDesignatorType </a></code></td><td> saml1.h:129 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AudienceRestrictionConditionType"> struct saml1__AudienceRestrictionConditionType </a></code></td><td> saml1.h:84 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__DoNotCacheConditionType"> struct saml1__DoNotCacheConditionType </a></code></td><td> saml1.h:87 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__SubjectStatementAbstractType"> struct saml1__SubjectStatementAbstractType </a></code></td><td> saml1.h:96 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__NameIdentifierType"> struct saml1__NameIdentifierType </a></code></td><td> saml1.h:102 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__ActionType"> struct saml1__ActionType </a></code></td><td> saml1.h:120 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AttributeType"> struct saml1__AttributeType </a></code></td><td> saml1.h:132 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AuthenticationStatementType"> struct saml1__AuthenticationStatementType </a></code></td><td> saml1.h:108 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AuthorizationDecisionStatementType"> struct saml1__AuthorizationDecisionStatementType </a></code></td><td> saml1.h:117 </td><td> yes </td></tr>
<tr><td><code><a href="#saml1__AttributeStatementType"> struct saml1__AttributeStatementType </a></code></td><td> saml1.h:126 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__BaseIDAbstractType"> struct saml2__BaseIDAbstractType </a></code></td><td> saml2.h:75 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__EncryptedElementType"> struct saml2__EncryptedElementType </a></code></td><td> saml2.h:81 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml2__union_AssertionType"> struct __saml2__union_AssertionType </a></code></td><td> saml2.h:234 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AssertionType"> struct saml2__AssertionType </a></code></td><td> saml2.h:84 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__SubjectType"> struct saml2__SubjectType </a></code></td><td> saml2.h:87 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__SubjectConfirmationType"> struct saml2__SubjectConfirmationType </a></code></td><td> saml2.h:90 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml2__union_ConditionsType"> struct __saml2__union_ConditionsType </a></code></td><td> saml2.h:327 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__ConditionsType"> struct saml2__ConditionsType </a></code></td><td> saml2.h:99 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__ConditionAbstractType"> struct saml2__ConditionAbstractType </a></code></td><td> saml2.h:102 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml2__union_AdviceType"> struct __saml2__union_AdviceType </a></code></td><td> saml2.h:376 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AdviceType"> struct saml2__AdviceType </a></code></td><td> saml2.h:114 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__StatementAbstractType"> struct saml2__StatementAbstractType </a></code></td><td> saml2.h:117 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__SubjectLocalityType"> struct saml2__SubjectLocalityType </a></code></td><td> saml2.h:123 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AuthnContextType"> struct saml2__AuthnContextType </a></code></td><td> saml2.h:126 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml2__union_EvidenceType"> struct __saml2__union_EvidenceType </a></code></td><td> saml2.h:479 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__EvidenceType"> struct saml2__EvidenceType </a></code></td><td> saml2.h:135 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AttributeType"> struct saml2__AttributeType </a></code></td><td> saml2.h:141 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__NameIDType"> struct saml2__NameIDType </a></code></td><td> saml2.h:78 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__SubjectConfirmationDataType"> struct saml2__SubjectConfirmationDataType </a></code></td><td> saml2.h:93 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AudienceRestrictionType"> struct saml2__AudienceRestrictionType </a></code></td><td> saml2.h:105 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__OneTimeUseType"> struct saml2__OneTimeUseType </a></code></td><td> saml2.h:108 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__ProxyRestrictionType"> struct saml2__ProxyRestrictionType </a></code></td><td> saml2.h:111 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AuthnStatementType"> struct saml2__AuthnStatementType </a></code></td><td> saml2.h:120 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AuthzDecisionStatementType"> struct saml2__AuthzDecisionStatementType </a></code></td><td> saml2.h:129 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__ActionType"> struct saml2__ActionType </a></code></td><td> saml2.h:132 </td><td> yes </td></tr>
<tr><td><code><a href="#__saml2__union_AttributeStatementType"> struct __saml2__union_AttributeStatementType </a></code></td><td> saml2.h:729 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__AttributeStatementType"> struct saml2__AttributeStatementType </a></code></td><td> saml2.h:138 </td><td> yes </td></tr>
<tr><td><code><a href="#saml2__KeyInfoConfirmationDataType"> struct saml2__KeyInfoConfirmationDataType </a></code></td><td> saml2.h:96 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__Security"> struct _wsse__Security </a></code></td><td> wsse.h:212 </td><td> yes </td></tr>
<tr><td><code><a href="#_wsse__Password"> struct _wsse__Password </a></code></td><td> wsse.h:146 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td> wsse.h:244 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td> CCMovelDigitalSignature.h:1975 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td> CCMovelDigitalSignature.h:1975 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td> CCMovelDigitalSignature.h:1975 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td> CCMovelDigitalSignature.h:1975 </td><td> yes </td></tr>
</table>

<a name="xsd__anyType"></a>

### `xsd__anyType`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 171, is a simple content wrapper *`xsd:anyType`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__ID__"> xsd__ID__ </a></code> is a derived class of this base class
- <code><a href="#xsd__IDREF__"> xsd__IDREF__ </a></code> is a derived class of this base class
- <code><a href="#xsd__QName__"> xsd__QName__ </a></code> is a derived class of this base class
- <code><a href="#xsd__anyURI__"> xsd__anyURI__ </a></code> is a derived class of this base class
- <code><a href="#xsd__base64Binary__"> xsd__base64Binary__ </a></code> is a derived class of this base class
- <code><a href="#xsd__boolean_"> xsd__boolean_ </a></code> is a derived class of this base class
- <code><a href="#xsd__byte__"> xsd__byte__ </a></code> is a derived class of this base class
- <code><a href="#xsd__dateTime_"> xsd__dateTime_ </a></code> is a derived class of this base class
- <code><a href="#xsd__decimal__"> xsd__decimal__ </a></code> is a derived class of this base class
- <code><a href="#xsd__double_"> xsd__double_ </a></code> is a derived class of this base class
- <code><a href="#xsd__duration__"> xsd__duration__ </a></code> is a derived class of this base class
- <code><a href="#xsd__float_"> xsd__float_ </a></code> is a derived class of this base class
- <code><a href="#xsd__int_"> xsd__int_ </a></code> is a derived class of this base class
- <code><a href="#xsd__long_"> xsd__long_ </a></code> is a derived class of this base class
- <code><a href="#xsd__short_"> xsd__short_ </a></code> is a derived class of this base class
- <code><a href="#xsd__string_"> xsd__string_ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedByte__"> xsd__unsignedByte__ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedInt_"> xsd__unsignedInt_ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedLong_"> xsd__unsignedLong_ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedShort_"> xsd__unsignedShort_ </a></code> is a derived class of this base class
- <code><a href="#ns4__char__"> ns4__char__ </a></code> is a derived class of this base class
- <code><a href="#ns4__duration__"> ns4__duration__ </a></code> is a derived class of this base class
- <code><a href="#ns4__guid__"> ns4__guid__ </a></code> is a derived class of this base class
- <code><a href="#ns5__SignRequest"> ns5__SignRequest </a></code> is a derived class of this base class
- <code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code> is a derived class of this base class
- <code><a href="#ns5__SignResponse"> ns5__SignResponse </a></code> is a derived class of this base class
- <code><a href="#ns5__ArrayOfHashStructure"> ns5__ArrayOfHashStructure </a></code> is a derived class of this base class
- <code><a href="#ns5__HashStructure"> ns5__HashStructure </a></code> is a derived class of this base class
- <code><a href="#ns5__MultipleSignRequest"> ns5__MultipleSignRequest </a></code> is a derived class of this base class
- `char *__item` is simple content of XML schema type *`xsd:anyType`* wrapped in *`xsd:anyType`*, where the type of this member is <code><a href="#_XML"> _XML </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct soap *soap` the context that manages this object

The following operations on `xsd__anyType` are available:

- `xsd__anyType *soap_new_xsd__anyType(struct soap*)` managed allocation with default initialization
- `xsd__anyType *soap_new_xsd__anyType(struct soap*, int n)` managed allocation of array `xsd__anyType[n]`
- `xsd__anyType *soap_new_req_xsd__anyType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__anyType *soap_new_set_xsd__anyType(struct soap*, char *__item)` managed allocation with public members assigned the values of these parameters
- `void xsd__anyType::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__anyType(struct soap*, const xsd__anyType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__anyType(struct soap*, const char *URL, const xsd__anyType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__anyType(struct soap*, const char *URL, const xsd__anyType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__anyType(struct soap*, const char *URL, const xsd__anyType*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__anyType(struct soap*, xsd__anyType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__anyType(struct soap*, const char *URL, xsd__anyType*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__anyType(struct soap*, xsd__anyType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__base64Binary"></a>

### `xsd__base64Binary`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 181, is an attachment, meaning binary data attached as a MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64 with `__ptr` pointing to the data of length `__size` and `id`, `type`, and `options` identifying and describing the attachment data (use the `SOAP_ENC_MTOM` or the `SOAP_ENC_MIME` flag and set at least `type` to create an attachment ), and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
    };

The following operations on `xsd__base64Binary` are available:

- `xsd__base64Binary *soap_new_xsd__base64Binary(struct soap*)` managed allocation with default initialization
- `xsd__base64Binary *soap_new_xsd__base64Binary(struct soap*, int n)` managed allocation of array `xsd__base64Binary[n]`
- `xsd__base64Binary *soap_new_req_xsd__base64Binary(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__base64Binary *soap_new_set_xsd__base64Binary(struct soap*, unsigned char *__ptr, int __size, char *id, char *type, char *options)` managed allocation with public members assigned the values of these parameters
- `void xsd__base64Binary::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__base64Binary(struct soap*, const xsd__base64Binary*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__base64Binary(struct soap*, const char *URL, const xsd__base64Binary*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__base64Binary(struct soap*, const char *URL, const xsd__base64Binary*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__base64Binary(struct soap*, const char *URL, const xsd__base64Binary*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__base64Binary(struct soap*, xsd__base64Binary*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__base64Binary(struct soap*, const char *URL, xsd__base64Binary*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__base64Binary(struct soap*, xsd__base64Binary*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__ID__"></a>

### `xsd__ID__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 199, is a simple content wrapper *`xsd:ID`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__ID__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:ID' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__ID__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__ID__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID__, default initialized and not managed by a soap context
        virtual xsd__ID__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__ID__); }
      public:
        /// Constructor with default initializations
        xsd__ID__() : __item() { }
        virtual ~xsd__ID__() { }
        /// Friend allocator used by soap_new_xsd__ID__(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID__ * SOAP_FMAC2 soap_instantiate_xsd__ID__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`xsd:ID`* wrapped in *`xsd:ID`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__ID__` are available:

- `xsd__ID__ *soap_new_xsd__ID__(struct soap*)` managed allocation with default initialization
- `xsd__ID__ *soap_new_xsd__ID__(struct soap*, int n)` managed allocation of array `xsd__ID__[n]`
- `xsd__ID__ *soap_new_req_xsd__ID__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__ID__ *soap_new_set_xsd__ID__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__ID__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__ID__(struct soap*, const xsd__ID__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__ID__(struct soap*, const char *URL, const xsd__ID__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__ID__(struct soap*, const char *URL, const xsd__ID__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__ID__(struct soap*, const char *URL, const xsd__ID__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__ID__(struct soap*, xsd__ID__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__ID__(struct soap*, const char *URL, xsd__ID__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__ID__(struct soap*, xsd__ID__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__IDREF__"></a>

### `xsd__IDREF__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 209, is a simple content wrapper *`xsd:IDREF`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__IDREF__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:IDREF' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__IDREF__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__IDREF__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF__, default initialized and not managed by a soap context
        virtual xsd__IDREF__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__IDREF__); }
      public:
        /// Constructor with default initializations
        xsd__IDREF__() : __item() { }
        virtual ~xsd__IDREF__() { }
        /// Friend allocator used by soap_new_xsd__IDREF__(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF__ * SOAP_FMAC2 soap_instantiate_xsd__IDREF__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`xsd:IDREF`* wrapped in *`xsd:IDREF`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__IDREF__` are available:

- `xsd__IDREF__ *soap_new_xsd__IDREF__(struct soap*)` managed allocation with default initialization
- `xsd__IDREF__ *soap_new_xsd__IDREF__(struct soap*, int n)` managed allocation of array `xsd__IDREF__[n]`
- `xsd__IDREF__ *soap_new_req_xsd__IDREF__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__IDREF__ *soap_new_set_xsd__IDREF__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__IDREF__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__IDREF__(struct soap*, const xsd__IDREF__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__IDREF__(struct soap*, const char *URL, const xsd__IDREF__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__IDREF__(struct soap*, const char *URL, const xsd__IDREF__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__IDREF__(struct soap*, const char *URL, const xsd__IDREF__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__IDREF__(struct soap*, xsd__IDREF__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__IDREF__(struct soap*, const char *URL, xsd__IDREF__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__IDREF__(struct soap*, xsd__IDREF__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__QName__"></a>

### `xsd__QName__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 216, is a simple content wrapper *`xsd:QName`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__QName__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__QName__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName__, default initialized and not managed by a soap context
        virtual xsd__QName__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__QName__); }
      public:
        /// Constructor with default initializations
        xsd__QName__() : __item() { }
        virtual ~xsd__QName__() { }
        /// Friend allocator used by soap_new_xsd__QName__(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 soap_instantiate_xsd__QName__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`xsd:QName`* wrapped in *`xsd:QName`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__QName__` are available:

- `xsd__QName__ *soap_new_xsd__QName__(struct soap*)` managed allocation with default initialization
- `xsd__QName__ *soap_new_xsd__QName__(struct soap*, int n)` managed allocation of array `xsd__QName__[n]`
- `xsd__QName__ *soap_new_req_xsd__QName__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__QName__ *soap_new_set_xsd__QName__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__QName__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__QName__(struct soap*, const xsd__QName__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__QName__(struct soap*, const char *URL, const xsd__QName__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__QName__(struct soap*, const char *URL, const xsd__QName__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__QName__(struct soap*, const char *URL, const xsd__QName__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__QName__(struct soap*, xsd__QName__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__QName__(struct soap*, const char *URL, xsd__QName__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__QName__(struct soap*, xsd__QName__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__anyURI__"></a>

### `xsd__anyURI__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 226, is a simple content wrapper *`xsd:anyURI`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__anyURI__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyURI__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI__, default initialized and not managed by a soap context
        virtual xsd__anyURI__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyURI__); }
      public:
        /// Constructor with default initializations
        xsd__anyURI__() : __item() { }
        virtual ~xsd__anyURI__() { }
        /// Friend allocator used by soap_new_xsd__anyURI__(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 soap_instantiate_xsd__anyURI__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`xsd:anyURI`* wrapped in *`xsd:anyURI`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__anyURI__` are available:

- `xsd__anyURI__ *soap_new_xsd__anyURI__(struct soap*)` managed allocation with default initialization
- `xsd__anyURI__ *soap_new_xsd__anyURI__(struct soap*, int n)` managed allocation of array `xsd__anyURI__[n]`
- `xsd__anyURI__ *soap_new_req_xsd__anyURI__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__anyURI__ *soap_new_set_xsd__anyURI__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__anyURI__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__anyURI__(struct soap*, const xsd__anyURI__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__anyURI__(struct soap*, const char *URL, const xsd__anyURI__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__anyURI__(struct soap*, const char *URL, const xsd__anyURI__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__anyURI__(struct soap*, const char *URL, const xsd__anyURI__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__anyURI__(struct soap*, xsd__anyURI__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__anyURI__(struct soap*, const char *URL, xsd__anyURI__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__anyURI__(struct soap*, xsd__anyURI__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__base64Binary__"></a>

### `xsd__base64Binary__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 233, is a simple content wrapper *`xsd:base64Binary`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__base64Binary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary__, default initialized and not managed by a soap context
        virtual xsd__base64Binary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary__); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary__() : __item() { }
        virtual ~xsd__base64Binary__() { }
        /// Friend allocator used by soap_new_xsd__base64Binary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `xsd__base64Binary __item` is simple content of XML schema type *`xsd:base64Binary`* wrapped in *`xsd:base64Binary`*, where the type of this member is <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__base64Binary__` are available:

- `xsd__base64Binary__ *soap_new_xsd__base64Binary__(struct soap*)` managed allocation with default initialization
- `xsd__base64Binary__ *soap_new_xsd__base64Binary__(struct soap*, int n)` managed allocation of array `xsd__base64Binary__[n]`
- `xsd__base64Binary__ *soap_new_req_xsd__base64Binary__(struct soap*, const xsd__base64Binary& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__base64Binary__ *soap_new_set_xsd__base64Binary__(struct soap*, const xsd__base64Binary& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__base64Binary__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__base64Binary__(struct soap*, const xsd__base64Binary__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__base64Binary__(struct soap*, const char *URL, const xsd__base64Binary__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__base64Binary__(struct soap*, const char *URL, const xsd__base64Binary__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__base64Binary__(struct soap*, const char *URL, const xsd__base64Binary__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__base64Binary__(struct soap*, xsd__base64Binary__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__base64Binary__(struct soap*, const char *URL, xsd__base64Binary__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__base64Binary__(struct soap*, xsd__base64Binary__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__boolean_"></a>

### `xsd__boolean_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 240, is a simple content wrapper *`xsd:boolean`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__boolean_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean_, default initialized and not managed by a soap context
        virtual xsd__boolean_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__boolean_); }
      public:
        /// Constructor with default initializations
        xsd__boolean_() : __item() { }
        virtual ~xsd__boolean_() { }
        /// Friend allocator used by soap_new_xsd__boolean_(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 soap_instantiate_xsd__boolean_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `bool __item` is simple content of XML schema type *`xsd:boolean`* wrapped in *`xsd:boolean`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__boolean_` are available:

- `xsd__boolean_ *soap_new_xsd__boolean_(struct soap*)` managed allocation with default initialization
- `xsd__boolean_ *soap_new_xsd__boolean_(struct soap*, int n)` managed allocation of array `xsd__boolean_[n]`
- `xsd__boolean_ *soap_new_req_xsd__boolean_(struct soap*, bool __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__boolean_ *soap_new_set_xsd__boolean_(struct soap*, bool __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__boolean_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__boolean_(struct soap*, const xsd__boolean_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__boolean_(struct soap*, const char *URL, const xsd__boolean_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__boolean_(struct soap*, const char *URL, const xsd__boolean_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__boolean_(struct soap*, const char *URL, const xsd__boolean_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__boolean_(struct soap*, xsd__boolean_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__boolean_(struct soap*, const char *URL, xsd__boolean_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__boolean_(struct soap*, xsd__boolean_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__byte__"></a>

### `xsd__byte__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 247, is a simple content wrapper *`xsd:byte`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__byte__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__byte__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__byte__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte__, default initialized and not managed by a soap context
        virtual xsd__byte__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__byte__); }
      public:
        /// Constructor with default initializations
        xsd__byte__() : __item() { }
        virtual ~xsd__byte__() { }
        /// Friend allocator used by soap_new_xsd__byte__(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte__ * SOAP_FMAC2 soap_instantiate_xsd__byte__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char __item` is simple content of XML schema type *`xsd:byte`* wrapped in *`xsd:byte`*, where the type of this member is <code><a href="#xsd__byte"> xsd__byte </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__byte__` are available:

- `xsd__byte__ *soap_new_xsd__byte__(struct soap*)` managed allocation with default initialization
- `xsd__byte__ *soap_new_xsd__byte__(struct soap*, int n)` managed allocation of array `xsd__byte__[n]`
- `xsd__byte__ *soap_new_req_xsd__byte__(struct soap*, char __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__byte__ *soap_new_set_xsd__byte__(struct soap*, char __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__byte__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__byte__(struct soap*, const xsd__byte__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__byte__(struct soap*, const char *URL, const xsd__byte__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__byte__(struct soap*, const char *URL, const xsd__byte__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__byte__(struct soap*, const char *URL, const xsd__byte__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__byte__(struct soap*, xsd__byte__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__byte__(struct soap*, const char *URL, xsd__byte__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__byte__(struct soap*, xsd__byte__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__dateTime_"></a>

### `xsd__dateTime_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 254, is a simple content wrapper *`xsd:dateTime`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__dateTime_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__dateTime_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime_, default initialized and not managed by a soap context
        virtual xsd__dateTime_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__dateTime_); }
      public:
        /// Constructor with default initializations
        xsd__dateTime_() : __item() { }
        virtual ~xsd__dateTime_() { }
        /// Friend allocator used by soap_new_xsd__dateTime_(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 soap_instantiate_xsd__dateTime_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `time_t __item` is simple content of XML schema type *`xsd:dateTime`* wrapped in *`xsd:dateTime`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__dateTime_` are available:

- `xsd__dateTime_ *soap_new_xsd__dateTime_(struct soap*)` managed allocation with default initialization
- `xsd__dateTime_ *soap_new_xsd__dateTime_(struct soap*, int n)` managed allocation of array `xsd__dateTime_[n]`
- `xsd__dateTime_ *soap_new_req_xsd__dateTime_(struct soap*, time_t __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__dateTime_ *soap_new_set_xsd__dateTime_(struct soap*, time_t __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__dateTime_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__dateTime_(struct soap*, const xsd__dateTime_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__dateTime_(struct soap*, const char *URL, const xsd__dateTime_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__dateTime_(struct soap*, const char *URL, const xsd__dateTime_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__dateTime_(struct soap*, const char *URL, const xsd__dateTime_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__dateTime_(struct soap*, xsd__dateTime_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__dateTime_(struct soap*, const char *URL, xsd__dateTime_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__dateTime_(struct soap*, xsd__dateTime_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__decimal__"></a>

### `xsd__decimal__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 264, is a simple content wrapper *`xsd:decimal`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__decimal__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:decimal' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__decimal__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__decimal__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal__, default initialized and not managed by a soap context
        virtual xsd__decimal__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__decimal__); }
      public:
        /// Constructor with default initializations
        xsd__decimal__() : __item() { }
        virtual ~xsd__decimal__() { }
        /// Friend allocator used by soap_new_xsd__decimal__(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal__ * SOAP_FMAC2 soap_instantiate_xsd__decimal__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`xsd:decimal`* wrapped in *`xsd:decimal`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__decimal__` are available:

- `xsd__decimal__ *soap_new_xsd__decimal__(struct soap*)` managed allocation with default initialization
- `xsd__decimal__ *soap_new_xsd__decimal__(struct soap*, int n)` managed allocation of array `xsd__decimal__[n]`
- `xsd__decimal__ *soap_new_req_xsd__decimal__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__decimal__ *soap_new_set_xsd__decimal__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__decimal__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__decimal__(struct soap*, const xsd__decimal__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__decimal__(struct soap*, const char *URL, const xsd__decimal__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__decimal__(struct soap*, const char *URL, const xsd__decimal__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__decimal__(struct soap*, const char *URL, const xsd__decimal__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__decimal__(struct soap*, xsd__decimal__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__decimal__(struct soap*, const char *URL, xsd__decimal__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__decimal__(struct soap*, xsd__decimal__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__double_"></a>

### `xsd__double_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 271, is a simple content wrapper *`xsd:double`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__double_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__double_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double_, default initialized and not managed by a soap context
        virtual xsd__double_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__double_); }
      public:
        /// Constructor with default initializations
        xsd__double_() : __item() { }
        virtual ~xsd__double_() { }
        /// Friend allocator used by soap_new_xsd__double_(struct soap*, int)
        friend SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 soap_instantiate_xsd__double_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `double __item` is simple content of XML schema type *`xsd:double`* wrapped in *`xsd:double`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__double_` are available:

- `xsd__double_ *soap_new_xsd__double_(struct soap*)` managed allocation with default initialization
- `xsd__double_ *soap_new_xsd__double_(struct soap*, int n)` managed allocation of array `xsd__double_[n]`
- `xsd__double_ *soap_new_req_xsd__double_(struct soap*, double __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__double_ *soap_new_set_xsd__double_(struct soap*, double __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__double_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__double_(struct soap*, const xsd__double_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__double_(struct soap*, const char *URL, const xsd__double_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__double_(struct soap*, const char *URL, const xsd__double_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__double_(struct soap*, const char *URL, const xsd__double_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__double_(struct soap*, xsd__double_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__double_(struct soap*, const char *URL, xsd__double_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__double_(struct soap*, xsd__double_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__duration__"></a>

### `xsd__duration__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 281, is a simple content wrapper *`xsd:duration`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration__, default initialized and not managed by a soap context
        virtual xsd__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__duration__); }
      public:
        /// Constructor with default initializations
        xsd__duration__() : __item() { }
        virtual ~xsd__duration__() { }
        /// Friend allocator used by soap_new_xsd__duration__(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 soap_instantiate_xsd__duration__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`xsd:duration`* wrapped in *`xsd:duration`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__duration__` are available:

- `xsd__duration__ *soap_new_xsd__duration__(struct soap*)` managed allocation with default initialization
- `xsd__duration__ *soap_new_xsd__duration__(struct soap*, int n)` managed allocation of array `xsd__duration__[n]`
- `xsd__duration__ *soap_new_req_xsd__duration__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__duration__ *soap_new_set_xsd__duration__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__duration__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__duration__(struct soap*, const xsd__duration__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__duration__(struct soap*, const char *URL, const xsd__duration__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__duration__(struct soap*, const char *URL, const xsd__duration__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__duration__(struct soap*, const char *URL, const xsd__duration__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__duration__(struct soap*, xsd__duration__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__duration__(struct soap*, const char *URL, xsd__duration__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__duration__(struct soap*, xsd__duration__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__float_"></a>

### `xsd__float_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 288, is a simple content wrapper *`xsd:float`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__float_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__float_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float_, default initialized and not managed by a soap context
        virtual xsd__float_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__float_); }
      public:
        /// Constructor with default initializations
        xsd__float_() : __item() { }
        virtual ~xsd__float_() { }
        /// Friend allocator used by soap_new_xsd__float_(struct soap*, int)
        friend SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 soap_instantiate_xsd__float_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `float __item` is simple content of XML schema type *`xsd:float`* wrapped in *`xsd:float`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__float_` are available:

- `xsd__float_ *soap_new_xsd__float_(struct soap*)` managed allocation with default initialization
- `xsd__float_ *soap_new_xsd__float_(struct soap*, int n)` managed allocation of array `xsd__float_[n]`
- `xsd__float_ *soap_new_req_xsd__float_(struct soap*, float __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__float_ *soap_new_set_xsd__float_(struct soap*, float __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__float_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__float_(struct soap*, const xsd__float_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__float_(struct soap*, const char *URL, const xsd__float_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__float_(struct soap*, const char *URL, const xsd__float_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__float_(struct soap*, const char *URL, const xsd__float_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__float_(struct soap*, xsd__float_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__float_(struct soap*, const char *URL, xsd__float_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__float_(struct soap*, xsd__float_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__int_"></a>

### `xsd__int_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 295, is a simple content wrapper *`xsd:int`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__int_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__int_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int_, default initialized and not managed by a soap context
        virtual xsd__int_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__int_); }
      public:
        /// Constructor with default initializations
        xsd__int_() : __item() { }
        virtual ~xsd__int_() { }
        /// Friend allocator used by soap_new_xsd__int_(struct soap*, int)
        friend SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 soap_instantiate_xsd__int_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __item` is simple content of XML schema type *`xsd:int`* wrapped in *`xsd:int`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__int_` are available:

- `xsd__int_ *soap_new_xsd__int_(struct soap*)` managed allocation with default initialization
- `xsd__int_ *soap_new_xsd__int_(struct soap*, int n)` managed allocation of array `xsd__int_[n]`
- `xsd__int_ *soap_new_req_xsd__int_(struct soap*, int __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__int_ *soap_new_set_xsd__int_(struct soap*, int __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__int_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__int_(struct soap*, const xsd__int_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__int_(struct soap*, const char *URL, const xsd__int_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__int_(struct soap*, const char *URL, const xsd__int_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__int_(struct soap*, const char *URL, const xsd__int_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__int_(struct soap*, xsd__int_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__int_(struct soap*, const char *URL, xsd__int_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__int_(struct soap*, xsd__int_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__long_"></a>

### `xsd__long_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 302, is a simple content wrapper *`xsd:long`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__long_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__long_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long_, default initialized and not managed by a soap context
        virtual xsd__long_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__long_); }
      public:
        /// Constructor with default initializations
        xsd__long_() : __item() { }
        virtual ~xsd__long_() { }
        /// Friend allocator used by soap_new_xsd__long_(struct soap*, int)
        friend SOAP_FMAC1 xsd__long_ * SOAP_FMAC2 soap_instantiate_xsd__long_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `LONG64 __item` is simple content of XML schema type *`xsd:long`* wrapped in *`xsd:long`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__long_` are available:

- `xsd__long_ *soap_new_xsd__long_(struct soap*)` managed allocation with default initialization
- `xsd__long_ *soap_new_xsd__long_(struct soap*, int n)` managed allocation of array `xsd__long_[n]`
- `xsd__long_ *soap_new_req_xsd__long_(struct soap*, LONG64 __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__long_ *soap_new_set_xsd__long_(struct soap*, LONG64 __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__long_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__long_(struct soap*, const xsd__long_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__long_(struct soap*, const char *URL, const xsd__long_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__long_(struct soap*, const char *URL, const xsd__long_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__long_(struct soap*, const char *URL, const xsd__long_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__long_(struct soap*, xsd__long_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__long_(struct soap*, const char *URL, xsd__long_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__long_(struct soap*, xsd__long_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__short_"></a>

### `xsd__short_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 309, is a simple content wrapper *`xsd:short`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__short_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__short_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__short_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short_, default initialized and not managed by a soap context
        virtual xsd__short_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__short_); }
      public:
        /// Constructor with default initializations
        xsd__short_() : __item() { }
        virtual ~xsd__short_() { }
        /// Friend allocator used by soap_new_xsd__short_(struct soap*, int)
        friend SOAP_FMAC1 xsd__short_ * SOAP_FMAC2 soap_instantiate_xsd__short_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `short __item` is simple content of XML schema type *`xsd:short`* wrapped in *`xsd:short`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__short_` are available:

- `xsd__short_ *soap_new_xsd__short_(struct soap*)` managed allocation with default initialization
- `xsd__short_ *soap_new_xsd__short_(struct soap*, int n)` managed allocation of array `xsd__short_[n]`
- `xsd__short_ *soap_new_req_xsd__short_(struct soap*, short __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__short_ *soap_new_set_xsd__short_(struct soap*, short __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__short_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__short_(struct soap*, const xsd__short_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__short_(struct soap*, const char *URL, const xsd__short_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__short_(struct soap*, const char *URL, const xsd__short_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__short_(struct soap*, const char *URL, const xsd__short_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__short_(struct soap*, xsd__short_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__short_(struct soap*, const char *URL, xsd__short_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__short_(struct soap*, xsd__short_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__string_"></a>

### `xsd__string_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 316, is a simple content wrapper *`xsd:string`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__string_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string_, default initialized and not managed by a soap context
        virtual xsd__string_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__string_); }
      public:
        /// Constructor with default initializations
        xsd__string_() : __item() { }
        virtual ~xsd__string_() { }
        /// Friend allocator used by soap_new_xsd__string_(struct soap*, int)
        friend SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 soap_instantiate_xsd__string_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`xsd:string`* wrapped in *`xsd:string`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__string_` are available:

- `xsd__string_ *soap_new_xsd__string_(struct soap*)` managed allocation with default initialization
- `xsd__string_ *soap_new_xsd__string_(struct soap*, int n)` managed allocation of array `xsd__string_[n]`
- `xsd__string_ *soap_new_req_xsd__string_(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__string_ *soap_new_set_xsd__string_(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__string_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__string_(struct soap*, const xsd__string_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__string_(struct soap*, const char *URL, const xsd__string_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__string_(struct soap*, const char *URL, const xsd__string_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__string_(struct soap*, const char *URL, const xsd__string_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__string_(struct soap*, xsd__string_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__string_(struct soap*, const char *URL, xsd__string_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__string_(struct soap*, xsd__string_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedByte__"></a>

### `xsd__unsignedByte__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 323, is a simple content wrapper *`xsd:unsignedByte`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedByte__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedByte__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedByte__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte__, default initialized and not managed by a soap context
        virtual xsd__unsignedByte__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedByte__); }
      public:
        /// Constructor with default initializations
        xsd__unsignedByte__() : __item() { }
        virtual ~xsd__unsignedByte__() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte__(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte__ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `unsigned char __item` is simple content of XML schema type *`xsd:unsignedByte`* wrapped in *`xsd:unsignedByte`*, where the type of this member is <code><a href="#xsd__unsignedByte"> xsd__unsignedByte </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedByte__` are available:

- `xsd__unsignedByte__ *soap_new_xsd__unsignedByte__(struct soap*)` managed allocation with default initialization
- `xsd__unsignedByte__ *soap_new_xsd__unsignedByte__(struct soap*, int n)` managed allocation of array `xsd__unsignedByte__[n]`
- `xsd__unsignedByte__ *soap_new_req_xsd__unsignedByte__(struct soap*, unsigned char __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedByte__ *soap_new_set_xsd__unsignedByte__(struct soap*, unsigned char __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedByte__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedByte__(struct soap*, const xsd__unsignedByte__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedByte__(struct soap*, const char *URL, const xsd__unsignedByte__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedByte__(struct soap*, const char *URL, const xsd__unsignedByte__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedByte__(struct soap*, const char *URL, const xsd__unsignedByte__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedByte__(struct soap*, xsd__unsignedByte__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedByte__(struct soap*, const char *URL, xsd__unsignedByte__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedByte__(struct soap*, xsd__unsignedByte__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedInt_"></a>

### `xsd__unsignedInt_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 330, is a simple content wrapper *`xsd:unsignedInt`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedInt_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt_, default initialized and not managed by a soap context
        virtual xsd__unsignedInt_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedInt_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedInt_() : __item() { }
        virtual ~xsd__unsignedInt_() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `unsigned int __item` is simple content of XML schema type *`xsd:unsignedInt`* wrapped in *`xsd:unsignedInt`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedInt_` are available:

- `xsd__unsignedInt_ *soap_new_xsd__unsignedInt_(struct soap*)` managed allocation with default initialization
- `xsd__unsignedInt_ *soap_new_xsd__unsignedInt_(struct soap*, int n)` managed allocation of array `xsd__unsignedInt_[n]`
- `xsd__unsignedInt_ *soap_new_req_xsd__unsignedInt_(struct soap*, unsigned int __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedInt_ *soap_new_set_xsd__unsignedInt_(struct soap*, unsigned int __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedInt_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedInt_(struct soap*, const xsd__unsignedInt_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedInt_(struct soap*, const char *URL, const xsd__unsignedInt_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedInt_(struct soap*, const char *URL, const xsd__unsignedInt_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedInt_(struct soap*, const char *URL, const xsd__unsignedInt_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedInt_(struct soap*, xsd__unsignedInt_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedInt_(struct soap*, const char *URL, xsd__unsignedInt_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedInt_(struct soap*, xsd__unsignedInt_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedLong_"></a>

### `xsd__unsignedLong_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 337, is a simple content wrapper *`xsd:unsignedLong`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedLong_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong_, default initialized and not managed by a soap context
        virtual xsd__unsignedLong_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedLong_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedLong_() : __item() { }
        virtual ~xsd__unsignedLong_() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `ULONG64 __item` is simple content of XML schema type *`xsd:unsignedLong`* wrapped in *`xsd:unsignedLong`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedLong_` are available:

- `xsd__unsignedLong_ *soap_new_xsd__unsignedLong_(struct soap*)` managed allocation with default initialization
- `xsd__unsignedLong_ *soap_new_xsd__unsignedLong_(struct soap*, int n)` managed allocation of array `xsd__unsignedLong_[n]`
- `xsd__unsignedLong_ *soap_new_req_xsd__unsignedLong_(struct soap*, ULONG64 __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedLong_ *soap_new_set_xsd__unsignedLong_(struct soap*, ULONG64 __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedLong_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedLong_(struct soap*, const xsd__unsignedLong_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedLong_(struct soap*, const char *URL, const xsd__unsignedLong_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedLong_(struct soap*, const char *URL, const xsd__unsignedLong_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedLong_(struct soap*, const char *URL, const xsd__unsignedLong_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedLong_(struct soap*, xsd__unsignedLong_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedLong_(struct soap*, const char *URL, xsd__unsignedLong_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedLong_(struct soap*, xsd__unsignedLong_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedShort_"></a>

### `xsd__unsignedShort_`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 344, is a simple content wrapper *`xsd:unsignedShort`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedShort_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort_, default initialized and not managed by a soap context
        virtual xsd__unsignedShort_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedShort_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedShort_() : __item() { }
        virtual ~xsd__unsignedShort_() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `unsigned short __item` is simple content of XML schema type *`xsd:unsignedShort`* wrapped in *`xsd:unsignedShort`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedShort_` are available:

- `xsd__unsignedShort_ *soap_new_xsd__unsignedShort_(struct soap*)` managed allocation with default initialization
- `xsd__unsignedShort_ *soap_new_xsd__unsignedShort_(struct soap*, int n)` managed allocation of array `xsd__unsignedShort_[n]`
- `xsd__unsignedShort_ *soap_new_req_xsd__unsignedShort_(struct soap*, unsigned short __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedShort_ *soap_new_set_xsd__unsignedShort_(struct soap*, unsigned short __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedShort_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedShort_(struct soap*, const xsd__unsignedShort_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedShort_(struct soap*, const char *URL, const xsd__unsignedShort_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedShort_(struct soap*, const char *URL, const xsd__unsignedShort_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedShort_(struct soap*, const char *URL, const xsd__unsignedShort_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedShort_(struct soap*, xsd__unsignedShort_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedShort_(struct soap*, const char *URL, xsd__unsignedShort_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedShort_(struct soap*, xsd__unsignedShort_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns4__char__"></a>

### `ns4__char__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 432, is a simple content wrapper *`ns4:char`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns4__char__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns4:char' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_ns4__char__
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__char__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__char__, default initialized and not managed by a soap context
        virtual ns4__char__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__char__); }
      public:
        /// Constructor with default initializations
        ns4__char__() : __item() { }
        virtual ~ns4__char__() { }
        /// Friend allocator used by soap_new_ns4__char__(struct soap*, int)
        friend SOAP_FMAC1 ns4__char__ * SOAP_FMAC2 soap_instantiate_ns4__char__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __item` is simple content of XML schema type *`ns4:char`* wrapped in *`ns4:char`*, where the type of this member is <code><a href="#ns4__char"> ns4__char </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns4__char__` are available:

- `ns4__char__ *soap_new_ns4__char__(struct soap*)` managed allocation with default initialization
- `ns4__char__ *soap_new_ns4__char__(struct soap*, int n)` managed allocation of array `ns4__char__[n]`
- `ns4__char__ *soap_new_req_ns4__char__(struct soap*, int __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns4__char__ *soap_new_set_ns4__char__(struct soap*, int __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns4__char__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns4__char__(struct soap*, const ns4__char__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns4__char__(struct soap*, const char *URL, const ns4__char__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns4__char__(struct soap*, const char *URL, const ns4__char__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns4__char__(struct soap*, const char *URL, const ns4__char__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns4__char__(struct soap*, ns4__char__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns4__char__(struct soap*, const char *URL, ns4__char__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns4__char__(struct soap*, ns4__char__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns4__duration__"></a>

### `ns4__duration__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 446, is a simple content wrapper *`ns4:duration`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns4__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns4:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns4__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__duration__, default initialized and not managed by a soap context
        virtual ns4__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__duration__); }
      public:
        /// Constructor with default initializations
        ns4__duration__() : __item() { }
        virtual ~ns4__duration__() { }
        /// Friend allocator used by soap_new_ns4__duration__(struct soap*, int)
        friend SOAP_FMAC1 ns4__duration__ * SOAP_FMAC2 soap_instantiate_ns4__duration__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`ns4:duration`* wrapped in *`ns4:duration`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns4__duration__` are available:

- `ns4__duration__ *soap_new_ns4__duration__(struct soap*)` managed allocation with default initialization
- `ns4__duration__ *soap_new_ns4__duration__(struct soap*, int n)` managed allocation of array `ns4__duration__[n]`
- `ns4__duration__ *soap_new_req_ns4__duration__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns4__duration__ *soap_new_set_ns4__duration__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns4__duration__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns4__duration__(struct soap*, const ns4__duration__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns4__duration__(struct soap*, const char *URL, const ns4__duration__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns4__duration__(struct soap*, const char *URL, const ns4__duration__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns4__duration__(struct soap*, const char *URL, const ns4__duration__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns4__duration__(struct soap*, ns4__duration__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns4__duration__(struct soap*, const char *URL, ns4__duration__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns4__duration__(struct soap*, ns4__duration__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns4__guid__"></a>

### `ns4__guid__`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 459, is a simple content wrapper *`ns4:guid`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns4__guid__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns4:guid' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns4__guid__
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__guid__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__guid__, default initialized and not managed by a soap context
        virtual ns4__guid__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__guid__); }
      public:
        /// Constructor with default initializations
        ns4__guid__() : __item() { }
        virtual ~ns4__guid__() { }
        /// Friend allocator used by soap_new_ns4__guid__(struct soap*, int)
        friend SOAP_FMAC1 ns4__guid__ * SOAP_FMAC2 soap_instantiate_ns4__guid__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string __item` is simple content of XML schema type *`ns4:guid`* wrapped in *`ns4:guid`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns4__guid__` are available:

- `ns4__guid__ *soap_new_ns4__guid__(struct soap*)` managed allocation with default initialization
- `ns4__guid__ *soap_new_ns4__guid__(struct soap*, int n)` managed allocation of array `ns4__guid__[n]`
- `ns4__guid__ *soap_new_req_ns4__guid__(struct soap*, const std::string& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns4__guid__ *soap_new_set_ns4__guid__(struct soap*, const std::string& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns4__guid__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns4__guid__(struct soap*, const ns4__guid__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns4__guid__(struct soap*, const char *URL, const ns4__guid__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns4__guid__(struct soap*, const char *URL, const ns4__guid__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns4__guid__(struct soap*, const char *URL, const ns4__guid__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns4__guid__(struct soap*, ns4__guid__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns4__guid__(struct soap*, const char *URL, ns4__guid__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns4__guid__(struct soap*, ns4__guid__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__CCMovelSign"></a>

### `_ns3__CCMovelSign`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 357, is serialized as XML schema type *`ns3:CCMovelSign`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__CCMovelSign {
      public:
        /// Optional element 'ns3:request' of XML schema type 'ns5:SignRequest'
        ns5__SignRequest *request;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CCMovelSign
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__CCMovelSign; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CCMovelSign, default initialized and not managed by a soap context
        virtual _ns3__CCMovelSign *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__CCMovelSign); }
      public:
        /// Constructor with default initializations
        _ns3__CCMovelSign() : request(), soap() { }
        virtual ~_ns3__CCMovelSign() { }
        /// Friend allocator used by soap_new__ns3__CCMovelSign(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CCMovelSign * SOAP_FMAC2 soap_instantiate__ns3__CCMovelSign(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns5__SignRequest *request` is an optional element *`<ns3:request>`* of XML schema type *`ns5:SignRequest`*, where the type of this member is a pointer to <code><a href="#ns5__SignRequest"> ns5__SignRequest </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__CCMovelSign` are available:

- `_ns3__CCMovelSign *soap_new__ns3__CCMovelSign(struct soap*)` managed allocation with default initialization
- `_ns3__CCMovelSign *soap_new__ns3__CCMovelSign(struct soap*, int n)` managed allocation of array `_ns3__CCMovelSign[n]`
- `_ns3__CCMovelSign *soap_new_req__ns3__CCMovelSign(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__CCMovelSign *soap_new_set__ns3__CCMovelSign(struct soap*, ns5__SignRequest *request)` managed allocation with public members assigned the values of these parameters
- `void _ns3__CCMovelSign::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__CCMovelSign(struct soap*, const _ns3__CCMovelSign*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__CCMovelSign(struct soap*, const char *URL, const _ns3__CCMovelSign*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__CCMovelSign(struct soap*, const char *URL, const _ns3__CCMovelSign*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__CCMovelSign(struct soap*, const char *URL, const _ns3__CCMovelSign*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__CCMovelSign(struct soap*, _ns3__CCMovelSign*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__CCMovelSign(struct soap*, const char *URL, _ns3__CCMovelSign*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__CCMovelSign(struct soap*, _ns3__CCMovelSign*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__CCMovelSignResponse"></a>

### `_ns3__CCMovelSignResponse`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 359, is serialized as XML schema type *`ns3:CCMovelSignResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__CCMovelSignResponse {
      public:
        /// Optional element 'ns3:CCMovelSignResult' of XML schema type 'ns5:SignStatus'
        ns5__SignStatus *CCMovelSignResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CCMovelSignResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__CCMovelSignResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CCMovelSignResponse, default initialized and not managed by a soap context
        virtual _ns3__CCMovelSignResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__CCMovelSignResponse); }
      public:
        /// Constructor with default initializations
        _ns3__CCMovelSignResponse() : CCMovelSignResult(), soap() { }
        virtual ~_ns3__CCMovelSignResponse() { }
        /// Friend allocator used by soap_new__ns3__CCMovelSignResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CCMovelSignResponse * SOAP_FMAC2 soap_instantiate__ns3__CCMovelSignResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns5__SignStatus *CCMovelSignResult` is an optional element *`<ns3:CCMovelSignResult>`* of XML schema type *`ns5:SignStatus`*, where the type of this member is a pointer to <code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__CCMovelSignResponse` are available:

- `_ns3__CCMovelSignResponse *soap_new__ns3__CCMovelSignResponse(struct soap*)` managed allocation with default initialization
- `_ns3__CCMovelSignResponse *soap_new__ns3__CCMovelSignResponse(struct soap*, int n)` managed allocation of array `_ns3__CCMovelSignResponse[n]`
- `_ns3__CCMovelSignResponse *soap_new_req__ns3__CCMovelSignResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__CCMovelSignResponse *soap_new_set__ns3__CCMovelSignResponse(struct soap*, ns5__SignStatus *CCMovelSignResult)` managed allocation with public members assigned the values of these parameters
- `void _ns3__CCMovelSignResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__CCMovelSignResponse(struct soap*, const _ns3__CCMovelSignResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__CCMovelSignResponse(struct soap*, const char *URL, const _ns3__CCMovelSignResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__CCMovelSignResponse(struct soap*, const char *URL, const _ns3__CCMovelSignResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__CCMovelSignResponse(struct soap*, const char *URL, const _ns3__CCMovelSignResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__CCMovelSignResponse(struct soap*, _ns3__CCMovelSignResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__CCMovelSignResponse(struct soap*, const char *URL, _ns3__CCMovelSignResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__CCMovelSignResponse(struct soap*, _ns3__CCMovelSignResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__GetCertificate"></a>

### `_ns3__GetCertificate`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 361, is serialized as XML schema type *`ns3:GetCertificate`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__GetCertificate {
      public:
        /// Optional element 'ns3:applicationId' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *applicationId;
        /// Optional element 'ns3:userId' of XML schema type 'xsd:string'
        std::string *userId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCertificate
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCertificate, default initialized and not managed by a soap context
        virtual _ns3__GetCertificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__GetCertificate); }
      public:
        /// Constructor with default initializations
        _ns3__GetCertificate() : applicationId(), userId(), soap() { }
        virtual ~_ns3__GetCertificate() { }
        /// Friend allocator used by soap_new__ns3__GetCertificate(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCertificate * SOAP_FMAC2 soap_instantiate__ns3__GetCertificate(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `xsd__base64Binary *applicationId` is an optional element *`<ns3:applicationId>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `std::string *userId` is an optional element *`<ns3:userId>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__GetCertificate` are available:

- `_ns3__GetCertificate *soap_new__ns3__GetCertificate(struct soap*)` managed allocation with default initialization
- `_ns3__GetCertificate *soap_new__ns3__GetCertificate(struct soap*, int n)` managed allocation of array `_ns3__GetCertificate[n]`
- `_ns3__GetCertificate *soap_new_req__ns3__GetCertificate(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__GetCertificate *soap_new_set__ns3__GetCertificate(struct soap*, xsd__base64Binary *applicationId, std::string *userId)` managed allocation with public members assigned the values of these parameters
- `void _ns3__GetCertificate::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__GetCertificate(struct soap*, const _ns3__GetCertificate*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__GetCertificate(struct soap*, const char *URL, const _ns3__GetCertificate*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__GetCertificate(struct soap*, const char *URL, const _ns3__GetCertificate*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__GetCertificate(struct soap*, const char *URL, const _ns3__GetCertificate*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__GetCertificate(struct soap*, _ns3__GetCertificate*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__GetCertificate(struct soap*, const char *URL, _ns3__GetCertificate*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__GetCertificate(struct soap*, _ns3__GetCertificate*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__GetCertificateResponse"></a>

### `_ns3__GetCertificateResponse`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 363, is serialized as XML schema type *`ns3:GetCertificateResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__GetCertificateResponse {
      public:
        /// Optional element 'ns3:GetCertificateResult' of XML schema type 'xsd:string'
        std::string *GetCertificateResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCertificateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCertificateResponse, default initialized and not managed by a soap context
        virtual _ns3__GetCertificateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__GetCertificateResponse); }
      public:
        /// Constructor with default initializations
        _ns3__GetCertificateResponse() : GetCertificateResult(), soap() { }
        virtual ~_ns3__GetCertificateResponse() { }
        /// Friend allocator used by soap_new__ns3__GetCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCertificateResponse * SOAP_FMAC2 soap_instantiate__ns3__GetCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *GetCertificateResult` is an optional element *`<ns3:GetCertificateResult>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__GetCertificateResponse` are available:

- `_ns3__GetCertificateResponse *soap_new__ns3__GetCertificateResponse(struct soap*)` managed allocation with default initialization
- `_ns3__GetCertificateResponse *soap_new__ns3__GetCertificateResponse(struct soap*, int n)` managed allocation of array `_ns3__GetCertificateResponse[n]`
- `_ns3__GetCertificateResponse *soap_new_req__ns3__GetCertificateResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__GetCertificateResponse *soap_new_set__ns3__GetCertificateResponse(struct soap*, std::string *GetCertificateResult)` managed allocation with public members assigned the values of these parameters
- `void _ns3__GetCertificateResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__GetCertificateResponse(struct soap*, const _ns3__GetCertificateResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__GetCertificateResponse(struct soap*, const char *URL, const _ns3__GetCertificateResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__GetCertificateResponse(struct soap*, const char *URL, const _ns3__GetCertificateResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__GetCertificateResponse(struct soap*, const char *URL, const _ns3__GetCertificateResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__GetCertificateResponse(struct soap*, _ns3__GetCertificateResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__GetCertificateResponse(struct soap*, const char *URL, _ns3__GetCertificateResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__GetCertificateResponse(struct soap*, _ns3__GetCertificateResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__ValidateOtp"></a>

### `_ns3__ValidateOtp`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 365, is serialized as XML schema type *`ns3:ValidateOtp`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__ValidateOtp {
      public:
        /// Optional element 'ns3:code' of XML schema type 'xsd:string'
        std::string *code;
        /// Optional element 'ns3:processId' of XML schema type 'xsd:string'
        std::string *processId;
        /// Optional element 'ns3:applicationId' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *applicationId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ValidateOtp
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__ValidateOtp; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ValidateOtp, default initialized and not managed by a soap context
        virtual _ns3__ValidateOtp *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__ValidateOtp); }
      public:
        /// Constructor with default initializations
        _ns3__ValidateOtp() : code(), processId(), applicationId(), soap() { }
        virtual ~_ns3__ValidateOtp() { }
        /// Friend allocator used by soap_new__ns3__ValidateOtp(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ValidateOtp * SOAP_FMAC2 soap_instantiate__ns3__ValidateOtp(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *code` is an optional element *`<ns3:code>`* of XML schema type *`xsd:string`*
- `std::string *processId` is an optional element *`<ns3:processId>`* of XML schema type *`xsd:string`*
- `xsd__base64Binary *applicationId` is an optional element *`<ns3:applicationId>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__ValidateOtp` are available:

- `_ns3__ValidateOtp *soap_new__ns3__ValidateOtp(struct soap*)` managed allocation with default initialization
- `_ns3__ValidateOtp *soap_new__ns3__ValidateOtp(struct soap*, int n)` managed allocation of array `_ns3__ValidateOtp[n]`
- `_ns3__ValidateOtp *soap_new_req__ns3__ValidateOtp(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__ValidateOtp *soap_new_set__ns3__ValidateOtp(struct soap*, std::string *code, std::string *processId, xsd__base64Binary *applicationId)` managed allocation with public members assigned the values of these parameters
- `void _ns3__ValidateOtp::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__ValidateOtp(struct soap*, const _ns3__ValidateOtp*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__ValidateOtp(struct soap*, const char *URL, const _ns3__ValidateOtp*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__ValidateOtp(struct soap*, const char *URL, const _ns3__ValidateOtp*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__ValidateOtp(struct soap*, const char *URL, const _ns3__ValidateOtp*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__ValidateOtp(struct soap*, _ns3__ValidateOtp*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__ValidateOtp(struct soap*, const char *URL, _ns3__ValidateOtp*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__ValidateOtp(struct soap*, _ns3__ValidateOtp*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__ValidateOtpResponse"></a>

### `_ns3__ValidateOtpResponse`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 367, is serialized as XML schema type *`ns3:ValidateOtpResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__ValidateOtpResponse {
      public:
        /// Optional element 'ns3:ValidateOtpResult' of XML schema type 'ns5:SignResponse'
        ns5__SignResponse *ValidateOtpResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ValidateOtpResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__ValidateOtpResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ValidateOtpResponse, default initialized and not managed by a soap context
        virtual _ns3__ValidateOtpResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__ValidateOtpResponse); }
      public:
        /// Constructor with default initializations
        _ns3__ValidateOtpResponse() : ValidateOtpResult(), soap() { }
        virtual ~_ns3__ValidateOtpResponse() { }
        /// Friend allocator used by soap_new__ns3__ValidateOtpResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ValidateOtpResponse * SOAP_FMAC2 soap_instantiate__ns3__ValidateOtpResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns5__SignResponse *ValidateOtpResult` is an optional element *`<ns3:ValidateOtpResult>`* of XML schema type *`ns5:SignResponse`*, where the type of this member is a pointer to <code><a href="#ns5__SignResponse"> ns5__SignResponse </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__ValidateOtpResponse` are available:

- `_ns3__ValidateOtpResponse *soap_new__ns3__ValidateOtpResponse(struct soap*)` managed allocation with default initialization
- `_ns3__ValidateOtpResponse *soap_new__ns3__ValidateOtpResponse(struct soap*, int n)` managed allocation of array `_ns3__ValidateOtpResponse[n]`
- `_ns3__ValidateOtpResponse *soap_new_req__ns3__ValidateOtpResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__ValidateOtpResponse *soap_new_set__ns3__ValidateOtpResponse(struct soap*, ns5__SignResponse *ValidateOtpResult)` managed allocation with public members assigned the values of these parameters
- `void _ns3__ValidateOtpResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__ValidateOtpResponse(struct soap*, const _ns3__ValidateOtpResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__ValidateOtpResponse(struct soap*, const char *URL, const _ns3__ValidateOtpResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__ValidateOtpResponse(struct soap*, const char *URL, const _ns3__ValidateOtpResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__ValidateOtpResponse(struct soap*, const char *URL, const _ns3__ValidateOtpResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__ValidateOtpResponse(struct soap*, _ns3__ValidateOtpResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__ValidateOtpResponse(struct soap*, const char *URL, _ns3__ValidateOtpResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__ValidateOtpResponse(struct soap*, _ns3__ValidateOtpResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__CCMovelMultipleSign"></a>

### `_ns3__CCMovelMultipleSign`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 369, is serialized as XML schema type *`ns3:CCMovelMultipleSign`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__CCMovelMultipleSign {
      public:
        /// Optional element 'ns3:request' of XML schema type 'ns5:MultipleSignRequest'
        ns5__MultipleSignRequest *request;
        /// Optional element 'ns3:documents' of XML schema type 'ns5:ArrayOfHashStructure'
        ns5__ArrayOfHashStructure *documents;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CCMovelMultipleSign
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__CCMovelMultipleSign; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CCMovelMultipleSign, default initialized and not managed by a soap context
        virtual _ns3__CCMovelMultipleSign *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__CCMovelMultipleSign); }
      public:
        /// Constructor with default initializations
        _ns3__CCMovelMultipleSign() : request(), documents(), soap() { }
        virtual ~_ns3__CCMovelMultipleSign() { }
        /// Friend allocator used by soap_new__ns3__CCMovelMultipleSign(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CCMovelMultipleSign * SOAP_FMAC2 soap_instantiate__ns3__CCMovelMultipleSign(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns5__MultipleSignRequest *request` is an optional element *`<ns3:request>`* of XML schema type *`ns5:MultipleSignRequest`*, where the type of this member is a pointer to <code><a href="#ns5__MultipleSignRequest"> ns5__MultipleSignRequest </a></code>
- `ns5__ArrayOfHashStructure *documents` is an optional element *`<ns3:documents>`* of XML schema type *`ns5:ArrayOfHashStructure`*, where the type of this member is a pointer to <code><a href="#ns5__ArrayOfHashStructure"> ns5__ArrayOfHashStructure </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__CCMovelMultipleSign` are available:

- `_ns3__CCMovelMultipleSign *soap_new__ns3__CCMovelMultipleSign(struct soap*)` managed allocation with default initialization
- `_ns3__CCMovelMultipleSign *soap_new__ns3__CCMovelMultipleSign(struct soap*, int n)` managed allocation of array `_ns3__CCMovelMultipleSign[n]`
- `_ns3__CCMovelMultipleSign *soap_new_req__ns3__CCMovelMultipleSign(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__CCMovelMultipleSign *soap_new_set__ns3__CCMovelMultipleSign(struct soap*, ns5__MultipleSignRequest *request, ns5__ArrayOfHashStructure *documents)` managed allocation with public members assigned the values of these parameters
- `void _ns3__CCMovelMultipleSign::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__CCMovelMultipleSign(struct soap*, const _ns3__CCMovelMultipleSign*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__CCMovelMultipleSign(struct soap*, const char *URL, const _ns3__CCMovelMultipleSign*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__CCMovelMultipleSign(struct soap*, const char *URL, const _ns3__CCMovelMultipleSign*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__CCMovelMultipleSign(struct soap*, const char *URL, const _ns3__CCMovelMultipleSign*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__CCMovelMultipleSign(struct soap*, _ns3__CCMovelMultipleSign*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__CCMovelMultipleSign(struct soap*, const char *URL, _ns3__CCMovelMultipleSign*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__CCMovelMultipleSign(struct soap*, _ns3__CCMovelMultipleSign*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__CCMovelMultipleSignResponse"></a>

### `_ns3__CCMovelMultipleSignResponse`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 371, is serialized as XML schema type *`ns3:CCMovelMultipleSignResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__CCMovelMultipleSignResponse {
      public:
        /// Optional element 'ns3:CCMovelMultipleSignResult' of XML schema type 'ns5:SignStatus'
        ns5__SignStatus *CCMovelMultipleSignResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CCMovelMultipleSignResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__CCMovelMultipleSignResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CCMovelMultipleSignResponse, default initialized and not managed by a soap context
        virtual _ns3__CCMovelMultipleSignResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__CCMovelMultipleSignResponse); }
      public:
        /// Constructor with default initializations
        _ns3__CCMovelMultipleSignResponse() : CCMovelMultipleSignResult(), soap() { }
        virtual ~_ns3__CCMovelMultipleSignResponse() { }
        /// Friend allocator used by soap_new__ns3__CCMovelMultipleSignResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CCMovelMultipleSignResponse * SOAP_FMAC2 soap_instantiate__ns3__CCMovelMultipleSignResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns5__SignStatus *CCMovelMultipleSignResult` is an optional element *`<ns3:CCMovelMultipleSignResult>`* of XML schema type *`ns5:SignStatus`*, where the type of this member is a pointer to <code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__CCMovelMultipleSignResponse` are available:

- `_ns3__CCMovelMultipleSignResponse *soap_new__ns3__CCMovelMultipleSignResponse(struct soap*)` managed allocation with default initialization
- `_ns3__CCMovelMultipleSignResponse *soap_new__ns3__CCMovelMultipleSignResponse(struct soap*, int n)` managed allocation of array `_ns3__CCMovelMultipleSignResponse[n]`
- `_ns3__CCMovelMultipleSignResponse *soap_new_req__ns3__CCMovelMultipleSignResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__CCMovelMultipleSignResponse *soap_new_set__ns3__CCMovelMultipleSignResponse(struct soap*, ns5__SignStatus *CCMovelMultipleSignResult)` managed allocation with public members assigned the values of these parameters
- `void _ns3__CCMovelMultipleSignResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__CCMovelMultipleSignResponse(struct soap*, const _ns3__CCMovelMultipleSignResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__CCMovelMultipleSignResponse(struct soap*, const char *URL, const _ns3__CCMovelMultipleSignResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__CCMovelMultipleSignResponse(struct soap*, const char *URL, const _ns3__CCMovelMultipleSignResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__CCMovelMultipleSignResponse(struct soap*, const char *URL, const _ns3__CCMovelMultipleSignResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__CCMovelMultipleSignResponse(struct soap*, _ns3__CCMovelMultipleSignResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__CCMovelMultipleSignResponse(struct soap*, const char *URL, _ns3__CCMovelMultipleSignResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__CCMovelMultipleSignResponse(struct soap*, _ns3__CCMovelMultipleSignResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__ForceSMS"></a>

### `_ns3__ForceSMS`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 373, is serialized as XML schema type *`ns3:ForceSMS`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__ForceSMS {
      public:
        /// Optional element 'ns3:processId' of XML schema type 'xsd:string'
        std::string *processId;
        /// Optional element 'ns3:citizenId' of XML schema type 'xsd:string'
        std::string *citizenId;
        /// Optional element 'ns3:applicationId' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *applicationId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ForceSMS
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__ForceSMS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ForceSMS, default initialized and not managed by a soap context
        virtual _ns3__ForceSMS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__ForceSMS); }
      public:
        /// Constructor with default initializations
        _ns3__ForceSMS() : processId(), citizenId(), applicationId(), soap() { }
        virtual ~_ns3__ForceSMS() { }
        /// Friend allocator used by soap_new__ns3__ForceSMS(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ForceSMS * SOAP_FMAC2 soap_instantiate__ns3__ForceSMS(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *processId` is an optional element *`<ns3:processId>`* of XML schema type *`xsd:string`*
- `std::string *citizenId` is an optional element *`<ns3:citizenId>`* of XML schema type *`xsd:string`*
- `xsd__base64Binary *applicationId` is an optional element *`<ns3:applicationId>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__ForceSMS` are available:

- `_ns3__ForceSMS *soap_new__ns3__ForceSMS(struct soap*)` managed allocation with default initialization
- `_ns3__ForceSMS *soap_new__ns3__ForceSMS(struct soap*, int n)` managed allocation of array `_ns3__ForceSMS[n]`
- `_ns3__ForceSMS *soap_new_req__ns3__ForceSMS(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__ForceSMS *soap_new_set__ns3__ForceSMS(struct soap*, std::string *processId, std::string *citizenId, xsd__base64Binary *applicationId)` managed allocation with public members assigned the values of these parameters
- `void _ns3__ForceSMS::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__ForceSMS(struct soap*, const _ns3__ForceSMS*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__ForceSMS(struct soap*, const char *URL, const _ns3__ForceSMS*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__ForceSMS(struct soap*, const char *URL, const _ns3__ForceSMS*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__ForceSMS(struct soap*, const char *URL, const _ns3__ForceSMS*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__ForceSMS(struct soap*, _ns3__ForceSMS*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__ForceSMS(struct soap*, const char *URL, _ns3__ForceSMS*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__ForceSMS(struct soap*, _ns3__ForceSMS*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__ForceSMSResponse"></a>

### `_ns3__ForceSMSResponse`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 375, is serialized as XML schema type *`ns3:ForceSMSResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__ForceSMSResponse {
      public:
        /// Optional element 'ns3:ForceSMSResult' of XML schema type 'ns5:SignStatus'
        ns5__SignStatus *ForceSMSResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ForceSMSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__ForceSMSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ForceSMSResponse, default initialized and not managed by a soap context
        virtual _ns3__ForceSMSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__ForceSMSResponse); }
      public:
        /// Constructor with default initializations
        _ns3__ForceSMSResponse() : ForceSMSResult(), soap() { }
        virtual ~_ns3__ForceSMSResponse() { }
        /// Friend allocator used by soap_new__ns3__ForceSMSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ForceSMSResponse * SOAP_FMAC2 soap_instantiate__ns3__ForceSMSResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns5__SignStatus *ForceSMSResult` is an optional element *`<ns3:ForceSMSResult>`* of XML schema type *`ns5:SignStatus`*, where the type of this member is a pointer to <code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__ForceSMSResponse` are available:

- `_ns3__ForceSMSResponse *soap_new__ns3__ForceSMSResponse(struct soap*)` managed allocation with default initialization
- `_ns3__ForceSMSResponse *soap_new__ns3__ForceSMSResponse(struct soap*, int n)` managed allocation of array `_ns3__ForceSMSResponse[n]`
- `_ns3__ForceSMSResponse *soap_new_req__ns3__ForceSMSResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__ForceSMSResponse *soap_new_set__ns3__ForceSMSResponse(struct soap*, ns5__SignStatus *ForceSMSResult)` managed allocation with public members assigned the values of these parameters
- `void _ns3__ForceSMSResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__ForceSMSResponse(struct soap*, const _ns3__ForceSMSResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__ForceSMSResponse(struct soap*, const char *URL, const _ns3__ForceSMSResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__ForceSMSResponse(struct soap*, const char *URL, const _ns3__ForceSMSResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__ForceSMSResponse(struct soap*, const char *URL, const _ns3__ForceSMSResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__ForceSMSResponse(struct soap*, _ns3__ForceSMSResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__ForceSMSResponse(struct soap*, const char *URL, _ns3__ForceSMSResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__ForceSMSResponse(struct soap*, _ns3__ForceSMSResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__GetCertificateWithPin"></a>

### `_ns3__GetCertificateWithPin`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 377, is serialized as XML schema type *`ns3:GetCertificateWithPin`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__GetCertificateWithPin {
      public:
        /// Optional element 'ns3:applicationId' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *applicationId;
        /// Optional element 'ns3:userId' of XML schema type 'xsd:string'
        std::string *userId;
        /// Optional element 'ns3:signaturePin' of XML schema type 'xsd:string'
        std::string *signaturePin;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCertificateWithPin
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetCertificateWithPin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCertificateWithPin, default initialized and not managed by a soap context
        virtual _ns3__GetCertificateWithPin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__GetCertificateWithPin); }
      public:
        /// Constructor with default initializations
        _ns3__GetCertificateWithPin() : applicationId(), userId(), signaturePin(), soap() { }
        virtual ~_ns3__GetCertificateWithPin() { }
        /// Friend allocator used by soap_new__ns3__GetCertificateWithPin(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCertificateWithPin * SOAP_FMAC2 soap_instantiate__ns3__GetCertificateWithPin(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `xsd__base64Binary *applicationId` is an optional element *`<ns3:applicationId>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `std::string *userId` is an optional element *`<ns3:userId>`* of XML schema type *`xsd:string`*
- `std::string *signaturePin` is an optional element *`<ns3:signaturePin>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__GetCertificateWithPin` are available:

- `_ns3__GetCertificateWithPin *soap_new__ns3__GetCertificateWithPin(struct soap*)` managed allocation with default initialization
- `_ns3__GetCertificateWithPin *soap_new__ns3__GetCertificateWithPin(struct soap*, int n)` managed allocation of array `_ns3__GetCertificateWithPin[n]`
- `_ns3__GetCertificateWithPin *soap_new_req__ns3__GetCertificateWithPin(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__GetCertificateWithPin *soap_new_set__ns3__GetCertificateWithPin(struct soap*, xsd__base64Binary *applicationId, std::string *userId, std::string *signaturePin)` managed allocation with public members assigned the values of these parameters
- `void _ns3__GetCertificateWithPin::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__GetCertificateWithPin(struct soap*, const _ns3__GetCertificateWithPin*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__GetCertificateWithPin(struct soap*, const char *URL, const _ns3__GetCertificateWithPin*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__GetCertificateWithPin(struct soap*, const char *URL, const _ns3__GetCertificateWithPin*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__GetCertificateWithPin(struct soap*, const char *URL, const _ns3__GetCertificateWithPin*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__GetCertificateWithPin(struct soap*, _ns3__GetCertificateWithPin*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__GetCertificateWithPin(struct soap*, const char *URL, _ns3__GetCertificateWithPin*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__GetCertificateWithPin(struct soap*, _ns3__GetCertificateWithPin*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns3__GetCertificateWithPinResponse"></a>

### `_ns3__GetCertificateWithPinResponse`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 379, is serialized as XML schema type *`ns3:GetCertificateWithPinResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns3__GetCertificateWithPinResponse {
      public:
        /// Optional element 'ns3:GetCertificateWithPinResult' of XML schema type 'ns5:SignStatus'
        ns5__SignStatus *GetCertificateWithPinResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCertificateWithPinResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetCertificateWithPinResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCertificateWithPinResponse, default initialized and not managed by a soap context
        virtual _ns3__GetCertificateWithPinResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns3__GetCertificateWithPinResponse); }
      public:
        /// Constructor with default initializations
        _ns3__GetCertificateWithPinResponse() : GetCertificateWithPinResult(), soap() { }
        virtual ~_ns3__GetCertificateWithPinResponse() { }
        /// Friend allocator used by soap_new__ns3__GetCertificateWithPinResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCertificateWithPinResponse * SOAP_FMAC2 soap_instantiate__ns3__GetCertificateWithPinResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns5__SignStatus *GetCertificateWithPinResult` is an optional element *`<ns3:GetCertificateWithPinResult>`* of XML schema type *`ns5:SignStatus`*, where the type of this member is a pointer to <code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns3__GetCertificateWithPinResponse` are available:

- `_ns3__GetCertificateWithPinResponse *soap_new__ns3__GetCertificateWithPinResponse(struct soap*)` managed allocation with default initialization
- `_ns3__GetCertificateWithPinResponse *soap_new__ns3__GetCertificateWithPinResponse(struct soap*, int n)` managed allocation of array `_ns3__GetCertificateWithPinResponse[n]`
- `_ns3__GetCertificateWithPinResponse *soap_new_req__ns3__GetCertificateWithPinResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns3__GetCertificateWithPinResponse *soap_new_set__ns3__GetCertificateWithPinResponse(struct soap*, ns5__SignStatus *GetCertificateWithPinResult)` managed allocation with public members assigned the values of these parameters
- `void _ns3__GetCertificateWithPinResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns3__GetCertificateWithPinResponse(struct soap*, const _ns3__GetCertificateWithPinResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns3__GetCertificateWithPinResponse(struct soap*, const char *URL, const _ns3__GetCertificateWithPinResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns3__GetCertificateWithPinResponse(struct soap*, const char *URL, const _ns3__GetCertificateWithPinResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns3__GetCertificateWithPinResponse(struct soap*, const char *URL, const _ns3__GetCertificateWithPinResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns3__GetCertificateWithPinResponse(struct soap*, _ns3__GetCertificateWithPinResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns3__GetCertificateWithPinResponse(struct soap*, const char *URL, _ns3__GetCertificateWithPinResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns3__GetCertificateWithPinResponse(struct soap*, _ns3__GetCertificateWithPinResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns5__SignRequest"></a>

### `ns5__SignRequest`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 381, is serialized as XML schema type *`ns5:SignRequest`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns5__SignRequest : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns5:ApplicationId' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *ApplicationId;
        /// Optional element 'ns5:DocName' of XML schema type 'xsd:string'
        std::string *DocName;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Hash' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *Hash;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Pin' of XML schema type 'xsd:string'
        std::string *Pin;
        /// Required nillable (xsi:nil when NULL) element 'ns5:UserId' of XML schema type 'xsd:string'
        std::string *UserId;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SignRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__SignRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SignRequest, default initialized and not managed by a soap context
        virtual ns5__SignRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__SignRequest); }
      public:
        /// Constructor with default initializations
        ns5__SignRequest() : ApplicationId(), DocName(), Hash(), Pin(), UserId() { }
        virtual ~ns5__SignRequest() { }
        /// Friend allocator used by soap_new_ns5__SignRequest(struct soap*, int)
        friend SOAP_FMAC1 ns5__SignRequest * SOAP_FMAC2 soap_instantiate_ns5__SignRequest(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `xsd__base64Binary *ApplicationId` is a required nillable (xsi:nil when NULL) element *`<ns5:ApplicationId>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `std::string *DocName` is an optional element *`<ns5:DocName>`* of XML schema type *`xsd:string`*
- `xsd__base64Binary *Hash` is a required nillable (xsi:nil when NULL) element *`<ns5:Hash>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `std::string *Pin` is a required nillable (xsi:nil when NULL) element *`<ns5:Pin>`* of XML schema type *`xsd:string`*
- `std::string *UserId` is a required nillable (xsi:nil when NULL) element *`<ns5:UserId>`* of XML schema type *`xsd:string`*

The following operations on `ns5__SignRequest` are available:

- `ns5__SignRequest *soap_new_ns5__SignRequest(struct soap*)` managed allocation with default initialization
- `ns5__SignRequest *soap_new_ns5__SignRequest(struct soap*, int n)` managed allocation of array `ns5__SignRequest[n]`
- `ns5__SignRequest *soap_new_req_ns5__SignRequest(struct soap*, xsd__base64Binary *ApplicationId, xsd__base64Binary *Hash, std::string *Pin, std::string *UserId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns5__SignRequest *soap_new_set_ns5__SignRequest(struct soap*, xsd__base64Binary *ApplicationId, std::string *DocName, xsd__base64Binary *Hash, std::string *Pin, std::string *UserId, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns5__SignRequest::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns5__SignRequest(struct soap*, const ns5__SignRequest*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns5__SignRequest(struct soap*, const char *URL, const ns5__SignRequest*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns5__SignRequest(struct soap*, const char *URL, const ns5__SignRequest*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns5__SignRequest(struct soap*, const char *URL, const ns5__SignRequest*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns5__SignRequest(struct soap*, ns5__SignRequest*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns5__SignRequest(struct soap*, const char *URL, ns5__SignRequest*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns5__SignRequest(struct soap*, ns5__SignRequest*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns5__SignStatus"></a>

### `ns5__SignStatus`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 383, is serialized as XML schema type *`ns5:SignStatus`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns5__SignStatus : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns5:Code' of XML schema type 'xsd:string'
        std::string *Code;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Field' of XML schema type 'xsd:string'
        std::string *Field;
        /// Required nillable (xsi:nil when NULL) element 'ns5:FieldValue' of XML schema type 'xsd:string'
        std::string *FieldValue;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Message' of XML schema type 'xsd:string'
        std::string *Message;
        /// Required nillable (xsi:nil when NULL) element 'ns5:ProcessId' of XML schema type 'xsd:string'
        std::string *ProcessId;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SignStatus
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__SignStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SignStatus, default initialized and not managed by a soap context
        virtual ns5__SignStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__SignStatus); }
      public:
        /// Constructor with default initializations
        ns5__SignStatus() : Code(), Field(), FieldValue(), Message(), ProcessId() { }
        virtual ~ns5__SignStatus() { }
        /// Friend allocator used by soap_new_ns5__SignStatus(struct soap*, int)
        friend SOAP_FMAC1 ns5__SignStatus * SOAP_FMAC2 soap_instantiate_ns5__SignStatus(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::string *Code` is a required nillable (xsi:nil when NULL) element *`<ns5:Code>`* of XML schema type *`xsd:string`*
- `std::string *Field` is a required nillable (xsi:nil when NULL) element *`<ns5:Field>`* of XML schema type *`xsd:string`*
- `std::string *FieldValue` is a required nillable (xsi:nil when NULL) element *`<ns5:FieldValue>`* of XML schema type *`xsd:string`*
- `std::string *Message` is a required nillable (xsi:nil when NULL) element *`<ns5:Message>`* of XML schema type *`xsd:string`*
- `std::string *ProcessId` is a required nillable (xsi:nil when NULL) element *`<ns5:ProcessId>`* of XML schema type *`xsd:string`*

The following operations on `ns5__SignStatus` are available:

- `ns5__SignStatus *soap_new_ns5__SignStatus(struct soap*)` managed allocation with default initialization
- `ns5__SignStatus *soap_new_ns5__SignStatus(struct soap*, int n)` managed allocation of array `ns5__SignStatus[n]`
- `ns5__SignStatus *soap_new_req_ns5__SignStatus(struct soap*, std::string *Code, std::string *Field, std::string *FieldValue, std::string *Message, std::string *ProcessId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns5__SignStatus *soap_new_set_ns5__SignStatus(struct soap*, std::string *Code, std::string *Field, std::string *FieldValue, std::string *Message, std::string *ProcessId, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns5__SignStatus::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns5__SignStatus(struct soap*, const ns5__SignStatus*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns5__SignStatus(struct soap*, const char *URL, const ns5__SignStatus*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns5__SignStatus(struct soap*, const char *URL, const ns5__SignStatus*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns5__SignStatus(struct soap*, const char *URL, const ns5__SignStatus*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns5__SignStatus(struct soap*, ns5__SignStatus*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns5__SignStatus(struct soap*, const char *URL, ns5__SignStatus*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns5__SignStatus(struct soap*, ns5__SignStatus*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns5__SignResponse"></a>

### `ns5__SignResponse`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 385, is serialized as XML schema type *`ns5:SignResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns5__SignResponse : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns5:ArrayOfHashStructure' of XML schema type 'ns5:ArrayOfHashStructure'
        ns5__ArrayOfHashStructure *ArrayOfHashStructure;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Signature' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *Signature;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Status' of XML schema type 'ns5:SignStatus'
        ns5__SignStatus *Status;
        /// Required nillable (xsi:nil when NULL) element 'ns5:certificate' of XML schema type 'xsd:string'
        std::string *certificate;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SignResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__SignResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SignResponse, default initialized and not managed by a soap context
        virtual ns5__SignResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__SignResponse); }
      public:
        /// Constructor with default initializations
        ns5__SignResponse() : ArrayOfHashStructure(), Signature(), Status(), certificate() { }
        virtual ~ns5__SignResponse() { }
        /// Friend allocator used by soap_new_ns5__SignResponse(struct soap*, int)
        friend SOAP_FMAC1 ns5__SignResponse * SOAP_FMAC2 soap_instantiate_ns5__SignResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `ns5__ArrayOfHashStructure *ArrayOfHashStructure` is a required nillable (xsi:nil when NULL) element *`<ns5:ArrayOfHashStructure>`* of XML schema type *`ns5:ArrayOfHashStructure`*, where the type of this member is a pointer to <code><a href="#ns5__ArrayOfHashStructure"> ns5__ArrayOfHashStructure </a></code>
- `xsd__base64Binary *Signature` is a required nillable (xsi:nil when NULL) element *`<ns5:Signature>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `ns5__SignStatus *Status` is a required nillable (xsi:nil when NULL) element *`<ns5:Status>`* of XML schema type *`ns5:SignStatus`*, where the type of this member is a pointer to <code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code>
- `std::string *certificate` is a required nillable (xsi:nil when NULL) element *`<ns5:certificate>`* of XML schema type *`xsd:string`*

The following operations on `ns5__SignResponse` are available:

- `ns5__SignResponse *soap_new_ns5__SignResponse(struct soap*)` managed allocation with default initialization
- `ns5__SignResponse *soap_new_ns5__SignResponse(struct soap*, int n)` managed allocation of array `ns5__SignResponse[n]`
- `ns5__SignResponse *soap_new_req_ns5__SignResponse(struct soap*, ns5__ArrayOfHashStructure *ArrayOfHashStructure, xsd__base64Binary *Signature, ns5__SignStatus *Status, std::string *certificate)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns5__SignResponse *soap_new_set_ns5__SignResponse(struct soap*, ns5__ArrayOfHashStructure *ArrayOfHashStructure, xsd__base64Binary *Signature, ns5__SignStatus *Status, std::string *certificate, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns5__SignResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns5__SignResponse(struct soap*, const ns5__SignResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns5__SignResponse(struct soap*, const char *URL, const ns5__SignResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns5__SignResponse(struct soap*, const char *URL, const ns5__SignResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns5__SignResponse(struct soap*, const char *URL, const ns5__SignResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns5__SignResponse(struct soap*, ns5__SignResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns5__SignResponse(struct soap*, const char *URL, ns5__SignResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns5__SignResponse(struct soap*, ns5__SignResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns5__ArrayOfHashStructure"></a>

### `ns5__ArrayOfHashStructure`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 387, is serialized as XML schema type *`ns5:ArrayOfHashStructure`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns5__ArrayOfHashStructure : public xsd__anyType {
      public:
        /// Optional element 'ns5:HashStructure' of XML schema type 'ns5:HashStructure'
        std::vector<ns5__HashStructure *> HashStructure;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ArrayOfHashStructure
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ArrayOfHashStructure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ArrayOfHashStructure, default initialized and not managed by a soap context
        virtual ns5__ArrayOfHashStructure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__ArrayOfHashStructure); }
      public:
        /// Constructor with default initializations
        ns5__ArrayOfHashStructure() : HashStructure() { }
        virtual ~ns5__ArrayOfHashStructure() { }
        /// Friend allocator used by soap_new_ns5__ArrayOfHashStructure(struct soap*, int)
        friend SOAP_FMAC1 ns5__ArrayOfHashStructure * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfHashStructure(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `std::vector<ns5__HashStructure *> HashStructure` is an optional element *`<ns5:HashStructure>`* of XML schema type *`ns5:HashStructure`*, where the type of this member is a container of pointers to <code><a href="#ns5__HashStructure"> ns5__HashStructure </a></code>

The following operations on `ns5__ArrayOfHashStructure` are available:

- `ns5__ArrayOfHashStructure *soap_new_ns5__ArrayOfHashStructure(struct soap*)` managed allocation with default initialization
- `ns5__ArrayOfHashStructure *soap_new_ns5__ArrayOfHashStructure(struct soap*, int n)` managed allocation of array `ns5__ArrayOfHashStructure[n]`
- `ns5__ArrayOfHashStructure *soap_new_req_ns5__ArrayOfHashStructure(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns5__ArrayOfHashStructure *soap_new_set_ns5__ArrayOfHashStructure(struct soap*, const std::vector<ns5__HashStructure *> & HashStructure, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns5__ArrayOfHashStructure::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns5__ArrayOfHashStructure(struct soap*, const ns5__ArrayOfHashStructure*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns5__ArrayOfHashStructure(struct soap*, const char *URL, const ns5__ArrayOfHashStructure*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns5__ArrayOfHashStructure(struct soap*, const char *URL, const ns5__ArrayOfHashStructure*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns5__ArrayOfHashStructure(struct soap*, const char *URL, const ns5__ArrayOfHashStructure*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns5__ArrayOfHashStructure(struct soap*, ns5__ArrayOfHashStructure*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns5__ArrayOfHashStructure(struct soap*, const char *URL, ns5__ArrayOfHashStructure*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns5__ArrayOfHashStructure(struct soap*, ns5__ArrayOfHashStructure*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns5__HashStructure"></a>

### `ns5__HashStructure`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 389, is serialized as XML schema type *`ns5:HashStructure`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns5__HashStructure : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns5:Hash' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *Hash;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Name' of XML schema type 'xsd:string'
        std::string *Name;
        /// Required nillable (xsi:nil when NULL) element 'ns5:id' of XML schema type 'xsd:string'
        std::string *id;
      public:
        /// Return unique type id SOAP_TYPE_ns5__HashStructure
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__HashStructure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__HashStructure, default initialized and not managed by a soap context
        virtual ns5__HashStructure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__HashStructure); }
      public:
        /// Constructor with default initializations
        ns5__HashStructure() : Hash(), Name(), id() { }
        virtual ~ns5__HashStructure() { }
        /// Friend allocator used by soap_new_ns5__HashStructure(struct soap*, int)
        friend SOAP_FMAC1 ns5__HashStructure * SOAP_FMAC2 soap_instantiate_ns5__HashStructure(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `xsd__base64Binary *Hash` is a required nillable (xsi:nil when NULL) element *`<ns5:Hash>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `std::string *Name` is a required nillable (xsi:nil when NULL) element *`<ns5:Name>`* of XML schema type *`xsd:string`*
- `std::string *id` is a required nillable (xsi:nil when NULL) element *`<ns5:id>`* of XML schema type *`xsd:string`*

The following operations on `ns5__HashStructure` are available:

- `ns5__HashStructure *soap_new_ns5__HashStructure(struct soap*)` managed allocation with default initialization
- `ns5__HashStructure *soap_new_ns5__HashStructure(struct soap*, int n)` managed allocation of array `ns5__HashStructure[n]`
- `ns5__HashStructure *soap_new_req_ns5__HashStructure(struct soap*, xsd__base64Binary *Hash, std::string *Name, std::string *id)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns5__HashStructure *soap_new_set_ns5__HashStructure(struct soap*, xsd__base64Binary *Hash, std::string *Name, std::string *id, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns5__HashStructure::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns5__HashStructure(struct soap*, const ns5__HashStructure*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns5__HashStructure(struct soap*, const char *URL, const ns5__HashStructure*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns5__HashStructure(struct soap*, const char *URL, const ns5__HashStructure*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns5__HashStructure(struct soap*, const char *URL, const ns5__HashStructure*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns5__HashStructure(struct soap*, ns5__HashStructure*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns5__HashStructure(struct soap*, const char *URL, ns5__HashStructure*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns5__HashStructure(struct soap*, ns5__HashStructure*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns5__MultipleSignRequest"></a>

### `ns5__MultipleSignRequest`

This class is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 391, is serialized as XML schema type *`ns5:MultipleSignRequest`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns5__MultipleSignRequest : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns5:ApplicationId' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *ApplicationId;
        /// Required nillable (xsi:nil when NULL) element 'ns5:Pin' of XML schema type 'xsd:string'
        std::string *Pin;
        /// Required nillable (xsi:nil when NULL) element 'ns5:UserId' of XML schema type 'xsd:string'
        std::string *UserId;
      public:
        /// Return unique type id SOAP_TYPE_ns5__MultipleSignRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__MultipleSignRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__MultipleSignRequest, default initialized and not managed by a soap context
        virtual ns5__MultipleSignRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__MultipleSignRequest); }
      public:
        /// Constructor with default initializations
        ns5__MultipleSignRequest() : ApplicationId(), Pin(), UserId() { }
        virtual ~ns5__MultipleSignRequest() { }
        /// Friend allocator used by soap_new_ns5__MultipleSignRequest(struct soap*, int)
        friend SOAP_FMAC1 ns5__MultipleSignRequest * SOAP_FMAC2 soap_instantiate_ns5__MultipleSignRequest(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `xsd__base64Binary *ApplicationId` is a required nillable (xsi:nil when NULL) element *`<ns5:ApplicationId>`* of XML schema type *`xsd:base64Binary`*, where the type of this member is a pointer to <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `std::string *Pin` is a required nillable (xsi:nil when NULL) element *`<ns5:Pin>`* of XML schema type *`xsd:string`*
- `std::string *UserId` is a required nillable (xsi:nil when NULL) element *`<ns5:UserId>`* of XML schema type *`xsd:string`*

The following operations on `ns5__MultipleSignRequest` are available:

- `ns5__MultipleSignRequest *soap_new_ns5__MultipleSignRequest(struct soap*)` managed allocation with default initialization
- `ns5__MultipleSignRequest *soap_new_ns5__MultipleSignRequest(struct soap*, int n)` managed allocation of array `ns5__MultipleSignRequest[n]`
- `ns5__MultipleSignRequest *soap_new_req_ns5__MultipleSignRequest(struct soap*, xsd__base64Binary *ApplicationId, std::string *Pin, std::string *UserId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns5__MultipleSignRequest *soap_new_set_ns5__MultipleSignRequest(struct soap*, xsd__base64Binary *ApplicationId, std::string *Pin, std::string *UserId, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns5__MultipleSignRequest::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns5__MultipleSignRequest(struct soap*, const ns5__MultipleSignRequest*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns5__MultipleSignRequest(struct soap*, const char *URL, const ns5__MultipleSignRequest*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns5__MultipleSignRequest(struct soap*, const char *URL, const ns5__MultipleSignRequest*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns5__MultipleSignRequest(struct soap*, const char *URL, const ns5__MultipleSignRequest*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns5__MultipleSignRequest(struct soap*, ns5__MultipleSignRequest*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns5__MultipleSignRequest(struct soap*, const char *URL, ns5__MultipleSignRequest*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns5__MultipleSignRequest(struct soap*, ns5__MultipleSignRequest*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__ns1__CCMovelSign"></a>

### `struct __ns1__CCMovelSign`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1233, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__CCMovelSign()`.

[![][1] To top](#)


<a name="__ns1__GetCertificate"></a>

### `struct __ns1__GetCertificate`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1303, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__GetCertificate()`.

[![][1] To top](#)


<a name="__ns1__ValidateOtp"></a>

### `struct __ns1__ValidateOtp`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1373, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__ValidateOtp()`.

[![][1] To top](#)


<a name="__ns1__CCMovelMultipleSign"></a>

### `struct __ns1__CCMovelMultipleSign`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1443, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__CCMovelMultipleSign()`.

[![][1] To top](#)


<a name="__ns1__ForceSMS"></a>

### `struct __ns1__ForceSMS`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1513, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__ForceSMS()`.

[![][1] To top](#)


<a name="__ns1__GetCertificateWithPin"></a>

### `struct __ns1__GetCertificateWithPin`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1583, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__GetCertificateWithPin()`.

[![][1] To top](#)


<a name="_wsu__Timestamp"></a>

### `struct _wsu__Timestamp`

This struct is declared in [wsu.h](wsu.h) at line 77, is serialized as XML schema type *`wsu:Timestamp`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XML schema type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        long soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp() : wsu__Id(), Created(), Expires() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*
- `char *Created` is an optional element *`<wsu:Created>`* of XML schema type *`xsd:string`*
- `char *Expires` is an optional element *`<wsu:Expires>`* of XML schema type *`xsd:string`*

The following operations on `struct _wsu__Timestamp` are available:

- `struct _wsu__Timestamp *soap_new__wsu__Timestamp(struct soap*)` managed allocation with default initialization
- `struct _wsu__Timestamp *soap_new__wsu__Timestamp(struct soap*, int n)` managed allocation with default initialization of array `struct _wsu__Timestamp[n]`
- `struct _wsu__Timestamp *soap_new_req__wsu__Timestamp(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsu__Timestamp *soap_new_set__wsu__Timestamp(struct soap*, char *wsu__Id, char *Created, char *Expires)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsu__Timestamp(struct soap*, struct _wsu__Timestamp*)` (re)set to default initialization values
- `int soap_write__wsu__Timestamp(struct soap*, const struct _wsu__Timestamp*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsu__Timestamp(struct soap*, struct _wsu__Timestamp*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsu__Timestamp(struct soap*, const char *URL, const struct _wsu__Timestamp*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsu__Timestamp(struct soap*, const char *URL, const struct _wsu__Timestamp*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsu__Timestamp(struct soap*, const char *URL, const struct _wsu__Timestamp*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsu__Timestamp(struct soap*, struct _wsu__Timestamp*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsu__Timestamp(struct soap*, const char *URL, struct _wsu__Timestamp*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="wsse__EncodedString"></a>

### `struct wsse__EncodedString`

This struct is declared in [wsse.h](wsse.h) at line 74, is a simple content wrapper *`wsse:EncodedString`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC wsse__EncodedString {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        long soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString() : __item(), EncodingType(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`wsse:EncodedString`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *EncodingType` is an optional attribute *`EncodingType`* of XML schema type *`xsd:string`*
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*

The following operations on `struct wsse__EncodedString` are available:

- `struct wsse__EncodedString *soap_new_wsse__EncodedString(struct soap*)` managed allocation with default initialization
- `struct wsse__EncodedString *soap_new_wsse__EncodedString(struct soap*, int n)` managed allocation with default initialization of array `struct wsse__EncodedString[n]`
- `struct wsse__EncodedString *soap_new_req_wsse__EncodedString(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct wsse__EncodedString *soap_new_set_wsse__EncodedString(struct soap*, char *__item, char *EncodingType, char *wsu__Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_wsse__EncodedString(struct soap*, struct wsse__EncodedString*)` (re)set to default initialization values
- `int soap_write_wsse__EncodedString(struct soap*, const struct wsse__EncodedString*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_wsse__EncodedString(struct soap*, struct wsse__EncodedString*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_wsse__EncodedString(struct soap*, const char *URL, const struct wsse__EncodedString*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_wsse__EncodedString(struct soap*, const char *URL, const struct wsse__EncodedString*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_wsse__EncodedString(struct soap*, const char *URL, const struct wsse__EncodedString*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_wsse__EncodedString(struct soap*, struct wsse__EncodedString*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_wsse__EncodedString(struct soap*, const char *URL, struct wsse__EncodedString*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__UsernameToken"></a>

### `struct _wsse__UsernameToken`

This struct is declared in [wsse.h](wsse.h) at line 145, is serialized as XML schema type *`wsse:UsernameToken`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XML schema type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XML schema type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XML schema type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsse:Salt' of XML schema type 'xsd:string' */
        char *Salt;
        /** Optional element 'wsse:Iteration' of XML schema type 'xsd:unsignedInt' */
        unsigned int *Iteration;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        long soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken() : Username(), Password(), Nonce(), Salt(), Iteration(), wsu__Created(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *Username` is an optional element *`<wsse:Username>`* of XML schema type *`xsd:string`*
- `struct _wsse__Password *Password` is an optional element *`<wsse:Password>`* of XML schema type *`wsse:Password`*, where the type of this member is a pointer to <code><a href="#_wsse__Password"> _wsse__Password </a></code>
- `struct wsse__EncodedString *Nonce` is an optional element *`<wsse:Nonce>`* of XML schema type *`wsse:EncodedString`*, where the type of this member is a pointer to <code><a href="#wsse__EncodedString"> wsse__EncodedString </a></code>
- `char *Salt` is an optional element *`<wsse:Salt>`* of XML schema type *`xsd:string`*
- `unsigned int *Iteration` is an optional element *`<wsse:Iteration>`* of XML schema type *`xsd:unsignedInt`*
- `char *wsu__Created` is an optional element *`<wsu:Created>`* of XML schema type *`xsd:string`*
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__UsernameToken` are available:

- `struct _wsse__UsernameToken *soap_new__wsse__UsernameToken(struct soap*)` managed allocation with default initialization
- `struct _wsse__UsernameToken *soap_new__wsse__UsernameToken(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__UsernameToken[n]`
- `struct _wsse__UsernameToken *soap_new_req__wsse__UsernameToken(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__UsernameToken *soap_new_set__wsse__UsernameToken(struct soap*, char *Username, struct _wsse__Password *Password, struct wsse__EncodedString *Nonce, char *Salt, unsigned int *Iteration, char *wsu__Created, char *wsu__Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__UsernameToken(struct soap*, struct _wsse__UsernameToken*)` (re)set to default initialization values
- `int soap_write__wsse__UsernameToken(struct soap*, const struct _wsse__UsernameToken*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__UsernameToken(struct soap*, struct _wsse__UsernameToken*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__UsernameToken(struct soap*, const char *URL, const struct _wsse__UsernameToken*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__UsernameToken(struct soap*, const char *URL, const struct _wsse__UsernameToken*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__UsernameToken(struct soap*, const char *URL, const struct _wsse__UsernameToken*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__UsernameToken(struct soap*, struct _wsse__UsernameToken*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__UsernameToken(struct soap*, const char *URL, struct _wsse__UsernameToken*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__BinarySecurityToken"></a>

### `struct _wsse__BinarySecurityToken`

This struct is declared in [wsse.h](wsse.h) at line 158, is a simple content wrapper *`wsse:BinarySecurityToken`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__BinarySecurityToken {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        long soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`wsse:BinarySecurityToken`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*
- `char *ValueType` is an optional attribute *`ValueType`* of XML schema type *`xsd:string`*
- `char *EncodingType` is an optional attribute *`EncodingType`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__BinarySecurityToken` are available:

- `struct _wsse__BinarySecurityToken *soap_new__wsse__BinarySecurityToken(struct soap*)` managed allocation with default initialization
- `struct _wsse__BinarySecurityToken *soap_new__wsse__BinarySecurityToken(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__BinarySecurityToken[n]`
- `struct _wsse__BinarySecurityToken *soap_new_req__wsse__BinarySecurityToken(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__BinarySecurityToken *soap_new_set__wsse__BinarySecurityToken(struct soap*, char *__item, char *wsu__Id, char *ValueType, char *EncodingType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__BinarySecurityToken(struct soap*, struct _wsse__BinarySecurityToken*)` (re)set to default initialization values
- `int soap_write__wsse__BinarySecurityToken(struct soap*, const struct _wsse__BinarySecurityToken*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__BinarySecurityToken(struct soap*, struct _wsse__BinarySecurityToken*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__BinarySecurityToken(struct soap*, const char *URL, const struct _wsse__BinarySecurityToken*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__BinarySecurityToken(struct soap*, const char *URL, const struct _wsse__BinarySecurityToken*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__BinarySecurityToken(struct soap*, const char *URL, const struct _wsse__BinarySecurityToken*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__BinarySecurityToken(struct soap*, struct _wsse__BinarySecurityToken*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__BinarySecurityToken(struct soap*, const char *URL, struct _wsse__BinarySecurityToken*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__Reference"></a>

### `struct _wsse__Reference`

This struct is declared in [wsse.h](wsse.h) at line 168, is serialized as XML schema type *`wsse:Reference`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        long soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference() : URI(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *URI` is an optional attribute *`URI`* of XML schema type *`xsd:string`*
- `char *ValueType` is an optional attribute *`ValueType`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__Reference` are available:

- `struct _wsse__Reference *soap_new__wsse__Reference(struct soap*)` managed allocation with default initialization
- `struct _wsse__Reference *soap_new__wsse__Reference(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__Reference[n]`
- `struct _wsse__Reference *soap_new_req__wsse__Reference(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__Reference *soap_new_set__wsse__Reference(struct soap*, char *URI, char *ValueType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__Reference(struct soap*, struct _wsse__Reference*)` (re)set to default initialization values
- `int soap_write__wsse__Reference(struct soap*, const struct _wsse__Reference*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__Reference(struct soap*, struct _wsse__Reference*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__Reference(struct soap*, const char *URL, const struct _wsse__Reference*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__Reference(struct soap*, const char *URL, const struct _wsse__Reference*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__Reference(struct soap*, const char *URL, const struct _wsse__Reference*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__Reference(struct soap*, struct _wsse__Reference*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__Reference(struct soap*, const char *URL, struct _wsse__Reference*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__Embedded"></a>

### `struct _wsse__Embedded`

This struct is declared in [wsse.h](wsse.h) at line 176, is serialized as XML schema type *`wsse:Embedded`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        long soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded() : wsu__Id(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*
- `char *ValueType` is an optional attribute *`ValueType`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__Embedded` are available:

- `struct _wsse__Embedded *soap_new__wsse__Embedded(struct soap*)` managed allocation with default initialization
- `struct _wsse__Embedded *soap_new__wsse__Embedded(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__Embedded[n]`
- `struct _wsse__Embedded *soap_new_req__wsse__Embedded(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__Embedded *soap_new_set__wsse__Embedded(struct soap*, char *wsu__Id, char *ValueType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__Embedded(struct soap*, struct _wsse__Embedded*)` (re)set to default initialization values
- `int soap_write__wsse__Embedded(struct soap*, const struct _wsse__Embedded*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__Embedded(struct soap*, struct _wsse__Embedded*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__Embedded(struct soap*, const char *URL, const struct _wsse__Embedded*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__Embedded(struct soap*, const char *URL, const struct _wsse__Embedded*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__Embedded(struct soap*, const char *URL, const struct _wsse__Embedded*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__Embedded(struct soap*, struct _wsse__Embedded*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__Embedded(struct soap*, const char *URL, struct _wsse__Embedded*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__KeyIdentifier"></a>

### `struct _wsse__KeyIdentifier`

This struct is declared in [wsse.h](wsse.h) at line 185, is a simple content wrapper *`wsse:KeyIdentifier`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__KeyIdentifier {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        long soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`wsse:KeyIdentifier`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*
- `char *ValueType` is an optional attribute *`ValueType`* of XML schema type *`xsd:string`*
- `char *EncodingType` is an optional attribute *`EncodingType`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__KeyIdentifier` are available:

- `struct _wsse__KeyIdentifier *soap_new__wsse__KeyIdentifier(struct soap*)` managed allocation with default initialization
- `struct _wsse__KeyIdentifier *soap_new__wsse__KeyIdentifier(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__KeyIdentifier[n]`
- `struct _wsse__KeyIdentifier *soap_new_req__wsse__KeyIdentifier(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__KeyIdentifier *soap_new_set__wsse__KeyIdentifier(struct soap*, char *__item, char *wsu__Id, char *ValueType, char *EncodingType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__KeyIdentifier(struct soap*, struct _wsse__KeyIdentifier*)` (re)set to default initialization values
- `int soap_write__wsse__KeyIdentifier(struct soap*, const struct _wsse__KeyIdentifier*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__KeyIdentifier(struct soap*, struct _wsse__KeyIdentifier*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__KeyIdentifier(struct soap*, const char *URL, const struct _wsse__KeyIdentifier*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__KeyIdentifier(struct soap*, const char *URL, const struct _wsse__KeyIdentifier*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__KeyIdentifier(struct soap*, const char *URL, const struct _wsse__KeyIdentifier*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__KeyIdentifier(struct soap*, struct _wsse__KeyIdentifier*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__KeyIdentifier(struct soap*, const char *URL, struct _wsse__KeyIdentifier*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__SecurityTokenReference"></a>

### `struct _wsse__SecurityTokenReference`

This struct is declared in [wsse.h](wsse.h) at line 195, is serialized as XML schema type *`wsse:SecurityTokenReference`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XML schema type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XML schema type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XML schema type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XML schema type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XML schema type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        long soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference() : Reference(), KeyIdentifier(), Embedded(), ds__X509Data(), wsu__Id(), wsc__Instance(), Usage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct _wsse__Reference *Reference` is an optional element *`<wsse:Reference>`* of XML schema type *`wsse:Reference`*, where the type of this member is a pointer to <code><a href="#_wsse__Reference"> _wsse__Reference </a></code>
- `struct _wsse__KeyIdentifier *KeyIdentifier` is an optional element *`<wsse:KeyIdentifier>`* of XML schema type *`wsse:KeyIdentifier`*, where the type of this member is a pointer to <code><a href="#_wsse__KeyIdentifier"> _wsse__KeyIdentifier </a></code>
- `struct _wsse__Embedded *Embedded` is an optional element *`<wsse:Embedded>`* of XML schema type *`wsse:Embedded`*, where the type of this member is a pointer to <code><a href="#_wsse__Embedded"> _wsse__Embedded </a></code>
- `struct ds__X509DataType *ds__X509Data` is an optional element *`<ds:X509Data>`* of XML schema type *`ds:X509DataType`*, where the type of this member is a pointer to <code><a href="#ds__X509DataType"> ds__X509DataType </a></code>
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*
- `char *wsc__Instance` is an optional attribute *`wsc:Instance`* of XML schema type *`xsd:string`*
- `char *Usage` is an optional attribute *`Usage`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__SecurityTokenReference` are available:

- `struct _wsse__SecurityTokenReference *soap_new__wsse__SecurityTokenReference(struct soap*)` managed allocation with default initialization
- `struct _wsse__SecurityTokenReference *soap_new__wsse__SecurityTokenReference(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__SecurityTokenReference[n]`
- `struct _wsse__SecurityTokenReference *soap_new_req__wsse__SecurityTokenReference(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__SecurityTokenReference *soap_new_set__wsse__SecurityTokenReference(struct soap*, struct _wsse__Reference *Reference, struct _wsse__KeyIdentifier *KeyIdentifier, struct _wsse__Embedded *Embedded, struct ds__X509DataType *ds__X509Data, char *wsu__Id, char *wsc__Instance, char *Usage)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__SecurityTokenReference(struct soap*, struct _wsse__SecurityTokenReference*)` (re)set to default initialization values
- `int soap_write__wsse__SecurityTokenReference(struct soap*, const struct _wsse__SecurityTokenReference*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__SecurityTokenReference(struct soap*, struct _wsse__SecurityTokenReference*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__SecurityTokenReference(struct soap*, const char *URL, const struct _wsse__SecurityTokenReference*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__SecurityTokenReference(struct soap*, const char *URL, const struct _wsse__SecurityTokenReference*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__SecurityTokenReference(struct soap*, const char *URL, const struct _wsse__SecurityTokenReference*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__SecurityTokenReference(struct soap*, struct _wsse__SecurityTokenReference*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__SecurityTokenReference(struct soap*, const char *URL, struct _wsse__SecurityTokenReference*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__KeyInfoType"></a>

### `struct ds__KeyInfoType`

This struct is declared in [xenc.h](xenc.h) at line 38, is serialized as XML schema type *`ds:KeyInfoType`* and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__KeyInfoType {
      public:
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'ds:KeyName' of XML schema type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XML schema type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XML schema type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        long soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType() : xenc__EncryptedKey(), KeyName(), KeyValue(), RetrievalMethod(), X509Data(), wsse__SecurityTokenReference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct xenc__EncryptedKeyType *xenc__EncryptedKey` is an optional element *`<xenc:EncryptedKey>`* of XML schema type *`xenc:EncryptedKeyType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptedKeyType"> xenc__EncryptedKeyType </a></code>
- `char *KeyName` is an optional element *`<ds:KeyName>`* of XML schema type *`xsd:string`*
- `struct ds__KeyValueType *KeyValue` is an optional element *`<ds:KeyValue>`* of XML schema type *`ds:KeyValueType`*, where the type of this member is a pointer to <code><a href="#ds__KeyValueType"> ds__KeyValueType </a></code>
- `struct ds__RetrievalMethodType *RetrievalMethod` is an optional element *`<ds:RetrievalMethod>`* of XML schema type *`ds:RetrievalMethodType`*, where the type of this member is a pointer to <code><a href="#ds__RetrievalMethodType"> ds__RetrievalMethodType </a></code>
- `struct ds__X509DataType *X509Data` is an optional element *`<ds:X509Data>`* of XML schema type *`ds:X509DataType`*, where the type of this member is a pointer to <code><a href="#ds__X509DataType"> ds__X509DataType </a></code>
- `struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference` is an optional element *`<wsse:SecurityTokenReference>`* of XML schema type *`wsse:SecurityTokenReference`*, where the type of this member is a pointer to <code><a href="#_wsse__SecurityTokenReference"> _wsse__SecurityTokenReference </a></code>
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*

The following operations on `struct ds__KeyInfoType` are available:

- `struct ds__KeyInfoType *soap_new_ds__KeyInfoType(struct soap*)` managed allocation with default initialization
- `struct ds__KeyInfoType *soap_new_ds__KeyInfoType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__KeyInfoType[n]`
- `struct ds__KeyInfoType *soap_new_req_ds__KeyInfoType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__KeyInfoType *soap_new_set_ds__KeyInfoType(struct soap*, struct xenc__EncryptedKeyType *xenc__EncryptedKey, char *KeyName, struct ds__KeyValueType *KeyValue, struct ds__RetrievalMethodType *RetrievalMethod, struct ds__X509DataType *X509Data, struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference, char *Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__KeyInfoType(struct soap*, struct ds__KeyInfoType*)` (re)set to default initialization values
- `int soap_write_ds__KeyInfoType(struct soap*, const struct ds__KeyInfoType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__KeyInfoType(struct soap*, struct ds__KeyInfoType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__KeyInfoType(struct soap*, const char *URL, const struct ds__KeyInfoType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__KeyInfoType(struct soap*, const char *URL, const struct ds__KeyInfoType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__KeyInfoType(struct soap*, const char *URL, const struct ds__KeyInfoType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__KeyInfoType(struct soap*, struct ds__KeyInfoType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__KeyInfoType(struct soap*, const char *URL, struct ds__KeyInfoType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__SignatureType"></a>

### `struct ds__SignatureType`

This struct is declared in [ds.h](ds.h) at line 50, is serialized as XML schema type *`ds:SignatureType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XML schema type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XML schema type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType() : SignedInfo(), SignatureValue(), KeyInfo(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct ds__SignedInfoType *SignedInfo` is an optional element *`<ds:SignedInfo>`* of XML schema type *`ds:SignedInfoType`*, where the type of this member is a pointer to <code><a href="#ds__SignedInfoType"> ds__SignedInfoType </a></code>
- `char *SignatureValue` is an optional element *`<ds:SignatureValue>`* of XML schema type *`ds:SignatureValue`*, where the type of this member is <code><a href="#_ds__SignatureValue"> _ds__SignatureValue </a></code>
- `struct ds__KeyInfoType *KeyInfo` is an optional element *`<ds:KeyInfo>`* of XML schema type *`ds:KeyInfoType`*, where the type of this member is a pointer to <code><a href="#ds__KeyInfoType"> ds__KeyInfoType </a></code>
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*

The following operations on `struct ds__SignatureType` are available:

- `struct ds__SignatureType *soap_new_ds__SignatureType(struct soap*)` managed allocation with default initialization
- `struct ds__SignatureType *soap_new_ds__SignatureType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__SignatureType[n]`
- `struct ds__SignatureType *soap_new_req_ds__SignatureType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__SignatureType *soap_new_set_ds__SignatureType(struct soap*, struct ds__SignedInfoType *SignedInfo, char *SignatureValue, struct ds__KeyInfoType *KeyInfo, char *Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__SignatureType(struct soap*, struct ds__SignatureType*)` (re)set to default initialization values
- `int soap_write_ds__SignatureType(struct soap*, const struct ds__SignatureType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__SignatureType(struct soap*, struct ds__SignatureType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__SignatureType(struct soap*, const char *URL, const struct ds__SignatureType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__SignatureType(struct soap*, const char *URL, const struct ds__SignatureType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__SignatureType(struct soap*, const char *URL, const struct ds__SignatureType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__SignatureType(struct soap*, struct ds__SignatureType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__SignatureType(struct soap*, const char *URL, struct ds__SignatureType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_c14n__InclusiveNamespaces"></a>

### `struct _c14n__InclusiveNamespaces`

This struct is declared in [c14n.h](c14n.h) at line 24, is serialized as XML schema type *`c14n:InclusiveNamespaces`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XML schema type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        long soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces() : PrefixList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *PrefixList` is an optional attribute *`PrefixList`* of XML schema type *`xsd:string`*

The following operations on `struct _c14n__InclusiveNamespaces` are available:

- `struct _c14n__InclusiveNamespaces *soap_new__c14n__InclusiveNamespaces(struct soap*)` managed allocation with default initialization
- `struct _c14n__InclusiveNamespaces *soap_new__c14n__InclusiveNamespaces(struct soap*, int n)` managed allocation with default initialization of array `struct _c14n__InclusiveNamespaces[n]`
- `struct _c14n__InclusiveNamespaces *soap_new_req__c14n__InclusiveNamespaces(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _c14n__InclusiveNamespaces *soap_new_set__c14n__InclusiveNamespaces(struct soap*, char *PrefixList)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__c14n__InclusiveNamespaces(struct soap*, struct _c14n__InclusiveNamespaces*)` (re)set to default initialization values
- `int soap_write__c14n__InclusiveNamespaces(struct soap*, const struct _c14n__InclusiveNamespaces*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__c14n__InclusiveNamespaces(struct soap*, struct _c14n__InclusiveNamespaces*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__c14n__InclusiveNamespaces(struct soap*, const char *URL, const struct _c14n__InclusiveNamespaces*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__c14n__InclusiveNamespaces(struct soap*, const char *URL, const struct _c14n__InclusiveNamespaces*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__c14n__InclusiveNamespaces(struct soap*, const char *URL, const struct _c14n__InclusiveNamespaces*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__c14n__InclusiveNamespaces(struct soap*, struct _c14n__InclusiveNamespaces*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__c14n__InclusiveNamespaces(struct soap*, const char *URL, struct _c14n__InclusiveNamespaces*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__TransformType"></a>

### `struct ds__TransformType`

This struct is declared in [ds.h](ds.h) at line 77, is serialized as XML schema type *`ds:TransformType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        long soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType() : c14n__InclusiveNamespaces(), __any(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces` is an optional element *`<c14n:InclusiveNamespaces>`* of XML schema type *`c14n:InclusiveNamespaces`*, where the type of this member is a pointer to <code><a href="#_c14n__InclusiveNamespaces"> _c14n__InclusiveNamespaces </a></code>
- `char *__any`, where the type of this member is <code><a href="#_XML"> _XML </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Algorithm` is an optional attribute *`Algorithm`* of XML schema type *`xsd:string`*

The following operations on `struct ds__TransformType` are available:

- `struct ds__TransformType *soap_new_ds__TransformType(struct soap*)` managed allocation with default initialization
- `struct ds__TransformType *soap_new_ds__TransformType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__TransformType[n]`
- `struct ds__TransformType *soap_new_req_ds__TransformType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__TransformType *soap_new_set_ds__TransformType(struct soap*, struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces, char *__any, char *Algorithm)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__TransformType(struct soap*, struct ds__TransformType*)` (re)set to default initialization values
- `int soap_write_ds__TransformType(struct soap*, const struct ds__TransformType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__TransformType(struct soap*, struct ds__TransformType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__TransformType(struct soap*, const char *URL, const struct ds__TransformType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__TransformType(struct soap*, const char *URL, const struct ds__TransformType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__TransformType(struct soap*, const char *URL, const struct ds__TransformType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__TransformType(struct soap*, struct ds__TransformType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__TransformType(struct soap*, const char *URL, struct ds__TransformType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__SignedInfoType"></a>

### `struct ds__SignedInfoType`

This struct is declared in [ds.h](ds.h) at line 50, is serialized as XML schema type *`ds:SignedInfoType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XML schema type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XML schema type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XML schema type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        long soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType() : CanonicalizationMethod(), SignatureMethod(), __sizeReference(), Reference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct ds__CanonicalizationMethodType *CanonicalizationMethod` is a required element *`<ds:CanonicalizationMethod>`* of XML schema type *`ds:CanonicalizationMethodType`*, where the type of this member is a pointer to <code><a href="#ds__CanonicalizationMethodType"> ds__CanonicalizationMethodType </a></code>
- `struct ds__SignatureMethodType *SignatureMethod` is a required element *`<ds:SignatureMethod>`* of XML schema type *`ds:SignatureMethodType`*, where the type of this member is a pointer to <code><a href="#ds__SignatureMethodType"> ds__SignatureMethodType </a></code>
- `int __sizeReference` is a sequence of elements *`<ds:Reference>`* of XML schema type *`ds:ReferenceType`* stored in dynamic array `Reference` of length `__sizeReference` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*

The following operations on `struct ds__SignedInfoType` are available:

- `struct ds__SignedInfoType *soap_new_ds__SignedInfoType(struct soap*)` managed allocation with default initialization
- `struct ds__SignedInfoType *soap_new_ds__SignedInfoType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__SignedInfoType[n]`
- `struct ds__SignedInfoType *soap_new_req_ds__SignedInfoType(struct soap*, struct ds__CanonicalizationMethodType *CanonicalizationMethod, struct ds__SignatureMethodType *SignatureMethod, int __sizeReference, struct ds__ReferenceType **Reference)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__SignedInfoType *soap_new_set_ds__SignedInfoType(struct soap*, struct ds__CanonicalizationMethodType *CanonicalizationMethod, struct ds__SignatureMethodType *SignatureMethod, int __sizeReference, struct ds__ReferenceType **Reference, char *Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__SignedInfoType(struct soap*, struct ds__SignedInfoType*)` (re)set to default initialization values
- `int soap_write_ds__SignedInfoType(struct soap*, const struct ds__SignedInfoType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__SignedInfoType(struct soap*, struct ds__SignedInfoType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__SignedInfoType(struct soap*, const char *URL, const struct ds__SignedInfoType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__SignedInfoType(struct soap*, const char *URL, const struct ds__SignedInfoType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__SignedInfoType(struct soap*, const char *URL, const struct ds__SignedInfoType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__SignedInfoType(struct soap*, struct ds__SignedInfoType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__SignedInfoType(struct soap*, const char *URL, struct ds__SignedInfoType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__CanonicalizationMethodType"></a>

### `struct ds__CanonicalizationMethodType`

This struct is declared in [ds.h](ds.h) at line 63, is serialized as XML schema type *`ds:CanonicalizationMethodType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        long soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType() : Algorithm(), c14n__InclusiveNamespaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *Algorithm` is a required attribute *`Algorithm`* of XML schema type *`xsd:string`*
- `struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces` is an optional element *`<c14n:InclusiveNamespaces>`* of XML schema type *`c14n:InclusiveNamespaces`*, where the type of this member is a pointer to <code><a href="#_c14n__InclusiveNamespaces"> _c14n__InclusiveNamespaces </a></code>

The following operations on `struct ds__CanonicalizationMethodType` are available:

- `struct ds__CanonicalizationMethodType *soap_new_ds__CanonicalizationMethodType(struct soap*)` managed allocation with default initialization
- `struct ds__CanonicalizationMethodType *soap_new_ds__CanonicalizationMethodType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__CanonicalizationMethodType[n]`
- `struct ds__CanonicalizationMethodType *soap_new_req_ds__CanonicalizationMethodType(struct soap*, char *Algorithm)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__CanonicalizationMethodType *soap_new_set_ds__CanonicalizationMethodType(struct soap*, char *Algorithm, struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__CanonicalizationMethodType(struct soap*, struct ds__CanonicalizationMethodType*)` (re)set to default initialization values
- `int soap_write_ds__CanonicalizationMethodType(struct soap*, const struct ds__CanonicalizationMethodType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__CanonicalizationMethodType(struct soap*, struct ds__CanonicalizationMethodType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__CanonicalizationMethodType(struct soap*, const char *URL, const struct ds__CanonicalizationMethodType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__CanonicalizationMethodType(struct soap*, const char *URL, const struct ds__CanonicalizationMethodType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__CanonicalizationMethodType(struct soap*, const char *URL, const struct ds__CanonicalizationMethodType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__CanonicalizationMethodType(struct soap*, struct ds__CanonicalizationMethodType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__CanonicalizationMethodType(struct soap*, const char *URL, struct ds__CanonicalizationMethodType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__SignatureMethodType"></a>

### `struct ds__SignatureMethodType`

This struct is declared in [ds.h](ds.h) at line 66, is serialized as XML schema type *`ds:SignatureMethodType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XML schema type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType() : HMACOutputLength(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int *HMACOutputLength` is an optional element *`<ds:HMACOutputLength>`* of XML schema type *`xsd:int`*
- `char *Algorithm` is a required attribute *`Algorithm`* of XML schema type *`xsd:string`*

The following operations on `struct ds__SignatureMethodType` are available:

- `struct ds__SignatureMethodType *soap_new_ds__SignatureMethodType(struct soap*)` managed allocation with default initialization
- `struct ds__SignatureMethodType *soap_new_ds__SignatureMethodType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__SignatureMethodType[n]`
- `struct ds__SignatureMethodType *soap_new_req_ds__SignatureMethodType(struct soap*, char *Algorithm)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__SignatureMethodType *soap_new_set_ds__SignatureMethodType(struct soap*, int *HMACOutputLength, char *Algorithm)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__SignatureMethodType(struct soap*, struct ds__SignatureMethodType*)` (re)set to default initialization values
- `int soap_write_ds__SignatureMethodType(struct soap*, const struct ds__SignatureMethodType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__SignatureMethodType(struct soap*, struct ds__SignatureMethodType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__SignatureMethodType(struct soap*, const char *URL, const struct ds__SignatureMethodType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__SignatureMethodType(struct soap*, const char *URL, const struct ds__SignatureMethodType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__SignatureMethodType(struct soap*, const char *URL, const struct ds__SignatureMethodType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__SignatureMethodType(struct soap*, struct ds__SignatureMethodType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__SignatureMethodType(struct soap*, const char *URL, struct ds__SignatureMethodType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__ReferenceType"></a>

### `struct ds__ReferenceType`

This struct is declared in [ds.h](ds.h) at line 69, is serialized as XML schema type *`ds:ReferenceType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XML schema type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        long soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType() : Transforms(), DigestMethod(), DigestValue(), Id(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct ds__TransformsType *Transforms` is an optional element *`<ds:Transforms>`* of XML schema type *`ds:TransformsType`*, where the type of this member is a pointer to <code><a href="#ds__TransformsType"> ds__TransformsType </a></code>
- `struct ds__DigestMethodType *DigestMethod` is a required element *`<ds:DigestMethod>`* of XML schema type *`ds:DigestMethodType`*, where the type of this member is a pointer to <code><a href="#ds__DigestMethodType"> ds__DigestMethodType </a></code>
- `char *DigestValue` is a required element *`<ds:DigestValue>`* of XML schema type *`xsd:string`*
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*
- `char *URI` is an optional attribute *`URI`* of XML schema type *`xsd:string`*
- `char *Type` is an optional attribute *`Type`* of XML schema type *`xsd:string`*

The following operations on `struct ds__ReferenceType` are available:

- `struct ds__ReferenceType *soap_new_ds__ReferenceType(struct soap*)` managed allocation with default initialization
- `struct ds__ReferenceType *soap_new_ds__ReferenceType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__ReferenceType[n]`
- `struct ds__ReferenceType *soap_new_req_ds__ReferenceType(struct soap*, struct ds__DigestMethodType *DigestMethod, char *DigestValue)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__ReferenceType *soap_new_set_ds__ReferenceType(struct soap*, struct ds__TransformsType *Transforms, struct ds__DigestMethodType *DigestMethod, char *DigestValue, char *Id, char *URI, char *Type)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__ReferenceType(struct soap*, struct ds__ReferenceType*)` (re)set to default initialization values
- `int soap_write_ds__ReferenceType(struct soap*, const struct ds__ReferenceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__ReferenceType(struct soap*, struct ds__ReferenceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__ReferenceType(struct soap*, const char *URL, const struct ds__ReferenceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__ReferenceType(struct soap*, const char *URL, const struct ds__ReferenceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__ReferenceType(struct soap*, const char *URL, const struct ds__ReferenceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__ReferenceType(struct soap*, struct ds__ReferenceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__ReferenceType(struct soap*, const char *URL, struct ds__ReferenceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__TransformsType"></a>

### `struct ds__TransformsType`

This struct is declared in [ds.h](ds.h) at line 72, is serialized as XML schema type *`ds:TransformsType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XML schema type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        long soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType() : __sizeTransform(), Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeTransform` is a sequence of elements *`<ds:Transform>`* of XML schema type *`ds:TransformType`* stored in dynamic array `Transform` of length `__sizeTransform` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct ds__TransformsType` are available:

- `struct ds__TransformsType *soap_new_ds__TransformsType(struct soap*)` managed allocation with default initialization
- `struct ds__TransformsType *soap_new_ds__TransformsType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__TransformsType[n]`
- `struct ds__TransformsType *soap_new_req_ds__TransformsType(struct soap*, int __sizeTransform, struct ds__TransformType *Transform)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__TransformsType *soap_new_set_ds__TransformsType(struct soap*, int __sizeTransform, struct ds__TransformType *Transform)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__TransformsType(struct soap*, struct ds__TransformsType*)` (re)set to default initialization values
- `int soap_write_ds__TransformsType(struct soap*, const struct ds__TransformsType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__TransformsType(struct soap*, struct ds__TransformsType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__TransformsType(struct soap*, const char *URL, const struct ds__TransformsType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__TransformsType(struct soap*, const char *URL, const struct ds__TransformsType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__TransformsType(struct soap*, const char *URL, const struct ds__TransformsType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__TransformsType(struct soap*, struct ds__TransformsType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__TransformsType(struct soap*, const char *URL, struct ds__TransformsType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__DigestMethodType"></a>

### `struct ds__DigestMethodType`

This struct is declared in [ds.h](ds.h) at line 83, is serialized as XML schema type *`ds:DigestMethodType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        long soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType() : Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *Algorithm` is a required attribute *`Algorithm`* of XML schema type *`xsd:string`*

The following operations on `struct ds__DigestMethodType` are available:

- `struct ds__DigestMethodType *soap_new_ds__DigestMethodType(struct soap*)` managed allocation with default initialization
- `struct ds__DigestMethodType *soap_new_ds__DigestMethodType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__DigestMethodType[n]`
- `struct ds__DigestMethodType *soap_new_req_ds__DigestMethodType(struct soap*, char *Algorithm)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__DigestMethodType *soap_new_set_ds__DigestMethodType(struct soap*, char *Algorithm)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__DigestMethodType(struct soap*, struct ds__DigestMethodType*)` (re)set to default initialization values
- `int soap_write_ds__DigestMethodType(struct soap*, const struct ds__DigestMethodType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__DigestMethodType(struct soap*, struct ds__DigestMethodType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__DigestMethodType(struct soap*, const char *URL, const struct ds__DigestMethodType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__DigestMethodType(struct soap*, const char *URL, const struct ds__DigestMethodType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__DigestMethodType(struct soap*, const char *URL, const struct ds__DigestMethodType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__DigestMethodType(struct soap*, struct ds__DigestMethodType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__DigestMethodType(struct soap*, const char *URL, struct ds__DigestMethodType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__KeyValueType"></a>

### `struct ds__KeyValueType`

This struct is declared in [ds.h](ds.h) at line 88, is serialized as XML schema type *`ds:KeyValueType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XML schema type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XML schema type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType() : DSAKeyValue(), RSAKeyValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct ds__DSAKeyValueType *DSAKeyValue` is an optional element *`<ds:DSAKeyValue>`* of XML schema type *`ds:DSAKeyValueType`*, where the type of this member is a pointer to <code><a href="#ds__DSAKeyValueType"> ds__DSAKeyValueType </a></code>
- `struct ds__RSAKeyValueType *RSAKeyValue` is an optional element *`<ds:RSAKeyValue>`* of XML schema type *`ds:RSAKeyValueType`*, where the type of this member is a pointer to <code><a href="#ds__RSAKeyValueType"> ds__RSAKeyValueType </a></code>

The following operations on `struct ds__KeyValueType` are available:

- `struct ds__KeyValueType *soap_new_ds__KeyValueType(struct soap*)` managed allocation with default initialization
- `struct ds__KeyValueType *soap_new_ds__KeyValueType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__KeyValueType[n]`
- `struct ds__KeyValueType *soap_new_req_ds__KeyValueType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__KeyValueType *soap_new_set_ds__KeyValueType(struct soap*, struct ds__DSAKeyValueType *DSAKeyValue, struct ds__RSAKeyValueType *RSAKeyValue)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__KeyValueType(struct soap*, struct ds__KeyValueType*)` (re)set to default initialization values
- `int soap_write_ds__KeyValueType(struct soap*, const struct ds__KeyValueType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__KeyValueType(struct soap*, struct ds__KeyValueType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__KeyValueType(struct soap*, const char *URL, const struct ds__KeyValueType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__KeyValueType(struct soap*, const char *URL, const struct ds__KeyValueType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__KeyValueType(struct soap*, const char *URL, const struct ds__KeyValueType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__KeyValueType(struct soap*, struct ds__KeyValueType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__KeyValueType(struct soap*, const char *URL, struct ds__KeyValueType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__RetrievalMethodType"></a>

### `struct ds__RetrievalMethodType`

This struct is declared in [ds.h](ds.h) at line 89, is serialized as XML schema type *`ds:RetrievalMethodType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        long soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType() : Transforms(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct ds__TransformsType *Transforms` is an optional element *`<ds:Transforms>`* of XML schema type *`ds:TransformsType`*, where the type of this member is a pointer to <code><a href="#ds__TransformsType"> ds__TransformsType </a></code>
- `char *URI` is an optional attribute *`URI`* of XML schema type *`xsd:string`*
- `char *Type` is an optional attribute *`Type`* of XML schema type *`xsd:string`*

The following operations on `struct ds__RetrievalMethodType` are available:

- `struct ds__RetrievalMethodType *soap_new_ds__RetrievalMethodType(struct soap*)` managed allocation with default initialization
- `struct ds__RetrievalMethodType *soap_new_ds__RetrievalMethodType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__RetrievalMethodType[n]`
- `struct ds__RetrievalMethodType *soap_new_req_ds__RetrievalMethodType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__RetrievalMethodType *soap_new_set_ds__RetrievalMethodType(struct soap*, struct ds__TransformsType *Transforms, char *URI, char *Type)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__RetrievalMethodType(struct soap*, struct ds__RetrievalMethodType*)` (re)set to default initialization values
- `int soap_write_ds__RetrievalMethodType(struct soap*, const struct ds__RetrievalMethodType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__RetrievalMethodType(struct soap*, struct ds__RetrievalMethodType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__RetrievalMethodType(struct soap*, const char *URL, const struct ds__RetrievalMethodType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__RetrievalMethodType(struct soap*, const char *URL, const struct ds__RetrievalMethodType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__RetrievalMethodType(struct soap*, const char *URL, const struct ds__RetrievalMethodType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__RetrievalMethodType(struct soap*, struct ds__RetrievalMethodType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__RetrievalMethodType(struct soap*, const char *URL, struct ds__RetrievalMethodType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__X509DataType"></a>

### `struct ds__X509DataType`

This struct is declared in [wsse.h](wsse.h) at line 198, is serialized as XML schema type *`ds:X509DataType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XML schema type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XML schema type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XML schema type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XML schema type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XML schema type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        long soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType() : X509IssuerSerial(), X509SKI(), X509SubjectName(), X509Certificate(), X509CRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct ds__X509IssuerSerialType *X509IssuerSerial` is an optional element *`<ds:X509IssuerSerial>`* of XML schema type *`ds:X509IssuerSerialType`*, where the type of this member is a pointer to <code><a href="#ds__X509IssuerSerialType"> ds__X509IssuerSerialType </a></code>
- `char *X509SKI` is an optional element *`<ds:X509SKI>`* of XML schema type *`xsd:string`*
- `char *X509SubjectName` is an optional element *`<ds:X509SubjectName>`* of XML schema type *`xsd:string`*
- `char *X509Certificate` is an optional element *`<ds:X509Certificate>`* of XML schema type *`xsd:string`*
- `char *X509CRL` is an optional element *`<ds:X509CRL>`* of XML schema type *`xsd:string`*

The following operations on `struct ds__X509DataType` are available:

- `struct ds__X509DataType *soap_new_ds__X509DataType(struct soap*)` managed allocation with default initialization
- `struct ds__X509DataType *soap_new_ds__X509DataType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__X509DataType[n]`
- `struct ds__X509DataType *soap_new_req_ds__X509DataType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__X509DataType *soap_new_set_ds__X509DataType(struct soap*, struct ds__X509IssuerSerialType *X509IssuerSerial, char *X509SKI, char *X509SubjectName, char *X509Certificate, char *X509CRL)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__X509DataType(struct soap*, struct ds__X509DataType*)` (re)set to default initialization values
- `int soap_write_ds__X509DataType(struct soap*, const struct ds__X509DataType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__X509DataType(struct soap*, struct ds__X509DataType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__X509DataType(struct soap*, const char *URL, const struct ds__X509DataType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__X509DataType(struct soap*, const char *URL, const struct ds__X509DataType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__X509DataType(struct soap*, const char *URL, const struct ds__X509DataType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__X509DataType(struct soap*, struct ds__X509DataType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__X509DataType(struct soap*, const char *URL, struct ds__X509DataType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__X509IssuerSerialType"></a>

### `struct ds__X509IssuerSerialType`

This struct is declared in [ds.h](ds.h) at line 106, is serialized as XML schema type *`ds:X509IssuerSerialType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XML schema type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XML schema type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        long soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType() : X509IssuerName(), X509SerialNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *X509IssuerName` is a required element *`<ds:X509IssuerName>`* of XML schema type *`xsd:string`*
- `char *X509SerialNumber` is a required element *`<ds:X509SerialNumber>`* of XML schema type *`xsd:string`*

The following operations on `struct ds__X509IssuerSerialType` are available:

- `struct ds__X509IssuerSerialType *soap_new_ds__X509IssuerSerialType(struct soap*)` managed allocation with default initialization
- `struct ds__X509IssuerSerialType *soap_new_ds__X509IssuerSerialType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__X509IssuerSerialType[n]`
- `struct ds__X509IssuerSerialType *soap_new_req_ds__X509IssuerSerialType(struct soap*, char *X509IssuerName, char *X509SerialNumber)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__X509IssuerSerialType *soap_new_set_ds__X509IssuerSerialType(struct soap*, char *X509IssuerName, char *X509SerialNumber)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__X509IssuerSerialType(struct soap*, struct ds__X509IssuerSerialType*)` (re)set to default initialization values
- `int soap_write_ds__X509IssuerSerialType(struct soap*, const struct ds__X509IssuerSerialType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__X509IssuerSerialType(struct soap*, struct ds__X509IssuerSerialType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__X509IssuerSerialType(struct soap*, const char *URL, const struct ds__X509IssuerSerialType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__X509IssuerSerialType(struct soap*, const char *URL, const struct ds__X509IssuerSerialType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__X509IssuerSerialType(struct soap*, const char *URL, const struct ds__X509IssuerSerialType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__X509IssuerSerialType(struct soap*, struct ds__X509IssuerSerialType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__X509IssuerSerialType(struct soap*, const char *URL, struct ds__X509IssuerSerialType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__DSAKeyValueType"></a>

### `struct ds__DSAKeyValueType`

This struct is declared in [ds.h](ds.h) at line 127, is serialized as XML schema type *`ds:DSAKeyValueType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XML schema type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XML schema type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XML schema type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XML schema type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XML schema type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XML schema type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XML schema type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType() : G(), Y(), J(), P(), Q(), Seed(), PgenCounter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *G` is an optional element *`<ds:G>`* of XML schema type *`xsd:string`*
- `char *Y` is a required element *`<ds:Y>`* of XML schema type *`xsd:string`*
- `char *J` is an optional element *`<ds:J>`* of XML schema type *`xsd:string`*
- `char *P` is a required element *`<ds:P>`* of XML schema type *`xsd:string`*
- `char *Q` is a required element *`<ds:Q>`* of XML schema type *`xsd:string`*
- `char *Seed` is a required element *`<ds:Seed>`* of XML schema type *`xsd:string`*
- `char *PgenCounter` is a required element *`<ds:PgenCounter>`* of XML schema type *`xsd:string`*

The following operations on `struct ds__DSAKeyValueType` are available:

- `struct ds__DSAKeyValueType *soap_new_ds__DSAKeyValueType(struct soap*)` managed allocation with default initialization
- `struct ds__DSAKeyValueType *soap_new_ds__DSAKeyValueType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__DSAKeyValueType[n]`
- `struct ds__DSAKeyValueType *soap_new_req_ds__DSAKeyValueType(struct soap*, char *Y, char *P, char *Q, char *Seed, char *PgenCounter)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__DSAKeyValueType *soap_new_set_ds__DSAKeyValueType(struct soap*, char *G, char *Y, char *J, char *P, char *Q, char *Seed, char *PgenCounter)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__DSAKeyValueType(struct soap*, struct ds__DSAKeyValueType*)` (re)set to default initialization values
- `int soap_write_ds__DSAKeyValueType(struct soap*, const struct ds__DSAKeyValueType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__DSAKeyValueType(struct soap*, struct ds__DSAKeyValueType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__DSAKeyValueType(struct soap*, const char *URL, const struct ds__DSAKeyValueType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__DSAKeyValueType(struct soap*, const char *URL, const struct ds__DSAKeyValueType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__DSAKeyValueType(struct soap*, const char *URL, const struct ds__DSAKeyValueType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__DSAKeyValueType(struct soap*, struct ds__DSAKeyValueType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__DSAKeyValueType(struct soap*, const char *URL, struct ds__DSAKeyValueType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ds__RSAKeyValueType"></a>

### `struct ds__RSAKeyValueType`

This struct is declared in [ds.h](ds.h) at line 130, is serialized as XML schema type *`ds:RSAKeyValueType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XML schema type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XML schema type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType() : Modulus(), Exponent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *Modulus` is a required element *`<ds:Modulus>`* of XML schema type *`xsd:string`*
- `char *Exponent` is a required element *`<ds:Exponent>`* of XML schema type *`xsd:string`*

The following operations on `struct ds__RSAKeyValueType` are available:

- `struct ds__RSAKeyValueType *soap_new_ds__RSAKeyValueType(struct soap*)` managed allocation with default initialization
- `struct ds__RSAKeyValueType *soap_new_ds__RSAKeyValueType(struct soap*, int n)` managed allocation with default initialization of array `struct ds__RSAKeyValueType[n]`
- `struct ds__RSAKeyValueType *soap_new_req_ds__RSAKeyValueType(struct soap*, char *Modulus, char *Exponent)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct ds__RSAKeyValueType *soap_new_set_ds__RSAKeyValueType(struct soap*, char *Modulus, char *Exponent)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_ds__RSAKeyValueType(struct soap*, struct ds__RSAKeyValueType*)` (re)set to default initialization values
- `int soap_write_ds__RSAKeyValueType(struct soap*, const struct ds__RSAKeyValueType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_ds__RSAKeyValueType(struct soap*, struct ds__RSAKeyValueType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_ds__RSAKeyValueType(struct soap*, const char *URL, const struct ds__RSAKeyValueType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ds__RSAKeyValueType(struct soap*, const char *URL, const struct ds__RSAKeyValueType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ds__RSAKeyValueType(struct soap*, const char *URL, const struct ds__RSAKeyValueType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_ds__RSAKeyValueType(struct soap*, struct ds__RSAKeyValueType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_ds__RSAKeyValueType(struct soap*, const char *URL, struct ds__RSAKeyValueType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__EncryptionPropertyType"></a>

### `struct xenc__EncryptionPropertyType`

This struct is declared in [xenc.h](xenc.h) at line 101, is serialized as XML schema type *`xenc:EncryptionPropertyType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XML schema type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType() : Target(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *Target` is an optional attribute *`Target`* of XML schema type *`xsd:string`*
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*

The following operations on `struct xenc__EncryptionPropertyType` are available:

- `struct xenc__EncryptionPropertyType *soap_new_xenc__EncryptionPropertyType(struct soap*)` managed allocation with default initialization
- `struct xenc__EncryptionPropertyType *soap_new_xenc__EncryptionPropertyType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__EncryptionPropertyType[n]`
- `struct xenc__EncryptionPropertyType *soap_new_req_xenc__EncryptionPropertyType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__EncryptionPropertyType *soap_new_set_xenc__EncryptionPropertyType(struct soap*, char *Target, char *Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__EncryptionPropertyType(struct soap*, struct xenc__EncryptionPropertyType*)` (re)set to default initialization values
- `int soap_write_xenc__EncryptionPropertyType(struct soap*, const struct xenc__EncryptionPropertyType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__EncryptionPropertyType(struct soap*, struct xenc__EncryptionPropertyType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__EncryptionPropertyType(struct soap*, const char *URL, const struct xenc__EncryptionPropertyType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__EncryptionPropertyType(struct soap*, const char *URL, const struct xenc__EncryptionPropertyType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__EncryptionPropertyType(struct soap*, const char *URL, const struct xenc__EncryptionPropertyType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__EncryptionPropertyType(struct soap*, struct xenc__EncryptionPropertyType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__EncryptionPropertyType(struct soap*, const char *URL, struct xenc__EncryptionPropertyType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__EncryptedType"></a>

### `struct xenc__EncryptedType`

This struct is declared in [xenc.h](xenc.h) at line 70, is serialized as XML schema type *`xenc:EncryptedType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct xenc__EncryptionMethodType *EncryptionMethod` is an optional element *`<xenc:EncryptionMethod>`* of XML schema type *`xenc:EncryptionMethodType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptionMethodType"> xenc__EncryptionMethodType </a></code>
- `struct ds__KeyInfoType *ds__KeyInfo` is an optional element *`<ds:KeyInfo>`* of XML schema type *`ds:KeyInfo`*, where the type of this member is a pointer to <code><a href="#ds__KeyInfoType"> ds__KeyInfoType </a></code>
- `struct xenc__CipherDataType *CipherData` is a required element *`<xenc:CipherData>`* of XML schema type *`xenc:CipherDataType`*, where the type of this member is a pointer to <code><a href="#xenc__CipherDataType"> xenc__CipherDataType </a></code>
- `struct xenc__EncryptionPropertiesType *EncryptionProperties` is an optional element *`<xenc:EncryptionProperties>`* of XML schema type *`xenc:EncryptionPropertiesType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptionPropertiesType"> xenc__EncryptionPropertiesType </a></code>
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*
- `char *Type` is an optional attribute *`Type`* of XML schema type *`xsd:string`*
- `char *MimeType` is an optional attribute *`MimeType`* of XML schema type *`xsd:string`*
- `char *Encoding` is an optional attribute *`Encoding`* of XML schema type *`xsd:string`*

The following operations on `struct xenc__EncryptedType` are available:

- `struct xenc__EncryptedType *soap_new_xenc__EncryptedType(struct soap*)` managed allocation with default initialization
- `struct xenc__EncryptedType *soap_new_xenc__EncryptedType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__EncryptedType[n]`
- `struct xenc__EncryptedType *soap_new_req_xenc__EncryptedType(struct soap*, struct xenc__CipherDataType *CipherData)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__EncryptedType *soap_new_set_xenc__EncryptedType(struct soap*, struct xenc__EncryptionMethodType *EncryptionMethod, struct ds__KeyInfoType *ds__KeyInfo, struct xenc__CipherDataType *CipherData, struct xenc__EncryptionPropertiesType *EncryptionProperties, char *Id, char *Type, char *MimeType, char *Encoding)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__EncryptedType(struct soap*, struct xenc__EncryptedType*)` (re)set to default initialization values
- `int soap_write_xenc__EncryptedType(struct soap*, const struct xenc__EncryptedType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__EncryptedType(struct soap*, struct xenc__EncryptedType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__EncryptedType(struct soap*, const char *URL, const struct xenc__EncryptedType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__EncryptedType(struct soap*, const char *URL, const struct xenc__EncryptedType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__EncryptedType(struct soap*, const char *URL, const struct xenc__EncryptedType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__EncryptedType(struct soap*, struct xenc__EncryptedType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__EncryptedType(struct soap*, const char *URL, struct xenc__EncryptedType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__EncryptionMethodType"></a>

### `struct xenc__EncryptionMethodType`

This struct is declared in [xenc.h](xenc.h) at line 73, is serialized as XML schema type *`xenc:EncryptionMethodType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XML schema type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XML schema type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType() : KeySize(), OAEPparams(), Algorithm(), ds__DigestMethod(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int *KeySize` is an optional element *`<xenc:KeySize>`* of XML schema type *`xsd:int`*
- `char *OAEPparams` is an optional element *`<xenc:OAEPparams>`* of XML schema type *`xsd:string`*
- `char *Algorithm` is a required attribute *`Algorithm`* of XML schema type *`xsd:string`*
- `struct ds__DigestMethodType *ds__DigestMethod` is an optional element *`<ds:DigestMethod>`* of XML schema type *`ds:DigestMethodType`*, where the type of this member is a pointer to <code><a href="#ds__DigestMethodType"> ds__DigestMethodType </a></code>
- `char *__mixed`, where the type of this member is <code><a href="#_XML"> _XML </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct xenc__EncryptionMethodType` are available:

- `struct xenc__EncryptionMethodType *soap_new_xenc__EncryptionMethodType(struct soap*)` managed allocation with default initialization
- `struct xenc__EncryptionMethodType *soap_new_xenc__EncryptionMethodType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__EncryptionMethodType[n]`
- `struct xenc__EncryptionMethodType *soap_new_req_xenc__EncryptionMethodType(struct soap*, char *Algorithm)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__EncryptionMethodType *soap_new_set_xenc__EncryptionMethodType(struct soap*, int *KeySize, char *OAEPparams, char *Algorithm, struct ds__DigestMethodType *ds__DigestMethod, char *__mixed)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__EncryptionMethodType(struct soap*, struct xenc__EncryptionMethodType*)` (re)set to default initialization values
- `int soap_write_xenc__EncryptionMethodType(struct soap*, const struct xenc__EncryptionMethodType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__EncryptionMethodType(struct soap*, struct xenc__EncryptionMethodType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__EncryptionMethodType(struct soap*, const char *URL, const struct xenc__EncryptionMethodType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__EncryptionMethodType(struct soap*, const char *URL, const struct xenc__EncryptionMethodType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__EncryptionMethodType(struct soap*, const char *URL, const struct xenc__EncryptionMethodType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__EncryptionMethodType(struct soap*, struct xenc__EncryptionMethodType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__EncryptionMethodType(struct soap*, const char *URL, struct xenc__EncryptionMethodType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__CipherDataType"></a>

### `struct xenc__CipherDataType`

This struct is declared in [xenc.h](xenc.h) at line 76, is serialized as XML schema type *`xenc:CipherDataType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XML schema type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XML schema type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType() : CipherValue(), CipherReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *CipherValue` is an optional element *`<xenc:CipherValue>`* of XML schema type *`xsd:string`*
- `struct xenc__CipherReferenceType *CipherReference` is an optional element *`<xenc:CipherReference>`* of XML schema type *`xenc:CipherReferenceType`*, where the type of this member is a pointer to <code><a href="#xenc__CipherReferenceType"> xenc__CipherReferenceType </a></code>

The following operations on `struct xenc__CipherDataType` are available:

- `struct xenc__CipherDataType *soap_new_xenc__CipherDataType(struct soap*)` managed allocation with default initialization
- `struct xenc__CipherDataType *soap_new_xenc__CipherDataType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__CipherDataType[n]`
- `struct xenc__CipherDataType *soap_new_req_xenc__CipherDataType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__CipherDataType *soap_new_set_xenc__CipherDataType(struct soap*, char *CipherValue, struct xenc__CipherReferenceType *CipherReference)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__CipherDataType(struct soap*, struct xenc__CipherDataType*)` (re)set to default initialization values
- `int soap_write_xenc__CipherDataType(struct soap*, const struct xenc__CipherDataType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__CipherDataType(struct soap*, struct xenc__CipherDataType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__CipherDataType(struct soap*, const char *URL, const struct xenc__CipherDataType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__CipherDataType(struct soap*, const char *URL, const struct xenc__CipherDataType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__CipherDataType(struct soap*, const char *URL, const struct xenc__CipherDataType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__CipherDataType(struct soap*, struct xenc__CipherDataType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__CipherDataType(struct soap*, const char *URL, struct xenc__CipherDataType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__CipherReferenceType"></a>

### `struct xenc__CipherReferenceType`

This struct is declared in [xenc.h](xenc.h) at line 79, is serialized as XML schema type *`xenc:CipherReferenceType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XML schema type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType() : Transforms(), URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct xenc__TransformsType *Transforms` is an optional element *`<xenc:Transforms>`* of XML schema type *`xenc:TransformsType`*, where the type of this member is a pointer to <code><a href="#xenc__TransformsType"> xenc__TransformsType </a></code>
- `char *URI` is a required attribute *`URI`* of XML schema type *`xsd:string`*

The following operations on `struct xenc__CipherReferenceType` are available:

- `struct xenc__CipherReferenceType *soap_new_xenc__CipherReferenceType(struct soap*)` managed allocation with default initialization
- `struct xenc__CipherReferenceType *soap_new_xenc__CipherReferenceType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__CipherReferenceType[n]`
- `struct xenc__CipherReferenceType *soap_new_req_xenc__CipherReferenceType(struct soap*, char *URI)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__CipherReferenceType *soap_new_set_xenc__CipherReferenceType(struct soap*, struct xenc__TransformsType *Transforms, char *URI)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__CipherReferenceType(struct soap*, struct xenc__CipherReferenceType*)` (re)set to default initialization values
- `int soap_write_xenc__CipherReferenceType(struct soap*, const struct xenc__CipherReferenceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__CipherReferenceType(struct soap*, struct xenc__CipherReferenceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__CipherReferenceType(struct soap*, const char *URL, const struct xenc__CipherReferenceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__CipherReferenceType(struct soap*, const char *URL, const struct xenc__CipherReferenceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__CipherReferenceType(struct soap*, const char *URL, const struct xenc__CipherReferenceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__CipherReferenceType(struct soap*, struct xenc__CipherReferenceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__CipherReferenceType(struct soap*, const char *URL, struct xenc__CipherReferenceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__TransformsType"></a>

### `struct xenc__TransformsType`

This struct is declared in [xenc.h](xenc.h) at line 82, is serialized as XML schema type *`xenc:TransformsType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XML schema type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        long soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType() : ds__Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct ds__TransformType ds__Transform` is a required element *`<ds:Transform>`* of XML schema type *`ds:Transform`*, where the type of this member is <code><a href="#ds__TransformType"> ds__TransformType </a></code>

The following operations on `struct xenc__TransformsType` are available:

- `struct xenc__TransformsType *soap_new_xenc__TransformsType(struct soap*)` managed allocation with default initialization
- `struct xenc__TransformsType *soap_new_xenc__TransformsType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__TransformsType[n]`
- `struct xenc__TransformsType *soap_new_req_xenc__TransformsType(struct soap*, const struct ds__TransformType& ds__Transform)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__TransformsType *soap_new_set_xenc__TransformsType(struct soap*, const struct ds__TransformType& ds__Transform)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__TransformsType(struct soap*, struct xenc__TransformsType*)` (re)set to default initialization values
- `int soap_write_xenc__TransformsType(struct soap*, const struct xenc__TransformsType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__TransformsType(struct soap*, struct xenc__TransformsType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__TransformsType(struct soap*, const char *URL, const struct xenc__TransformsType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__TransformsType(struct soap*, const char *URL, const struct xenc__TransformsType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__TransformsType(struct soap*, const char *URL, const struct xenc__TransformsType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__TransformsType(struct soap*, struct xenc__TransformsType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__TransformsType(struct soap*, const char *URL, struct xenc__TransformsType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__AgreementMethodType"></a>

### `struct xenc__AgreementMethodType`

This struct is declared in [xenc.h](xenc.h) at line 91, is serialized as XML schema type *`xenc:AgreementMethodType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XML schema type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType() : KA_Nonce(), OriginatorKeyInfo(), RecipientKeyInfo(), Algorithm(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *KA_Nonce` is an optional element *`<xenc:KA-Nonce>`* of XML schema type *`xsd:string`*
- `struct ds__KeyInfoType *OriginatorKeyInfo` is an optional element *`<xenc:OriginatorKeyInfo>`* of XML schema type *`ds:KeyInfoType`*, where the type of this member is a pointer to <code><a href="#ds__KeyInfoType"> ds__KeyInfoType </a></code>
- `struct ds__KeyInfoType *RecipientKeyInfo` is an optional element *`<xenc:RecipientKeyInfo>`* of XML schema type *`ds:KeyInfoType`*, where the type of this member is a pointer to <code><a href="#ds__KeyInfoType"> ds__KeyInfoType </a></code>
- `char *Algorithm` is a required attribute *`Algorithm`* of XML schema type *`xsd:string`*
- `char *__mixed`, where the type of this member is <code><a href="#_XML"> _XML </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct xenc__AgreementMethodType` are available:

- `struct xenc__AgreementMethodType *soap_new_xenc__AgreementMethodType(struct soap*)` managed allocation with default initialization
- `struct xenc__AgreementMethodType *soap_new_xenc__AgreementMethodType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__AgreementMethodType[n]`
- `struct xenc__AgreementMethodType *soap_new_req_xenc__AgreementMethodType(struct soap*, char *Algorithm)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__AgreementMethodType *soap_new_set_xenc__AgreementMethodType(struct soap*, char *KA_Nonce, struct ds__KeyInfoType *OriginatorKeyInfo, struct ds__KeyInfoType *RecipientKeyInfo, char *Algorithm, char *__mixed)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__AgreementMethodType(struct soap*, struct xenc__AgreementMethodType*)` (re)set to default initialization values
- `int soap_write_xenc__AgreementMethodType(struct soap*, const struct xenc__AgreementMethodType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__AgreementMethodType(struct soap*, struct xenc__AgreementMethodType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__AgreementMethodType(struct soap*, const char *URL, const struct xenc__AgreementMethodType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__AgreementMethodType(struct soap*, const char *URL, const struct xenc__AgreementMethodType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__AgreementMethodType(struct soap*, const char *URL, const struct xenc__AgreementMethodType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__AgreementMethodType(struct soap*, struct xenc__AgreementMethodType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__AgreementMethodType(struct soap*, const char *URL, struct xenc__AgreementMethodType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__ReferenceType"></a>

### `struct xenc__ReferenceType`

This struct is declared in [xenc.h](xenc.h) at line 94, is serialized as XML schema type *`xenc:ReferenceType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType() : URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *URI` is a required attribute *`URI`* of XML schema type *`xsd:string`*

The following operations on `struct xenc__ReferenceType` are available:

- `struct xenc__ReferenceType *soap_new_xenc__ReferenceType(struct soap*)` managed allocation with default initialization
- `struct xenc__ReferenceType *soap_new_xenc__ReferenceType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__ReferenceType[n]`
- `struct xenc__ReferenceType *soap_new_req_xenc__ReferenceType(struct soap*, char *URI)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__ReferenceType *soap_new_set_xenc__ReferenceType(struct soap*, char *URI)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__ReferenceType(struct soap*, struct xenc__ReferenceType*)` (re)set to default initialization values
- `int soap_write_xenc__ReferenceType(struct soap*, const struct xenc__ReferenceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__ReferenceType(struct soap*, struct xenc__ReferenceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__ReferenceType(struct soap*, const char *URL, const struct xenc__ReferenceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__ReferenceType(struct soap*, const char *URL, const struct xenc__ReferenceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__ReferenceType(struct soap*, const char *URL, const struct xenc__ReferenceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__ReferenceType(struct soap*, struct xenc__ReferenceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__ReferenceType(struct soap*, const char *URL, struct xenc__ReferenceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__EncryptionPropertiesType"></a>

### `struct xenc__EncryptionPropertiesType`

This struct is declared in [xenc.h](xenc.h) at line 97, is serialized as XML schema type *`xenc:EncryptionPropertiesType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XML schema type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType() : __sizeEncryptionProperty(), EncryptionProperty(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeEncryptionProperty` is a sequence of at least 1 elements *`<xenc:EncryptionProperty>`* of XML schema type *`xenc:EncryptionPropertyType`* stored in dynamic array `EncryptionProperty` of length `__sizeEncryptionProperty` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*

The following operations on `struct xenc__EncryptionPropertiesType` are available:

- `struct xenc__EncryptionPropertiesType *soap_new_xenc__EncryptionPropertiesType(struct soap*)` managed allocation with default initialization
- `struct xenc__EncryptionPropertiesType *soap_new_xenc__EncryptionPropertiesType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__EncryptionPropertiesType[n]`
- `struct xenc__EncryptionPropertiesType *soap_new_req_xenc__EncryptionPropertiesType(struct soap*, int __sizeEncryptionProperty, struct xenc__EncryptionPropertyType *EncryptionProperty)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__EncryptionPropertiesType *soap_new_set_xenc__EncryptionPropertiesType(struct soap*, int __sizeEncryptionProperty, struct xenc__EncryptionPropertyType *EncryptionProperty, char *Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__EncryptionPropertiesType(struct soap*, struct xenc__EncryptionPropertiesType*)` (re)set to default initialization values
- `int soap_write_xenc__EncryptionPropertiesType(struct soap*, const struct xenc__EncryptionPropertiesType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__EncryptionPropertiesType(struct soap*, struct xenc__EncryptionPropertiesType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__EncryptionPropertiesType(struct soap*, const char *URL, const struct xenc__EncryptionPropertiesType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__EncryptionPropertiesType(struct soap*, const char *URL, const struct xenc__EncryptionPropertiesType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__EncryptionPropertiesType(struct soap*, const char *URL, const struct xenc__EncryptionPropertiesType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__EncryptionPropertiesType(struct soap*, struct xenc__EncryptionPropertiesType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__EncryptionPropertiesType(struct soap*, const char *URL, struct xenc__EncryptionPropertiesType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__xenc__union_ReferenceList"></a>

### `struct __xenc__union_ReferenceList`

This struct is declared in [xenc.h](xenc.h) at line 253, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        long soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList() : DataReference(), KeyReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct xenc__ReferenceType *DataReference` is an optional element *`<xenc:DataReference>`* of XML schema type *`xenc:ReferenceType`*, where the type of this member is a pointer to <code><a href="#xenc__ReferenceType"> xenc__ReferenceType </a></code>
- `struct xenc__ReferenceType *KeyReference` is an optional element *`<xenc:KeyReference>`* of XML schema type *`xenc:ReferenceType`*, where the type of this member is a pointer to <code><a href="#xenc__ReferenceType"> xenc__ReferenceType </a></code>

The following operations on `struct __xenc__union_ReferenceList` are available:

- `struct __xenc__union_ReferenceList *soap_new___xenc__union_ReferenceList(struct soap*)` managed allocation with default initialization
- `struct __xenc__union_ReferenceList *soap_new___xenc__union_ReferenceList(struct soap*, int n)` managed allocation with default initialization of array `struct __xenc__union_ReferenceList[n]`
- `struct __xenc__union_ReferenceList *soap_new_req___xenc__union_ReferenceList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __xenc__union_ReferenceList *soap_new_set___xenc__union_ReferenceList(struct soap*, struct xenc__ReferenceType *DataReference, struct xenc__ReferenceType *KeyReference)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___xenc__union_ReferenceList(struct soap*, struct __xenc__union_ReferenceList*)` (re)set to default initialization values
- `int soap_write___xenc__union_ReferenceList(struct soap*, const struct __xenc__union_ReferenceList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___xenc__union_ReferenceList(struct soap*, struct __xenc__union_ReferenceList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___xenc__union_ReferenceList(struct soap*, const char *URL, const struct __xenc__union_ReferenceList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___xenc__union_ReferenceList(struct soap*, const char *URL, const struct __xenc__union_ReferenceList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___xenc__union_ReferenceList(struct soap*, const char *URL, const struct __xenc__union_ReferenceList*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___xenc__union_ReferenceList(struct soap*, struct __xenc__union_ReferenceList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___xenc__union_ReferenceList(struct soap*, const char *URL, struct __xenc__union_ReferenceList*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_xenc__ReferenceList"></a>

### `struct _xenc__ReferenceList`

This struct is declared in [xenc.h](xenc.h) at line 106, is serialized as XML schema type *`xenc:ReferenceList`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XML schema type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        long soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList() : __size_ReferenceList(), __union_ReferenceList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_ReferenceList` is a sequence of at least 1 elements *`<-union-ReferenceList>`* of XML schema type *`-xenc:union-ReferenceList`* stored in dynamic array `__union_ReferenceList` of length `__size_ReferenceList` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct _xenc__ReferenceList` are available:

- `struct _xenc__ReferenceList *soap_new__xenc__ReferenceList(struct soap*)` managed allocation with default initialization
- `struct _xenc__ReferenceList *soap_new__xenc__ReferenceList(struct soap*, int n)` managed allocation with default initialization of array `struct _xenc__ReferenceList[n]`
- `struct _xenc__ReferenceList *soap_new_req__xenc__ReferenceList(struct soap*, int __size_ReferenceList, struct __xenc__union_ReferenceList *__union_ReferenceList)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _xenc__ReferenceList *soap_new_set__xenc__ReferenceList(struct soap*, int __size_ReferenceList, struct __xenc__union_ReferenceList *__union_ReferenceList)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__xenc__ReferenceList(struct soap*, struct _xenc__ReferenceList*)` (re)set to default initialization values
- `int soap_write__xenc__ReferenceList(struct soap*, const struct _xenc__ReferenceList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__xenc__ReferenceList(struct soap*, struct _xenc__ReferenceList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__xenc__ReferenceList(struct soap*, const char *URL, const struct _xenc__ReferenceList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__xenc__ReferenceList(struct soap*, const char *URL, const struct _xenc__ReferenceList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__xenc__ReferenceList(struct soap*, const char *URL, const struct _xenc__ReferenceList*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__xenc__ReferenceList(struct soap*, struct _xenc__ReferenceList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__xenc__ReferenceList(struct soap*, const char *URL, struct _xenc__ReferenceList*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__EncryptedDataType"></a>

### `struct xenc__EncryptedDataType`

This struct is declared in [xenc.h](xenc.h) at line 85, is serialized as XML schema type *`xenc:EncryptedDataType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct xenc__EncryptionMethodType *EncryptionMethod` is an optional element *`<xenc:EncryptionMethod>`* of XML schema type *`xenc:EncryptionMethodType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptionMethodType"> xenc__EncryptionMethodType </a></code>
- `struct ds__KeyInfoType *ds__KeyInfo` is an optional element *`<ds:KeyInfo>`* of XML schema type *`ds:KeyInfo`*, where the type of this member is a pointer to <code><a href="#ds__KeyInfoType"> ds__KeyInfoType </a></code>
- `struct xenc__CipherDataType *CipherData` is a required element *`<xenc:CipherData>`* of XML schema type *`xenc:CipherDataType`*, where the type of this member is a pointer to <code><a href="#xenc__CipherDataType"> xenc__CipherDataType </a></code>
- `struct xenc__EncryptionPropertiesType *EncryptionProperties` is an optional element *`<xenc:EncryptionProperties>`* of XML schema type *`xenc:EncryptionPropertiesType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptionPropertiesType"> xenc__EncryptionPropertiesType </a></code>
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*
- `char *Type` is an optional attribute *`Type`* of XML schema type *`xsd:string`*
- `char *MimeType` is an optional attribute *`MimeType`* of XML schema type *`xsd:string`*
- `char *Encoding` is an optional attribute *`Encoding`* of XML schema type *`xsd:string`*

The following operations on `struct xenc__EncryptedDataType` are available:

- `struct xenc__EncryptedDataType *soap_new_xenc__EncryptedDataType(struct soap*)` managed allocation with default initialization
- `struct xenc__EncryptedDataType *soap_new_xenc__EncryptedDataType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__EncryptedDataType[n]`
- `struct xenc__EncryptedDataType *soap_new_req_xenc__EncryptedDataType(struct soap*, struct xenc__CipherDataType *CipherData)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__EncryptedDataType *soap_new_set_xenc__EncryptedDataType(struct soap*, struct xenc__EncryptionMethodType *EncryptionMethod, struct ds__KeyInfoType *ds__KeyInfo, struct xenc__CipherDataType *CipherData, struct xenc__EncryptionPropertiesType *EncryptionProperties, char *Id, char *Type, char *MimeType, char *Encoding)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__EncryptedDataType(struct soap*, struct xenc__EncryptedDataType*)` (re)set to default initialization values
- `int soap_write_xenc__EncryptedDataType(struct soap*, const struct xenc__EncryptedDataType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__EncryptedDataType(struct soap*, struct xenc__EncryptedDataType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__EncryptedDataType(struct soap*, const char *URL, const struct xenc__EncryptedDataType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__EncryptedDataType(struct soap*, const char *URL, const struct xenc__EncryptedDataType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__EncryptedDataType(struct soap*, const char *URL, const struct xenc__EncryptedDataType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__EncryptedDataType(struct soap*, struct xenc__EncryptedDataType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__EncryptedDataType(struct soap*, const char *URL, struct xenc__EncryptedDataType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xenc__EncryptedKeyType"></a>

### `struct xenc__EncryptedKeyType`

This struct is declared in [xenc.h](xenc.h) at line 39, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is serialized as XML schema type *`xenc:EncryptedKeyType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XML schema type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding(), ReferenceList(), CarriedKeyName(), Recipient() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct xenc__EncryptionMethodType *EncryptionMethod` is an optional element *`<xenc:EncryptionMethod>`* of XML schema type *`xenc:EncryptionMethodType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptionMethodType"> xenc__EncryptionMethodType </a></code>
- `struct ds__KeyInfoType *ds__KeyInfo` is an optional element *`<ds:KeyInfo>`* of XML schema type *`ds:KeyInfo`*, where the type of this member is a pointer to <code><a href="#ds__KeyInfoType"> ds__KeyInfoType </a></code>
- `struct xenc__CipherDataType *CipherData` is a required element *`<xenc:CipherData>`* of XML schema type *`xenc:CipherDataType`*, where the type of this member is a pointer to <code><a href="#xenc__CipherDataType"> xenc__CipherDataType </a></code>
- `struct xenc__EncryptionPropertiesType *EncryptionProperties` is an optional element *`<xenc:EncryptionProperties>`* of XML schema type *`xenc:EncryptionPropertiesType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptionPropertiesType"> xenc__EncryptionPropertiesType </a></code>
- `char *Id` is an optional attribute *`Id`* of XML schema type *`xsd:string`*
- `char *Type` is an optional attribute *`Type`* of XML schema type *`xsd:string`*
- `char *MimeType` is an optional attribute *`MimeType`* of XML schema type *`xsd:string`*
- `char *Encoding` is an optional attribute *`Encoding`* of XML schema type *`xsd:string`*
- `struct _xenc__ReferenceList *ReferenceList` is an optional element *`<xenc:ReferenceList>`* of XML schema type *`xenc:ReferenceList`*, where the type of this member is a pointer to <code><a href="#_xenc__ReferenceList"> _xenc__ReferenceList </a></code>
- `char *CarriedKeyName` is an optional element *`<xenc:CarriedKeyName>`* of XML schema type *`xsd:string`*
- `char *Recipient` is an optional attribute *`Recipient`* of XML schema type *`xsd:string`*

The following operations on `struct xenc__EncryptedKeyType` are available:

- `struct xenc__EncryptedKeyType *soap_new_xenc__EncryptedKeyType(struct soap*)` managed allocation with default initialization
- `struct xenc__EncryptedKeyType *soap_new_xenc__EncryptedKeyType(struct soap*, int n)` managed allocation with default initialization of array `struct xenc__EncryptedKeyType[n]`
- `struct xenc__EncryptedKeyType *soap_new_req_xenc__EncryptedKeyType(struct soap*, struct xenc__CipherDataType *CipherData)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct xenc__EncryptedKeyType *soap_new_set_xenc__EncryptedKeyType(struct soap*, struct xenc__EncryptionMethodType *EncryptionMethod, struct ds__KeyInfoType *ds__KeyInfo, struct xenc__CipherDataType *CipherData, struct xenc__EncryptionPropertiesType *EncryptionProperties, char *Id, char *Type, char *MimeType, char *Encoding, struct _xenc__ReferenceList *ReferenceList, char *CarriedKeyName, char *Recipient)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_xenc__EncryptedKeyType(struct soap*, struct xenc__EncryptedKeyType*)` (re)set to default initialization values
- `int soap_write_xenc__EncryptedKeyType(struct soap*, const struct xenc__EncryptedKeyType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_xenc__EncryptedKeyType(struct soap*, struct xenc__EncryptedKeyType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_xenc__EncryptedKeyType(struct soap*, const char *URL, const struct xenc__EncryptedKeyType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xenc__EncryptedKeyType(struct soap*, const char *URL, const struct xenc__EncryptedKeyType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xenc__EncryptedKeyType(struct soap*, const char *URL, const struct xenc__EncryptedKeyType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_xenc__EncryptedKeyType(struct soap*, struct xenc__EncryptedKeyType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_xenc__EncryptedKeyType(struct soap*, const char *URL, struct xenc__EncryptedKeyType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="wsc__SecurityContextTokenType"></a>

### `struct wsc__SecurityContextTokenType`

This struct is declared in [wsc.h](wsc.h) at line 88, is serialized as XML schema type *`wsc:SecurityContextTokenType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XML schema type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType() : wsu__Id(), Identifier(), Instance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*
- `char *Identifier` is an optional element *`<wsc:Identifier>`* of XML schema type *`xsd:string`*
- `char *Instance` is an optional element *`<wsc:Instance>`* of XML schema type *`xsd:string`*

The following operations on `struct wsc__SecurityContextTokenType` are available:

- `struct wsc__SecurityContextTokenType *soap_new_wsc__SecurityContextTokenType(struct soap*)` managed allocation with default initialization
- `struct wsc__SecurityContextTokenType *soap_new_wsc__SecurityContextTokenType(struct soap*, int n)` managed allocation with default initialization of array `struct wsc__SecurityContextTokenType[n]`
- `struct wsc__SecurityContextTokenType *soap_new_req_wsc__SecurityContextTokenType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct wsc__SecurityContextTokenType *soap_new_set_wsc__SecurityContextTokenType(struct soap*, char *wsu__Id, char *Identifier, char *Instance)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_wsc__SecurityContextTokenType(struct soap*, struct wsc__SecurityContextTokenType*)` (re)set to default initialization values
- `int soap_write_wsc__SecurityContextTokenType(struct soap*, const struct wsc__SecurityContextTokenType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_wsc__SecurityContextTokenType(struct soap*, struct wsc__SecurityContextTokenType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_wsc__SecurityContextTokenType(struct soap*, const char *URL, const struct wsc__SecurityContextTokenType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_wsc__SecurityContextTokenType(struct soap*, const char *URL, const struct wsc__SecurityContextTokenType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_wsc__SecurityContextTokenType(struct soap*, const char *URL, const struct wsc__SecurityContextTokenType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_wsc__SecurityContextTokenType(struct soap*, struct wsc__SecurityContextTokenType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_wsc__SecurityContextTokenType(struct soap*, const char *URL, struct wsc__SecurityContextTokenType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsc__union_DerivedKeyTokenType"></a>

### `union _wsc__union_DerivedKeyTokenType`

This union is declared in [wsc.h](wsc.h) at line 121, is serializable, but only when used as a member of a struct or class with a union variant selector, and has the following auto-completed declaration in soapStub.h:

    union _wsc__union_DerivedKeyTokenType
    {
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
    };

[![][1] To top](#)


<a name="__wsc__DerivedKeyTokenType_sequence"></a>

### `struct __wsc__DerivedKeyTokenType_sequence`

This struct is declared in [wsc.h](wsc.h) at line 117, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XML schema type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        long soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence() : __union_DerivedKeyTokenType(), Length() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __union_DerivedKeyTokenType` is a union `union _wsc__union_DerivedKeyTokenType` with variant selector `__union_DerivedKeyTokenType` set to one of: `SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation` `SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `ULONG64 *Length` is an optional element *`<wsc:Length>`* of XML schema type *`xsd:unsignedLong`*

The following operations on `struct __wsc__DerivedKeyTokenType_sequence` are available:

- `struct __wsc__DerivedKeyTokenType_sequence *soap_new___wsc__DerivedKeyTokenType_sequence(struct soap*)` managed allocation with default initialization
- `struct __wsc__DerivedKeyTokenType_sequence *soap_new___wsc__DerivedKeyTokenType_sequence(struct soap*, int n)` managed allocation with default initialization of array `struct __wsc__DerivedKeyTokenType_sequence[n]`
- `struct __wsc__DerivedKeyTokenType_sequence *soap_new_req___wsc__DerivedKeyTokenType_sequence(struct soap*, const union _wsc__union_DerivedKeyTokenType& union_DerivedKeyTokenType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __wsc__DerivedKeyTokenType_sequence *soap_new_set___wsc__DerivedKeyTokenType_sequence(struct soap*, int __union_DerivedKeyTokenType, const union _wsc__union_DerivedKeyTokenType& union_DerivedKeyTokenType, ULONG64 *Length)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___wsc__DerivedKeyTokenType_sequence(struct soap*, struct __wsc__DerivedKeyTokenType_sequence*)` (re)set to default initialization values
- `int soap_write___wsc__DerivedKeyTokenType_sequence(struct soap*, const struct __wsc__DerivedKeyTokenType_sequence*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___wsc__DerivedKeyTokenType_sequence(struct soap*, struct __wsc__DerivedKeyTokenType_sequence*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___wsc__DerivedKeyTokenType_sequence(struct soap*, const char *URL, const struct __wsc__DerivedKeyTokenType_sequence*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___wsc__DerivedKeyTokenType_sequence(struct soap*, const char *URL, const struct __wsc__DerivedKeyTokenType_sequence*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___wsc__DerivedKeyTokenType_sequence(struct soap*, const char *URL, const struct __wsc__DerivedKeyTokenType_sequence*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___wsc__DerivedKeyTokenType_sequence(struct soap*, struct __wsc__DerivedKeyTokenType_sequence*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___wsc__DerivedKeyTokenType_sequence(struct soap*, const char *URL, struct __wsc__DerivedKeyTokenType_sequence*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="wsc__DerivedKeyTokenType"></a>

### `struct wsc__DerivedKeyTokenType`

This struct is declared in [wsc.h](wsc.h) at line 110, is serialized as XML schema type *`wsc:DerivedKeyTokenType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XML schema type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XML schema type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XML schema type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType() : wsse__SecurityTokenReference(), Properties(), __DerivedKeyTokenType_sequence(), Label(), Nonce(), wsu__Id(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference` is an optional element *`<wsse:SecurityTokenReference>`* of XML schema type *`wsse:SecurityTokenReference`*, where the type of this member is a pointer to <code><a href="#_wsse__SecurityTokenReference"> _wsse__SecurityTokenReference </a></code>
- `struct wsc__PropertiesType *Properties` is an optional element *`<wsc:Properties>`* of XML schema type *`wsc:PropertiesType`*, where the type of this member is a pointer to <code><a href="#wsc__PropertiesType"> wsc__PropertiesType </a></code>
- `struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence`, where the type of this member is a pointer to <code><a href="#__wsc__DerivedKeyTokenType_sequence"> __wsc__DerivedKeyTokenType_sequence </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Label` is an optional element *`<wsc:Label>`* of XML schema type *`xsd:string`*
- `char *Nonce` is an optional element *`<wsc:Nonce>`* of XML schema type *`xsd:string`*
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*
- `char *Algorithm` is an optional attribute *`Algorithm`* of XML schema type *`xsd:string`*

The following operations on `struct wsc__DerivedKeyTokenType` are available:

- `struct wsc__DerivedKeyTokenType *soap_new_wsc__DerivedKeyTokenType(struct soap*)` managed allocation with default initialization
- `struct wsc__DerivedKeyTokenType *soap_new_wsc__DerivedKeyTokenType(struct soap*, int n)` managed allocation with default initialization of array `struct wsc__DerivedKeyTokenType[n]`
- `struct wsc__DerivedKeyTokenType *soap_new_req_wsc__DerivedKeyTokenType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct wsc__DerivedKeyTokenType *soap_new_set_wsc__DerivedKeyTokenType(struct soap*, struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference, struct wsc__PropertiesType *Properties, struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence, char *Label, char *Nonce, char *wsu__Id, char *Algorithm)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_wsc__DerivedKeyTokenType(struct soap*, struct wsc__DerivedKeyTokenType*)` (re)set to default initialization values
- `int soap_write_wsc__DerivedKeyTokenType(struct soap*, const struct wsc__DerivedKeyTokenType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_wsc__DerivedKeyTokenType(struct soap*, struct wsc__DerivedKeyTokenType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_wsc__DerivedKeyTokenType(struct soap*, const char *URL, const struct wsc__DerivedKeyTokenType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_wsc__DerivedKeyTokenType(struct soap*, const char *URL, const struct wsc__DerivedKeyTokenType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_wsc__DerivedKeyTokenType(struct soap*, const char *URL, const struct wsc__DerivedKeyTokenType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_wsc__DerivedKeyTokenType(struct soap*, struct wsc__DerivedKeyTokenType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_wsc__DerivedKeyTokenType(struct soap*, const char *URL, struct wsc__DerivedKeyTokenType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="wsc__PropertiesType"></a>

### `struct wsc__PropertiesType`

This struct is declared in [wsc.h](wsc.h) at line 114, is serialized as XML schema type *`wsc:PropertiesType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        long soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
    };

where:


The following operations on `struct wsc__PropertiesType` are available:

- `struct wsc__PropertiesType *soap_new_wsc__PropertiesType(struct soap*)` managed allocation with default initialization
- `struct wsc__PropertiesType *soap_new_wsc__PropertiesType(struct soap*, int n)` managed allocation with default initialization of array `struct wsc__PropertiesType[n]`
- `struct wsc__PropertiesType *soap_new_req_wsc__PropertiesType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct wsc__PropertiesType *soap_new_set_wsc__PropertiesType(struct soap*)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_wsc__PropertiesType(struct soap*, struct wsc__PropertiesType*)` (re)set to default initialization values
- `int soap_write_wsc__PropertiesType(struct soap*, const struct wsc__PropertiesType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_wsc__PropertiesType(struct soap*, struct wsc__PropertiesType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_wsc__PropertiesType(struct soap*, const char *URL, const struct wsc__PropertiesType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_wsc__PropertiesType(struct soap*, const char *URL, const struct wsc__PropertiesType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_wsc__PropertiesType(struct soap*, const char *URL, const struct wsc__PropertiesType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_wsc__PropertiesType(struct soap*, struct wsc__PropertiesType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_wsc__PropertiesType(struct soap*, const char *URL, struct wsc__PropertiesType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml1__union_AssertionType"></a>

### `struct __saml1__union_AssertionType`

This struct is declared in [saml1.h](saml1.h) at line 181, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml1__union_AssertionType {
      public:
        /** Optional element 'saml1:Statement' of XML schema type 'saml1:StatementAbstractType' */
        struct saml1__StatementAbstractType *saml1__Statement;
        /** Optional element 'saml1:SubjectStatement' of XML schema type 'saml1:SubjectStatementAbstractType' */
        struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement;
        /** Optional element 'saml1:AuthenticationStatement' of XML schema type 'saml1:AuthenticationStatementType' */
        struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement;
        /** Optional element 'saml1:AuthorizationDecisionStatement' of XML schema type 'saml1:AuthorizationDecisionStatementType' */
        struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement;
        /** Optional element 'saml1:AttributeStatement' of XML schema type 'saml1:AttributeStatementType' */
        struct saml1__AttributeStatementType *saml1__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AssertionType; }
        /** Constructor with member initializations */
        __saml1__union_AssertionType() : saml1__Statement(), saml1__SubjectStatement(), saml1__AuthenticationStatement(), saml1__AuthorizationDecisionStatement(), saml1__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__StatementAbstractType *saml1__Statement` is an optional element *`<saml1:Statement>`* of XML schema type *`saml1:StatementAbstractType`*, where the type of this member is a pointer to <code><a href="#saml1__StatementAbstractType"> saml1__StatementAbstractType </a></code>
- `struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement` is an optional element *`<saml1:SubjectStatement>`* of XML schema type *`saml1:SubjectStatementAbstractType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectStatementAbstractType"> saml1__SubjectStatementAbstractType </a></code>
- `struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement` is an optional element *`<saml1:AuthenticationStatement>`* of XML schema type *`saml1:AuthenticationStatementType`*, where the type of this member is a pointer to <code><a href="#saml1__AuthenticationStatementType"> saml1__AuthenticationStatementType </a></code>
- `struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement` is an optional element *`<saml1:AuthorizationDecisionStatement>`* of XML schema type *`saml1:AuthorizationDecisionStatementType`*, where the type of this member is a pointer to <code><a href="#saml1__AuthorizationDecisionStatementType"> saml1__AuthorizationDecisionStatementType </a></code>
- `struct saml1__AttributeStatementType *saml1__AttributeStatement` is an optional element *`<saml1:AttributeStatement>`* of XML schema type *`saml1:AttributeStatementType`*, where the type of this member is a pointer to <code><a href="#saml1__AttributeStatementType"> saml1__AttributeStatementType </a></code>

The following operations on `struct __saml1__union_AssertionType` are available:

- `struct __saml1__union_AssertionType *soap_new___saml1__union_AssertionType(struct soap*)` managed allocation with default initialization
- `struct __saml1__union_AssertionType *soap_new___saml1__union_AssertionType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml1__union_AssertionType[n]`
- `struct __saml1__union_AssertionType *soap_new_req___saml1__union_AssertionType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml1__union_AssertionType *soap_new_set___saml1__union_AssertionType(struct soap*, struct saml1__StatementAbstractType *saml1__Statement, struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement, struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement, struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement, struct saml1__AttributeStatementType *saml1__AttributeStatement)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml1__union_AssertionType(struct soap*, struct __saml1__union_AssertionType*)` (re)set to default initialization values
- `int soap_write___saml1__union_AssertionType(struct soap*, const struct __saml1__union_AssertionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml1__union_AssertionType(struct soap*, struct __saml1__union_AssertionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml1__union_AssertionType(struct soap*, const char *URL, const struct __saml1__union_AssertionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml1__union_AssertionType(struct soap*, const char *URL, const struct __saml1__union_AssertionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml1__union_AssertionType(struct soap*, const char *URL, const struct __saml1__union_AssertionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml1__union_AssertionType(struct soap*, struct __saml1__union_AssertionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml1__union_AssertionType(struct soap*, const char *URL, struct __saml1__union_AssertionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AssertionType"></a>

### `struct saml1__AssertionType`

This struct is declared in [saml1.h](saml1.h) at line 75, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is serialized as XML schema type *`saml1:AssertionType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AssertionType {
      public:
        /** Optional element 'saml1:Conditions' of XML schema type 'saml1:ConditionsType' */
        struct saml1__ConditionsType *saml1__Conditions;
        /** Optional element 'saml1:Advice' of XML schema type 'saml1:AdviceType' */
        struct saml1__AdviceType *saml1__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml1:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml1__union_AssertionType *__union_AssertionType;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Required attribute 'MajorVersion' of XML schema type 'xsd:string' */
        char *MajorVersion;
        /** Required attribute 'MinorVersion' of XML schema type 'xsd:string' */
        char *MinorVersion;
        /** Required attribute 'AssertionID' of XML schema type 'xsd:string' */
        char *AssertionID;
        /** Required attribute 'Issuer' of XML schema type 'xsd:string' */
        char *Issuer;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        struct timeval IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml1__AssertionType; }
        /** Constructor with member initializations */
        saml1__AssertionType() : saml1__Conditions(), saml1__Advice(), __size_AssertionType(), __union_AssertionType(), ds__Signature(), MajorVersion(), MinorVersion(), AssertionID(), Issuer(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__ConditionsType *saml1__Conditions` is an optional element *`<saml1:Conditions>`* of XML schema type *`saml1:ConditionsType`*, where the type of this member is a pointer to <code><a href="#saml1__ConditionsType"> saml1__ConditionsType </a></code>
- `struct saml1__AdviceType *saml1__Advice` is an optional element *`<saml1:Advice>`* of XML schema type *`saml1:AdviceType`*, where the type of this member is a pointer to <code><a href="#saml1__AdviceType"> saml1__AdviceType </a></code>
- `int __size_AssertionType` is a sequence of elements *`<-union-AssertionType>`* of XML schema type *`-saml1:union-AssertionType`* stored in dynamic array `__union_AssertionType` of length `__size_AssertionType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct ds__SignatureType *ds__Signature` is an optional element *`<ds:Signature>`* of XML schema type *`ds:Signature`*, where the type of this member is a pointer to <code><a href="#ds__SignatureType"> ds__SignatureType </a></code>
- `char *MajorVersion` is a required attribute *`MajorVersion`* of XML schema type *`xsd:string`*
- `char *MinorVersion` is a required attribute *`MinorVersion`* of XML schema type *`xsd:string`*
- `char *AssertionID` is a required attribute *`AssertionID`* of XML schema type *`xsd:string`*
- `char *Issuer` is a required attribute *`Issuer`* of XML schema type *`xsd:string`*
- `struct timeval IssueInstant` is a required attribute *`IssueInstant`* of XML schema type *`xsd:dateTime`* with a custom serializer `xsd__dateTime`, where the type of this member is <code><a href="#timeval"> timeval </a></code>
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*

The following operations on `struct saml1__AssertionType` are available:

- `struct saml1__AssertionType *soap_new_saml1__AssertionType(struct soap*)` managed allocation with default initialization
- `struct saml1__AssertionType *soap_new_saml1__AssertionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AssertionType[n]`
- `struct saml1__AssertionType *soap_new_req_saml1__AssertionType(struct soap*, int __size_AssertionType, struct __saml1__union_AssertionType *__union_AssertionType, char *MajorVersion, char *MinorVersion, char *AssertionID, char *Issuer, const struct timeval& IssueInstant)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AssertionType *soap_new_set_saml1__AssertionType(struct soap*, struct saml1__ConditionsType *saml1__Conditions, struct saml1__AdviceType *saml1__Advice, int __size_AssertionType, struct __saml1__union_AssertionType *__union_AssertionType, struct ds__SignatureType *ds__Signature, char *MajorVersion, char *MinorVersion, char *AssertionID, char *Issuer, const struct timeval& IssueInstant, char *wsu__Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AssertionType(struct soap*, struct saml1__AssertionType*)` (re)set to default initialization values
- `int soap_write_saml1__AssertionType(struct soap*, const struct saml1__AssertionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AssertionType(struct soap*, struct saml1__AssertionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AssertionType(struct soap*, const char *URL, const struct saml1__AssertionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AssertionType(struct soap*, const char *URL, const struct saml1__AssertionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AssertionType(struct soap*, const char *URL, const struct saml1__AssertionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AssertionType(struct soap*, struct saml1__AssertionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AssertionType(struct soap*, const char *URL, struct saml1__AssertionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml1__union_ConditionsType"></a>

### `struct __saml1__union_ConditionsType`

This struct is declared in [saml1.h](saml1.h) at line 224, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml1__union_ConditionsType {
      public:
        /** Optional element 'saml1:AudienceRestrictionCondition' of XML schema type 'saml1:AudienceRestrictionConditionType' */
        struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition;
        /** Optional element 'saml1:DoNotCacheCondition' of XML schema type 'saml1:DoNotCacheConditionType' */
        struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition;
        /** Optional element 'saml1:Condition' of XML schema type 'saml1:ConditionAbstractType' */
        struct saml1__ConditionAbstractType *saml1__Condition;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml1__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml1__union_ConditionsType() : saml1__AudienceRestrictionCondition(), saml1__DoNotCacheCondition(), saml1__Condition() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition` is an optional element *`<saml1:AudienceRestrictionCondition>`* of XML schema type *`saml1:AudienceRestrictionConditionType`*, where the type of this member is a pointer to <code><a href="#saml1__AudienceRestrictionConditionType"> saml1__AudienceRestrictionConditionType </a></code>
- `struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition` is an optional element *`<saml1:DoNotCacheCondition>`* of XML schema type *`saml1:DoNotCacheConditionType`*, where the type of this member is a pointer to <code><a href="#saml1__DoNotCacheConditionType"> saml1__DoNotCacheConditionType </a></code>
- `struct saml1__ConditionAbstractType *saml1__Condition` is an optional element *`<saml1:Condition>`* of XML schema type *`saml1:ConditionAbstractType`*, where the type of this member is a pointer to <code><a href="#saml1__ConditionAbstractType"> saml1__ConditionAbstractType </a></code>

The following operations on `struct __saml1__union_ConditionsType` are available:

- `struct __saml1__union_ConditionsType *soap_new___saml1__union_ConditionsType(struct soap*)` managed allocation with default initialization
- `struct __saml1__union_ConditionsType *soap_new___saml1__union_ConditionsType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml1__union_ConditionsType[n]`
- `struct __saml1__union_ConditionsType *soap_new_req___saml1__union_ConditionsType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml1__union_ConditionsType *soap_new_set___saml1__union_ConditionsType(struct soap*, struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition, struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition, struct saml1__ConditionAbstractType *saml1__Condition)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml1__union_ConditionsType(struct soap*, struct __saml1__union_ConditionsType*)` (re)set to default initialization values
- `int soap_write___saml1__union_ConditionsType(struct soap*, const struct __saml1__union_ConditionsType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml1__union_ConditionsType(struct soap*, struct __saml1__union_ConditionsType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml1__union_ConditionsType(struct soap*, const char *URL, const struct __saml1__union_ConditionsType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml1__union_ConditionsType(struct soap*, const char *URL, const struct __saml1__union_ConditionsType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml1__union_ConditionsType(struct soap*, const char *URL, const struct __saml1__union_ConditionsType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml1__union_ConditionsType(struct soap*, struct __saml1__union_ConditionsType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml1__union_ConditionsType(struct soap*, const char *URL, struct __saml1__union_ConditionsType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__ConditionsType"></a>

### `struct saml1__ConditionsType`

This struct is declared in [saml1.h](saml1.h) at line 78, is serialized as XML schema type *`saml1:ConditionsType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml1:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml1__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionsType; }
        /** Constructor with member initializations */
        saml1__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_ConditionsType` is a sequence of elements *`<-union-ConditionsType>`* of XML schema type *`-saml1:union-ConditionsType`* stored in dynamic array `__union_ConditionsType` of length `__size_ConditionsType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct timeval *NotBefore` is an optional attribute *`NotBefore`* of XML schema type *`xsd:dateTime`*, where the type of this member is a pointer to <code><a href="#timeval"> timeval </a></code>
- `struct timeval *NotOnOrAfter` is an optional attribute *`NotOnOrAfter`* of XML schema type *`xsd:dateTime`*, where the type of this member is a pointer to <code><a href="#timeval"> timeval </a></code>

The following operations on `struct saml1__ConditionsType` are available:

- `struct saml1__ConditionsType *soap_new_saml1__ConditionsType(struct soap*)` managed allocation with default initialization
- `struct saml1__ConditionsType *soap_new_saml1__ConditionsType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__ConditionsType[n]`
- `struct saml1__ConditionsType *soap_new_req_saml1__ConditionsType(struct soap*, int __size_ConditionsType, struct __saml1__union_ConditionsType *__union_ConditionsType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__ConditionsType *soap_new_set_saml1__ConditionsType(struct soap*, int __size_ConditionsType, struct __saml1__union_ConditionsType *__union_ConditionsType, struct timeval *NotBefore, struct timeval *NotOnOrAfter)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__ConditionsType(struct soap*, struct saml1__ConditionsType*)` (re)set to default initialization values
- `int soap_write_saml1__ConditionsType(struct soap*, const struct saml1__ConditionsType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__ConditionsType(struct soap*, struct saml1__ConditionsType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__ConditionsType(struct soap*, const char *URL, const struct saml1__ConditionsType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__ConditionsType(struct soap*, const char *URL, const struct saml1__ConditionsType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__ConditionsType(struct soap*, const char *URL, const struct saml1__ConditionsType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__ConditionsType(struct soap*, struct saml1__ConditionsType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__ConditionsType(struct soap*, const char *URL, struct saml1__ConditionsType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__ConditionAbstractType"></a>

### `struct saml1__ConditionAbstractType`

This struct is declared in [saml1.h](saml1.h) at line 81, is serialized as XML schema type *`saml1:ConditionAbstractType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml1__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
    };

where:


The following operations on `struct saml1__ConditionAbstractType` are available:

- `struct saml1__ConditionAbstractType *soap_new_saml1__ConditionAbstractType(struct soap*)` managed allocation with default initialization
- `struct saml1__ConditionAbstractType *soap_new_saml1__ConditionAbstractType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__ConditionAbstractType[n]`
- `struct saml1__ConditionAbstractType *soap_new_req_saml1__ConditionAbstractType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__ConditionAbstractType *soap_new_set_saml1__ConditionAbstractType(struct soap*)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__ConditionAbstractType(struct soap*, struct saml1__ConditionAbstractType*)` (re)set to default initialization values
- `int soap_write_saml1__ConditionAbstractType(struct soap*, const struct saml1__ConditionAbstractType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__ConditionAbstractType(struct soap*, struct saml1__ConditionAbstractType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__ConditionAbstractType(struct soap*, const char *URL, const struct saml1__ConditionAbstractType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__ConditionAbstractType(struct soap*, const char *URL, const struct saml1__ConditionAbstractType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__ConditionAbstractType(struct soap*, const char *URL, const struct saml1__ConditionAbstractType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__ConditionAbstractType(struct soap*, struct saml1__ConditionAbstractType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__ConditionAbstractType(struct soap*, const char *URL, struct saml1__ConditionAbstractType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml1__union_AdviceType"></a>

### `struct __saml1__union_AdviceType`

This struct is declared in [saml1.h](saml1.h) at line 270, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml1__union_AdviceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AdviceType; }
        /** Constructor with member initializations */
        __saml1__union_AdviceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *saml1__AssertionIDReference` is an optional element *`<saml1:AssertionIDReference>`* of XML schema type *`xsd:string`*
- `struct saml1__AssertionType *saml1__Assertion` is an optional element *`<saml1:Assertion>`* of XML schema type *`saml1:AssertionType`*, where the type of this member is a pointer to <code><a href="#saml1__AssertionType"> saml1__AssertionType </a></code>

The following operations on `struct __saml1__union_AdviceType` are available:

- `struct __saml1__union_AdviceType *soap_new___saml1__union_AdviceType(struct soap*)` managed allocation with default initialization
- `struct __saml1__union_AdviceType *soap_new___saml1__union_AdviceType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml1__union_AdviceType[n]`
- `struct __saml1__union_AdviceType *soap_new_req___saml1__union_AdviceType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml1__union_AdviceType *soap_new_set___saml1__union_AdviceType(struct soap*, char *saml1__AssertionIDReference, struct saml1__AssertionType *saml1__Assertion)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml1__union_AdviceType(struct soap*, struct __saml1__union_AdviceType*)` (re)set to default initialization values
- `int soap_write___saml1__union_AdviceType(struct soap*, const struct __saml1__union_AdviceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml1__union_AdviceType(struct soap*, struct __saml1__union_AdviceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml1__union_AdviceType(struct soap*, const char *URL, const struct __saml1__union_AdviceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml1__union_AdviceType(struct soap*, const char *URL, const struct __saml1__union_AdviceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml1__union_AdviceType(struct soap*, const char *URL, const struct __saml1__union_AdviceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml1__union_AdviceType(struct soap*, struct __saml1__union_AdviceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml1__union_AdviceType(struct soap*, const char *URL, struct __saml1__union_AdviceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AdviceType"></a>

### `struct saml1__AdviceType`

This struct is declared in [saml1.h](saml1.h) at line 90, is serialized as XML schema type *`saml1:AdviceType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml1:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml1__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml1__AdviceType; }
        /** Constructor with member initializations */
        saml1__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_AdviceType` is a sequence of elements *`<-union-AdviceType>`* of XML schema type *`-saml1:union-AdviceType`* stored in dynamic array `__union_AdviceType` of length `__size_AdviceType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml1__AdviceType` are available:

- `struct saml1__AdviceType *soap_new_saml1__AdviceType(struct soap*)` managed allocation with default initialization
- `struct saml1__AdviceType *soap_new_saml1__AdviceType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AdviceType[n]`
- `struct saml1__AdviceType *soap_new_req_saml1__AdviceType(struct soap*, int __size_AdviceType, struct __saml1__union_AdviceType *__union_AdviceType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AdviceType *soap_new_set_saml1__AdviceType(struct soap*, int __size_AdviceType, struct __saml1__union_AdviceType *__union_AdviceType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AdviceType(struct soap*, struct saml1__AdviceType*)` (re)set to default initialization values
- `int soap_write_saml1__AdviceType(struct soap*, const struct saml1__AdviceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AdviceType(struct soap*, struct saml1__AdviceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AdviceType(struct soap*, const char *URL, const struct saml1__AdviceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AdviceType(struct soap*, const char *URL, const struct saml1__AdviceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AdviceType(struct soap*, const char *URL, const struct saml1__AdviceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AdviceType(struct soap*, struct saml1__AdviceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AdviceType(struct soap*, const char *URL, struct saml1__AdviceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__StatementAbstractType"></a>

### `struct saml1__StatementAbstractType`

This struct is declared in [saml1.h](saml1.h) at line 93, is serialized as XML schema type *`saml1:StatementAbstractType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__StatementAbstractType; }
        /** Constructor with member initializations */
        saml1__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
    };

where:


The following operations on `struct saml1__StatementAbstractType` are available:

- `struct saml1__StatementAbstractType *soap_new_saml1__StatementAbstractType(struct soap*)` managed allocation with default initialization
- `struct saml1__StatementAbstractType *soap_new_saml1__StatementAbstractType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__StatementAbstractType[n]`
- `struct saml1__StatementAbstractType *soap_new_req_saml1__StatementAbstractType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__StatementAbstractType *soap_new_set_saml1__StatementAbstractType(struct soap*)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__StatementAbstractType(struct soap*, struct saml1__StatementAbstractType*)` (re)set to default initialization values
- `int soap_write_saml1__StatementAbstractType(struct soap*, const struct saml1__StatementAbstractType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__StatementAbstractType(struct soap*, struct saml1__StatementAbstractType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__StatementAbstractType(struct soap*, const char *URL, const struct saml1__StatementAbstractType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__StatementAbstractType(struct soap*, const char *URL, const struct saml1__StatementAbstractType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__StatementAbstractType(struct soap*, const char *URL, const struct saml1__StatementAbstractType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__StatementAbstractType(struct soap*, struct saml1__StatementAbstractType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__StatementAbstractType(struct soap*, const char *URL, struct saml1__StatementAbstractType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__SubjectType"></a>

### `struct saml1__SubjectType`

This struct is declared in [saml1.h](saml1.h) at line 99, is serialized as XML schema type *`saml1:SubjectType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__SubjectType {
      public:
        /** Optional element 'saml1:NameIdentifier' of XML schema type 'saml1:NameIdentifierType' */
        struct saml1__NameIdentifierType *saml1__NameIdentifier;
        /** Optional element 'saml1:SubjectConfirmation' of XML schema type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation;
        /** Optional element 'saml1:SubjectConfirmation' of XML schema type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation_;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectType; }
        /** Constructor with member initializations */
        saml1__SubjectType() : saml1__NameIdentifier(), saml1__SubjectConfirmation(), saml1__SubjectConfirmation_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__NameIdentifierType *saml1__NameIdentifier` is an optional element *`<saml1:NameIdentifier>`* of XML schema type *`saml1:NameIdentifierType`*, where the type of this member is a pointer to <code><a href="#saml1__NameIdentifierType"> saml1__NameIdentifierType </a></code>
- `struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation` is an optional element *`<saml1:SubjectConfirmation>`* of XML schema type *`saml1:SubjectConfirmationType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectConfirmationType"> saml1__SubjectConfirmationType </a></code>
- `struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation_` is an optional element *`<saml1:SubjectConfirmation>`* of XML schema type *`saml1:SubjectConfirmationType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectConfirmationType"> saml1__SubjectConfirmationType </a></code>

The following operations on `struct saml1__SubjectType` are available:

- `struct saml1__SubjectType *soap_new_saml1__SubjectType(struct soap*)` managed allocation with default initialization
- `struct saml1__SubjectType *soap_new_saml1__SubjectType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__SubjectType[n]`
- `struct saml1__SubjectType *soap_new_req_saml1__SubjectType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__SubjectType *soap_new_set_saml1__SubjectType(struct soap*, struct saml1__NameIdentifierType *saml1__NameIdentifier, struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation, struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation_)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__SubjectType(struct soap*, struct saml1__SubjectType*)` (re)set to default initialization values
- `int soap_write_saml1__SubjectType(struct soap*, const struct saml1__SubjectType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__SubjectType(struct soap*, struct saml1__SubjectType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__SubjectType(struct soap*, const char *URL, const struct saml1__SubjectType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__SubjectType(struct soap*, const char *URL, const struct saml1__SubjectType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__SubjectType(struct soap*, const char *URL, const struct saml1__SubjectType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__SubjectType(struct soap*, struct saml1__SubjectType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__SubjectType(struct soap*, const char *URL, struct saml1__SubjectType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__SubjectConfirmationType"></a>

### `struct saml1__SubjectConfirmationType`

This struct is declared in [saml1.h](saml1.h) at line 105, is serialized as XML schema type *`saml1:SubjectConfirmationType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__SubjectConfirmationType {
      public:
        /** Sequence of at least 1 elements 'saml1:ConfirmationMethod' of XML schema type 'xsd:string' stored in dynamic array saml1__ConfirmationMethod of length __sizeConfirmationMethod */
        int __sizeConfirmationMethod;
        char **saml1__ConfirmationMethod;
        /** Optional element 'saml1:SubjectConfirmationData' of XML schema type 'xsd:anyType' */
        char *saml1__SubjectConfirmationData;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml1__SubjectConfirmationType() : __sizeConfirmationMethod(), saml1__ConfirmationMethod(), saml1__SubjectConfirmationData(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeConfirmationMethod` is a sequence of at least 1 elements *`<saml1:ConfirmationMethod>`* of XML schema type *`xsd:string`* stored in dynamic array `saml1__ConfirmationMethod` of length `__sizeConfirmationMethod` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *saml1__SubjectConfirmationData` is an optional element *`<saml1:SubjectConfirmationData>`* of XML schema type *`xsd:anyType`*, where the type of this member is <code><a href="#_XML"> _XML </a></code>
- `struct ds__KeyInfoType *ds__KeyInfo` is an optional element *`<ds:KeyInfo>`* of XML schema type *`ds:KeyInfo`*, where the type of this member is a pointer to <code><a href="#ds__KeyInfoType"> ds__KeyInfoType </a></code>

The following operations on `struct saml1__SubjectConfirmationType` are available:

- `struct saml1__SubjectConfirmationType *soap_new_saml1__SubjectConfirmationType(struct soap*)` managed allocation with default initialization
- `struct saml1__SubjectConfirmationType *soap_new_saml1__SubjectConfirmationType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__SubjectConfirmationType[n]`
- `struct saml1__SubjectConfirmationType *soap_new_req_saml1__SubjectConfirmationType(struct soap*, int __sizeConfirmationMethod, char **saml1__ConfirmationMethod)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__SubjectConfirmationType *soap_new_set_saml1__SubjectConfirmationType(struct soap*, int __sizeConfirmationMethod, char **saml1__ConfirmationMethod, char *saml1__SubjectConfirmationData, struct ds__KeyInfoType *ds__KeyInfo)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__SubjectConfirmationType(struct soap*, struct saml1__SubjectConfirmationType*)` (re)set to default initialization values
- `int soap_write_saml1__SubjectConfirmationType(struct soap*, const struct saml1__SubjectConfirmationType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__SubjectConfirmationType(struct soap*, struct saml1__SubjectConfirmationType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__SubjectConfirmationType(struct soap*, const char *URL, const struct saml1__SubjectConfirmationType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__SubjectConfirmationType(struct soap*, const char *URL, const struct saml1__SubjectConfirmationType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__SubjectConfirmationType(struct soap*, const char *URL, const struct saml1__SubjectConfirmationType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__SubjectConfirmationType(struct soap*, struct saml1__SubjectConfirmationType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__SubjectConfirmationType(struct soap*, const char *URL, struct saml1__SubjectConfirmationType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__SubjectLocalityType"></a>

### `struct saml1__SubjectLocalityType`

This struct is declared in [saml1.h](saml1.h) at line 111, is serialized as XML schema type *`saml1:SubjectLocalityType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__SubjectLocalityType {
      public:
        /** Optional attribute 'IPAddress' of XML schema type 'xsd:string' */
        char *IPAddress;
        /** Optional attribute 'DNSAddress' of XML schema type 'xsd:string' */
        char *DNSAddress;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml1__SubjectLocalityType() : IPAddress(), DNSAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *IPAddress` is an optional attribute *`IPAddress`* of XML schema type *`xsd:string`*
- `char *DNSAddress` is an optional attribute *`DNSAddress`* of XML schema type *`xsd:string`*

The following operations on `struct saml1__SubjectLocalityType` are available:

- `struct saml1__SubjectLocalityType *soap_new_saml1__SubjectLocalityType(struct soap*)` managed allocation with default initialization
- `struct saml1__SubjectLocalityType *soap_new_saml1__SubjectLocalityType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__SubjectLocalityType[n]`
- `struct saml1__SubjectLocalityType *soap_new_req_saml1__SubjectLocalityType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__SubjectLocalityType *soap_new_set_saml1__SubjectLocalityType(struct soap*, char *IPAddress, char *DNSAddress)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__SubjectLocalityType(struct soap*, struct saml1__SubjectLocalityType*)` (re)set to default initialization values
- `int soap_write_saml1__SubjectLocalityType(struct soap*, const struct saml1__SubjectLocalityType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__SubjectLocalityType(struct soap*, struct saml1__SubjectLocalityType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__SubjectLocalityType(struct soap*, const char *URL, const struct saml1__SubjectLocalityType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__SubjectLocalityType(struct soap*, const char *URL, const struct saml1__SubjectLocalityType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__SubjectLocalityType(struct soap*, const char *URL, const struct saml1__SubjectLocalityType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__SubjectLocalityType(struct soap*, struct saml1__SubjectLocalityType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__SubjectLocalityType(struct soap*, const char *URL, struct saml1__SubjectLocalityType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AuthorityBindingType"></a>

### `struct saml1__AuthorityBindingType`

This struct is declared in [saml1.h](saml1.h) at line 114, is serialized as XML schema type *`saml1:AuthorityBindingType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AuthorityBindingType {
      public:
        /** Required attribute 'AuthorityKind' of XML schema type 'xsd:QName' */
        char *AuthorityKind;
        /** Required attribute 'Location' of XML schema type 'xsd:string' */
        char *Location;
        /** Required attribute 'Binding' of XML schema type 'xsd:string' */
        char *Binding;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorityBindingType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorityBindingType; }
        /** Constructor with member initializations */
        saml1__AuthorityBindingType() : AuthorityKind(), Location(), Binding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *AuthorityKind` is a required attribute *`AuthorityKind`* of XML schema type *`xsd:QName`*, where the type of this member is <code><a href="#_QName"> _QName </a></code>
- `char *Location` is a required attribute *`Location`* of XML schema type *`xsd:string`*
- `char *Binding` is a required attribute *`Binding`* of XML schema type *`xsd:string`*

The following operations on `struct saml1__AuthorityBindingType` are available:

- `struct saml1__AuthorityBindingType *soap_new_saml1__AuthorityBindingType(struct soap*)` managed allocation with default initialization
- `struct saml1__AuthorityBindingType *soap_new_saml1__AuthorityBindingType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AuthorityBindingType[n]`
- `struct saml1__AuthorityBindingType *soap_new_req_saml1__AuthorityBindingType(struct soap*, char *AuthorityKind, char *Location, char *Binding)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AuthorityBindingType *soap_new_set_saml1__AuthorityBindingType(struct soap*, char *AuthorityKind, char *Location, char *Binding)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AuthorityBindingType(struct soap*, struct saml1__AuthorityBindingType*)` (re)set to default initialization values
- `int soap_write_saml1__AuthorityBindingType(struct soap*, const struct saml1__AuthorityBindingType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AuthorityBindingType(struct soap*, struct saml1__AuthorityBindingType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AuthorityBindingType(struct soap*, const char *URL, const struct saml1__AuthorityBindingType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AuthorityBindingType(struct soap*, const char *URL, const struct saml1__AuthorityBindingType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AuthorityBindingType(struct soap*, const char *URL, const struct saml1__AuthorityBindingType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AuthorityBindingType(struct soap*, struct saml1__AuthorityBindingType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AuthorityBindingType(struct soap*, const char *URL, struct saml1__AuthorityBindingType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml1__union_EvidenceType"></a>

### `struct __saml1__union_EvidenceType`

This struct is declared in [saml1.h](saml1.h) at line 395, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml1__union_EvidenceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml1__union_EvidenceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *saml1__AssertionIDReference` is an optional element *`<saml1:AssertionIDReference>`* of XML schema type *`xsd:string`*
- `struct saml1__AssertionType *saml1__Assertion` is an optional element *`<saml1:Assertion>`* of XML schema type *`saml1:AssertionType`*, where the type of this member is a pointer to <code><a href="#saml1__AssertionType"> saml1__AssertionType </a></code>

The following operations on `struct __saml1__union_EvidenceType` are available:

- `struct __saml1__union_EvidenceType *soap_new___saml1__union_EvidenceType(struct soap*)` managed allocation with default initialization
- `struct __saml1__union_EvidenceType *soap_new___saml1__union_EvidenceType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml1__union_EvidenceType[n]`
- `struct __saml1__union_EvidenceType *soap_new_req___saml1__union_EvidenceType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml1__union_EvidenceType *soap_new_set___saml1__union_EvidenceType(struct soap*, char *saml1__AssertionIDReference, struct saml1__AssertionType *saml1__Assertion)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml1__union_EvidenceType(struct soap*, struct __saml1__union_EvidenceType*)` (re)set to default initialization values
- `int soap_write___saml1__union_EvidenceType(struct soap*, const struct __saml1__union_EvidenceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml1__union_EvidenceType(struct soap*, struct __saml1__union_EvidenceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml1__union_EvidenceType(struct soap*, const char *URL, const struct __saml1__union_EvidenceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml1__union_EvidenceType(struct soap*, const char *URL, const struct __saml1__union_EvidenceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml1__union_EvidenceType(struct soap*, const char *URL, const struct __saml1__union_EvidenceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml1__union_EvidenceType(struct soap*, struct __saml1__union_EvidenceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml1__union_EvidenceType(struct soap*, const char *URL, struct __saml1__union_EvidenceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__EvidenceType"></a>

### `struct saml1__EvidenceType`

This struct is declared in [saml1.h](saml1.h) at line 123, is serialized as XML schema type *`saml1:EvidenceType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml1:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml1__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml1__EvidenceType; }
        /** Constructor with member initializations */
        saml1__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_EvidenceType` is a sequence of elements *`<-union-EvidenceType>`* of XML schema type *`-saml1:union-EvidenceType`* stored in dynamic array `__union_EvidenceType` of length `__size_EvidenceType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml1__EvidenceType` are available:

- `struct saml1__EvidenceType *soap_new_saml1__EvidenceType(struct soap*)` managed allocation with default initialization
- `struct saml1__EvidenceType *soap_new_saml1__EvidenceType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__EvidenceType[n]`
- `struct saml1__EvidenceType *soap_new_req_saml1__EvidenceType(struct soap*, int __size_EvidenceType, struct __saml1__union_EvidenceType *__union_EvidenceType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__EvidenceType *soap_new_set_saml1__EvidenceType(struct soap*, int __size_EvidenceType, struct __saml1__union_EvidenceType *__union_EvidenceType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__EvidenceType(struct soap*, struct saml1__EvidenceType*)` (re)set to default initialization values
- `int soap_write_saml1__EvidenceType(struct soap*, const struct saml1__EvidenceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__EvidenceType(struct soap*, struct saml1__EvidenceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__EvidenceType(struct soap*, const char *URL, const struct saml1__EvidenceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__EvidenceType(struct soap*, const char *URL, const struct saml1__EvidenceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__EvidenceType(struct soap*, const char *URL, const struct saml1__EvidenceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__EvidenceType(struct soap*, struct saml1__EvidenceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__EvidenceType(struct soap*, const char *URL, struct saml1__EvidenceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AttributeDesignatorType"></a>

### `struct saml1__AttributeDesignatorType`

This struct is declared in [saml1.h](saml1.h) at line 129, is serialized as XML schema type *`saml1:AttributeDesignatorType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AttributeDesignatorType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeDesignatorType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeDesignatorType; }
        /** Constructor with member initializations */
        saml1__AttributeDesignatorType() : AttributeName(), AttributeNamespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *AttributeName` is a required attribute *`AttributeName`* of XML schema type *`xsd:string`*
- `char *AttributeNamespace` is a required attribute *`AttributeNamespace`* of XML schema type *`xsd:string`*

The following operations on `struct saml1__AttributeDesignatorType` are available:

- `struct saml1__AttributeDesignatorType *soap_new_saml1__AttributeDesignatorType(struct soap*)` managed allocation with default initialization
- `struct saml1__AttributeDesignatorType *soap_new_saml1__AttributeDesignatorType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AttributeDesignatorType[n]`
- `struct saml1__AttributeDesignatorType *soap_new_req_saml1__AttributeDesignatorType(struct soap*, char *AttributeName, char *AttributeNamespace)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AttributeDesignatorType *soap_new_set_saml1__AttributeDesignatorType(struct soap*, char *AttributeName, char *AttributeNamespace)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AttributeDesignatorType(struct soap*, struct saml1__AttributeDesignatorType*)` (re)set to default initialization values
- `int soap_write_saml1__AttributeDesignatorType(struct soap*, const struct saml1__AttributeDesignatorType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AttributeDesignatorType(struct soap*, struct saml1__AttributeDesignatorType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AttributeDesignatorType(struct soap*, const char *URL, const struct saml1__AttributeDesignatorType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AttributeDesignatorType(struct soap*, const char *URL, const struct saml1__AttributeDesignatorType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AttributeDesignatorType(struct soap*, const char *URL, const struct saml1__AttributeDesignatorType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AttributeDesignatorType(struct soap*, struct saml1__AttributeDesignatorType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AttributeDesignatorType(struct soap*, const char *URL, struct saml1__AttributeDesignatorType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AudienceRestrictionConditionType"></a>

### `struct saml1__AudienceRestrictionConditionType`

This struct is declared in [saml1.h](saml1.h) at line 84, is serialized as XML schema type *`saml1:AudienceRestrictionConditionType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AudienceRestrictionConditionType {
      public:
        /** Sequence of at least 1 elements 'saml1:Audience' of XML schema type 'xsd:string' stored in dynamic array saml1__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml1__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AudienceRestrictionConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__AudienceRestrictionConditionType; }
        /** Constructor with member initializations */
        saml1__AudienceRestrictionConditionType() : __sizeAudience(), saml1__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeAudience` is a sequence of at least 1 elements *`<saml1:Audience>`* of XML schema type *`xsd:string`* stored in dynamic array `saml1__Audience` of length `__sizeAudience` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml1__AudienceRestrictionConditionType` are available:

- `struct saml1__AudienceRestrictionConditionType *soap_new_saml1__AudienceRestrictionConditionType(struct soap*)` managed allocation with default initialization
- `struct saml1__AudienceRestrictionConditionType *soap_new_saml1__AudienceRestrictionConditionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AudienceRestrictionConditionType[n]`
- `struct saml1__AudienceRestrictionConditionType *soap_new_req_saml1__AudienceRestrictionConditionType(struct soap*, int __sizeAudience, char **saml1__Audience)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AudienceRestrictionConditionType *soap_new_set_saml1__AudienceRestrictionConditionType(struct soap*, int __sizeAudience, char **saml1__Audience)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AudienceRestrictionConditionType(struct soap*, struct saml1__AudienceRestrictionConditionType*)` (re)set to default initialization values
- `int soap_write_saml1__AudienceRestrictionConditionType(struct soap*, const struct saml1__AudienceRestrictionConditionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AudienceRestrictionConditionType(struct soap*, struct saml1__AudienceRestrictionConditionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AudienceRestrictionConditionType(struct soap*, const char *URL, const struct saml1__AudienceRestrictionConditionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AudienceRestrictionConditionType(struct soap*, const char *URL, const struct saml1__AudienceRestrictionConditionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AudienceRestrictionConditionType(struct soap*, const char *URL, const struct saml1__AudienceRestrictionConditionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AudienceRestrictionConditionType(struct soap*, struct saml1__AudienceRestrictionConditionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AudienceRestrictionConditionType(struct soap*, const char *URL, struct saml1__AudienceRestrictionConditionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__DoNotCacheConditionType"></a>

### `struct saml1__DoNotCacheConditionType`

This struct is declared in [saml1.h](saml1.h) at line 87, is serialized as XML schema type *`saml1:DoNotCacheConditionType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__DoNotCacheConditionType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__DoNotCacheConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__DoNotCacheConditionType; }
        /** Constructor with member initializations */
        saml1__DoNotCacheConditionType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:


The following operations on `struct saml1__DoNotCacheConditionType` are available:

- `struct saml1__DoNotCacheConditionType *soap_new_saml1__DoNotCacheConditionType(struct soap*)` managed allocation with default initialization
- `struct saml1__DoNotCacheConditionType *soap_new_saml1__DoNotCacheConditionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__DoNotCacheConditionType[n]`
- `struct saml1__DoNotCacheConditionType *soap_new_req_saml1__DoNotCacheConditionType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__DoNotCacheConditionType *soap_new_set_saml1__DoNotCacheConditionType(struct soap*)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__DoNotCacheConditionType(struct soap*, struct saml1__DoNotCacheConditionType*)` (re)set to default initialization values
- `int soap_write_saml1__DoNotCacheConditionType(struct soap*, const struct saml1__DoNotCacheConditionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__DoNotCacheConditionType(struct soap*, struct saml1__DoNotCacheConditionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__DoNotCacheConditionType(struct soap*, const char *URL, const struct saml1__DoNotCacheConditionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__DoNotCacheConditionType(struct soap*, const char *URL, const struct saml1__DoNotCacheConditionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__DoNotCacheConditionType(struct soap*, const char *URL, const struct saml1__DoNotCacheConditionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__DoNotCacheConditionType(struct soap*, struct saml1__DoNotCacheConditionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__DoNotCacheConditionType(struct soap*, const char *URL, struct saml1__DoNotCacheConditionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__SubjectStatementAbstractType"></a>

### `struct saml1__SubjectStatementAbstractType`

This struct is declared in [saml1.h](saml1.h) at line 96, is serialized as XML schema type *`saml1:SubjectStatementAbstractType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__SubjectStatementAbstractType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectStatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectStatementAbstractType; }
        /** Constructor with member initializations */
        saml1__SubjectStatementAbstractType() : saml1__Subject() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__SubjectType *saml1__Subject` is a required element *`<saml1:Subject>`* of XML schema type *`saml1:SubjectType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectType"> saml1__SubjectType </a></code>

The following operations on `struct saml1__SubjectStatementAbstractType` are available:

- `struct saml1__SubjectStatementAbstractType *soap_new_saml1__SubjectStatementAbstractType(struct soap*)` managed allocation with default initialization
- `struct saml1__SubjectStatementAbstractType *soap_new_saml1__SubjectStatementAbstractType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__SubjectStatementAbstractType[n]`
- `struct saml1__SubjectStatementAbstractType *soap_new_req_saml1__SubjectStatementAbstractType(struct soap*, struct saml1__SubjectType *saml1__Subject)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__SubjectStatementAbstractType *soap_new_set_saml1__SubjectStatementAbstractType(struct soap*, struct saml1__SubjectType *saml1__Subject)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__SubjectStatementAbstractType(struct soap*, struct saml1__SubjectStatementAbstractType*)` (re)set to default initialization values
- `int soap_write_saml1__SubjectStatementAbstractType(struct soap*, const struct saml1__SubjectStatementAbstractType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__SubjectStatementAbstractType(struct soap*, struct saml1__SubjectStatementAbstractType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__SubjectStatementAbstractType(struct soap*, const char *URL, const struct saml1__SubjectStatementAbstractType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__SubjectStatementAbstractType(struct soap*, const char *URL, const struct saml1__SubjectStatementAbstractType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__SubjectStatementAbstractType(struct soap*, const char *URL, const struct saml1__SubjectStatementAbstractType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__SubjectStatementAbstractType(struct soap*, struct saml1__SubjectStatementAbstractType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__SubjectStatementAbstractType(struct soap*, const char *URL, struct saml1__SubjectStatementAbstractType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__NameIdentifierType"></a>

### `struct saml1__NameIdentifierType`

This struct is declared in [saml1.h](saml1.h) at line 102, is a simple content wrapper *`saml1:NameIdentifierType`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__NameIdentifierType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
      public:
        /** Return unique type id SOAP_TYPE_saml1__NameIdentifierType */
        long soap_type() const { return SOAP_TYPE_saml1__NameIdentifierType; }
        /** Constructor with member initializations */
        saml1__NameIdentifierType() : __item(), NameQualifier(), Format() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`saml1:NameIdentifierType`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *NameQualifier` is an optional attribute *`NameQualifier`* of XML schema type *`xsd:string`*
- `char *Format` is an optional attribute *`Format`* of XML schema type *`xsd:string`*

The following operations on `struct saml1__NameIdentifierType` are available:

- `struct saml1__NameIdentifierType *soap_new_saml1__NameIdentifierType(struct soap*)` managed allocation with default initialization
- `struct saml1__NameIdentifierType *soap_new_saml1__NameIdentifierType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__NameIdentifierType[n]`
- `struct saml1__NameIdentifierType *soap_new_req_saml1__NameIdentifierType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__NameIdentifierType *soap_new_set_saml1__NameIdentifierType(struct soap*, char *__item, char *NameQualifier, char *Format)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__NameIdentifierType(struct soap*, struct saml1__NameIdentifierType*)` (re)set to default initialization values
- `int soap_write_saml1__NameIdentifierType(struct soap*, const struct saml1__NameIdentifierType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__NameIdentifierType(struct soap*, struct saml1__NameIdentifierType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__NameIdentifierType(struct soap*, const char *URL, const struct saml1__NameIdentifierType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__NameIdentifierType(struct soap*, const char *URL, const struct saml1__NameIdentifierType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__NameIdentifierType(struct soap*, const char *URL, const struct saml1__NameIdentifierType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__NameIdentifierType(struct soap*, struct saml1__NameIdentifierType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__NameIdentifierType(struct soap*, const char *URL, struct saml1__NameIdentifierType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__ActionType"></a>

### `struct saml1__ActionType`

This struct is declared in [saml1.h](saml1.h) at line 120, is a simple content wrapper *`saml1:ActionType`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ActionType */
        long soap_type() const { return SOAP_TYPE_saml1__ActionType; }
        /** Constructor with member initializations */
        saml1__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`saml1:ActionType`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Namespace` is an optional attribute *`Namespace`* of XML schema type *`xsd:string`*

The following operations on `struct saml1__ActionType` are available:

- `struct saml1__ActionType *soap_new_saml1__ActionType(struct soap*)` managed allocation with default initialization
- `struct saml1__ActionType *soap_new_saml1__ActionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__ActionType[n]`
- `struct saml1__ActionType *soap_new_req_saml1__ActionType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__ActionType *soap_new_set_saml1__ActionType(struct soap*, char *__item, char *Namespace)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__ActionType(struct soap*, struct saml1__ActionType*)` (re)set to default initialization values
- `int soap_write_saml1__ActionType(struct soap*, const struct saml1__ActionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__ActionType(struct soap*, struct saml1__ActionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__ActionType(struct soap*, const char *URL, const struct saml1__ActionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__ActionType(struct soap*, const char *URL, const struct saml1__ActionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__ActionType(struct soap*, const char *URL, const struct saml1__ActionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__ActionType(struct soap*, struct saml1__ActionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__ActionType(struct soap*, const char *URL, struct saml1__ActionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AttributeType"></a>

### `struct saml1__AttributeType`

This struct is declared in [saml1.h](saml1.h) at line 132, is serialized as XML schema type *`saml1:AttributeType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AttributeType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
        /** Sequence of at least 1 elements 'saml1:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml1__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml1__AttributeValue;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeType; }
        /** Constructor with member initializations */
        saml1__AttributeType() : AttributeName(), AttributeNamespace(), __sizeAttributeValue(), saml1__AttributeValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *AttributeName` is a required attribute *`AttributeName`* of XML schema type *`xsd:string`*
- `char *AttributeNamespace` is a required attribute *`AttributeNamespace`* of XML schema type *`xsd:string`*
- `int __sizeAttributeValue` is a sequence of at least 1 elements *`<saml1:AttributeValue>`* of XML schema type *`xsd:anyType`* stored in dynamic array `saml1__AttributeValue` of length `__sizeAttributeValue` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml1__AttributeType` are available:

- `struct saml1__AttributeType *soap_new_saml1__AttributeType(struct soap*)` managed allocation with default initialization
- `struct saml1__AttributeType *soap_new_saml1__AttributeType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AttributeType[n]`
- `struct saml1__AttributeType *soap_new_req_saml1__AttributeType(struct soap*, char *AttributeName, char *AttributeNamespace, int __sizeAttributeValue, char **saml1__AttributeValue)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AttributeType *soap_new_set_saml1__AttributeType(struct soap*, char *AttributeName, char *AttributeNamespace, int __sizeAttributeValue, char **saml1__AttributeValue)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AttributeType(struct soap*, struct saml1__AttributeType*)` (re)set to default initialization values
- `int soap_write_saml1__AttributeType(struct soap*, const struct saml1__AttributeType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AttributeType(struct soap*, struct saml1__AttributeType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AttributeType(struct soap*, const char *URL, const struct saml1__AttributeType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AttributeType(struct soap*, const char *URL, const struct saml1__AttributeType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AttributeType(struct soap*, const char *URL, const struct saml1__AttributeType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AttributeType(struct soap*, struct saml1__AttributeType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AttributeType(struct soap*, const char *URL, struct saml1__AttributeType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AuthenticationStatementType"></a>

### `struct saml1__AuthenticationStatementType`

This struct is declared in [saml1.h](saml1.h) at line 108, is serialized as XML schema type *`saml1:AuthenticationStatementType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AuthenticationStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Optional element 'saml1:SubjectLocality' of XML schema type 'saml1:SubjectLocalityType' */
        struct saml1__SubjectLocalityType *saml1__SubjectLocality;
        /** Sequence of elements 'saml1:AuthorityBinding' of XML schema type 'saml1:AuthorityBindingType' stored in dynamic array saml1__AuthorityBinding of length __sizeAuthorityBinding */
        int __sizeAuthorityBinding;
        struct saml1__AuthorityBindingType *saml1__AuthorityBinding;
        /** Required attribute 'AuthenticationMethod' of XML schema type 'xsd:string' */
        char *AuthenticationMethod;
        /** Required attribute 'AuthenticationInstant' of XML schema type 'xsd:dateTime' */
        struct timeval AuthenticationInstant;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthenticationStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthenticationStatementType; }
        /** Constructor with member initializations */
        saml1__AuthenticationStatementType() : saml1__Subject(), saml1__SubjectLocality(), __sizeAuthorityBinding(), saml1__AuthorityBinding(), AuthenticationMethod(), AuthenticationInstant() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__SubjectType *saml1__Subject` is a required element *`<saml1:Subject>`* of XML schema type *`saml1:SubjectType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectType"> saml1__SubjectType </a></code>
- `struct saml1__SubjectLocalityType *saml1__SubjectLocality` is an optional element *`<saml1:SubjectLocality>`* of XML schema type *`saml1:SubjectLocalityType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectLocalityType"> saml1__SubjectLocalityType </a></code>
- `int __sizeAuthorityBinding` is a sequence of elements *`<saml1:AuthorityBinding>`* of XML schema type *`saml1:AuthorityBindingType`* stored in dynamic array `saml1__AuthorityBinding` of length `__sizeAuthorityBinding` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *AuthenticationMethod` is a required attribute *`AuthenticationMethod`* of XML schema type *`xsd:string`*
- `struct timeval AuthenticationInstant` is a required attribute *`AuthenticationInstant`* of XML schema type *`xsd:dateTime`* with a custom serializer `xsd__dateTime`, where the type of this member is <code><a href="#timeval"> timeval </a></code>

The following operations on `struct saml1__AuthenticationStatementType` are available:

- `struct saml1__AuthenticationStatementType *soap_new_saml1__AuthenticationStatementType(struct soap*)` managed allocation with default initialization
- `struct saml1__AuthenticationStatementType *soap_new_saml1__AuthenticationStatementType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AuthenticationStatementType[n]`
- `struct saml1__AuthenticationStatementType *soap_new_req_saml1__AuthenticationStatementType(struct soap*, struct saml1__SubjectType *saml1__Subject, int __sizeAuthorityBinding, struct saml1__AuthorityBindingType *saml1__AuthorityBinding, char *AuthenticationMethod, const struct timeval& AuthenticationInstant)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AuthenticationStatementType *soap_new_set_saml1__AuthenticationStatementType(struct soap*, struct saml1__SubjectType *saml1__Subject, struct saml1__SubjectLocalityType *saml1__SubjectLocality, int __sizeAuthorityBinding, struct saml1__AuthorityBindingType *saml1__AuthorityBinding, char *AuthenticationMethod, const struct timeval& AuthenticationInstant)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AuthenticationStatementType(struct soap*, struct saml1__AuthenticationStatementType*)` (re)set to default initialization values
- `int soap_write_saml1__AuthenticationStatementType(struct soap*, const struct saml1__AuthenticationStatementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AuthenticationStatementType(struct soap*, struct saml1__AuthenticationStatementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AuthenticationStatementType(struct soap*, const char *URL, const struct saml1__AuthenticationStatementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AuthenticationStatementType(struct soap*, const char *URL, const struct saml1__AuthenticationStatementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AuthenticationStatementType(struct soap*, const char *URL, const struct saml1__AuthenticationStatementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AuthenticationStatementType(struct soap*, struct saml1__AuthenticationStatementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AuthenticationStatementType(struct soap*, const char *URL, struct saml1__AuthenticationStatementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AuthorizationDecisionStatementType"></a>

### `struct saml1__AuthorizationDecisionStatementType`

This struct is declared in [saml1.h](saml1.h) at line 117, is serialized as XML schema type *`saml1:AuthorizationDecisionStatementType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AuthorizationDecisionStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Action' of XML schema type 'saml1:ActionType' stored in dynamic array saml1__Action of length __sizeAction */
        int __sizeAction;
        struct saml1__ActionType *saml1__Action;
        /** Optional element 'saml1:Evidence' of XML schema type 'saml1:EvidenceType' */
        struct saml1__EvidenceType *saml1__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml1:DecisionType' */
        enum saml1__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorizationDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorizationDecisionStatementType; }
        /** Constructor with member initializations */
        saml1__AuthorizationDecisionStatementType() : saml1__Subject(), __sizeAction(), saml1__Action(), saml1__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__SubjectType *saml1__Subject` is a required element *`<saml1:Subject>`* of XML schema type *`saml1:SubjectType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectType"> saml1__SubjectType </a></code>
- `int __sizeAction` is a sequence of at least 1 elements *`<saml1:Action>`* of XML schema type *`saml1:ActionType`* stored in dynamic array `saml1__Action` of length `__sizeAction` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct saml1__EvidenceType *saml1__Evidence` is an optional element *`<saml1:Evidence>`* of XML schema type *`saml1:EvidenceType`*, where the type of this member is a pointer to <code><a href="#saml1__EvidenceType"> saml1__EvidenceType </a></code>
- `char *Resource` is a required attribute *`Resource`* of XML schema type *`xsd:string`*
- `enum saml1__DecisionType Decision` is a required attribute *`Decision`* of XML schema type *`saml1:DecisionType`*, where the type of this member is <code><a href="#saml1__DecisionType"> saml1__DecisionType </a></code>

The following operations on `struct saml1__AuthorizationDecisionStatementType` are available:

- `struct saml1__AuthorizationDecisionStatementType *soap_new_saml1__AuthorizationDecisionStatementType(struct soap*)` managed allocation with default initialization
- `struct saml1__AuthorizationDecisionStatementType *soap_new_saml1__AuthorizationDecisionStatementType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AuthorizationDecisionStatementType[n]`
- `struct saml1__AuthorizationDecisionStatementType *soap_new_req_saml1__AuthorizationDecisionStatementType(struct soap*, struct saml1__SubjectType *saml1__Subject, int __sizeAction, struct saml1__ActionType *saml1__Action, char *Resource, enum saml1__DecisionType Decision)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AuthorizationDecisionStatementType *soap_new_set_saml1__AuthorizationDecisionStatementType(struct soap*, struct saml1__SubjectType *saml1__Subject, int __sizeAction, struct saml1__ActionType *saml1__Action, struct saml1__EvidenceType *saml1__Evidence, char *Resource, enum saml1__DecisionType Decision)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AuthorizationDecisionStatementType(struct soap*, struct saml1__AuthorizationDecisionStatementType*)` (re)set to default initialization values
- `int soap_write_saml1__AuthorizationDecisionStatementType(struct soap*, const struct saml1__AuthorizationDecisionStatementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AuthorizationDecisionStatementType(struct soap*, struct saml1__AuthorizationDecisionStatementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AuthorizationDecisionStatementType(struct soap*, const char *URL, const struct saml1__AuthorizationDecisionStatementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AuthorizationDecisionStatementType(struct soap*, const char *URL, const struct saml1__AuthorizationDecisionStatementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AuthorizationDecisionStatementType(struct soap*, const char *URL, const struct saml1__AuthorizationDecisionStatementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AuthorizationDecisionStatementType(struct soap*, struct saml1__AuthorizationDecisionStatementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AuthorizationDecisionStatementType(struct soap*, const char *URL, struct saml1__AuthorizationDecisionStatementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml1__AttributeStatementType"></a>

### `struct saml1__AttributeStatementType`

This struct is declared in [saml1.h](saml1.h) at line 126, is serialized as XML schema type *`saml1:AttributeStatementType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml1__AttributeStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Attribute' of XML schema type 'saml1:AttributeType' stored in dynamic array saml1__Attribute of length __sizeAttribute */
        int __sizeAttribute;
        struct saml1__AttributeType *saml1__Attribute;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeStatementType; }
        /** Constructor with member initializations */
        saml1__AttributeStatementType() : saml1__Subject(), __sizeAttribute(), saml1__Attribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml1__SubjectType *saml1__Subject` is a required element *`<saml1:Subject>`* of XML schema type *`saml1:SubjectType`*, where the type of this member is a pointer to <code><a href="#saml1__SubjectType"> saml1__SubjectType </a></code>
- `int __sizeAttribute` is a sequence of at least 1 elements *`<saml1:Attribute>`* of XML schema type *`saml1:AttributeType`* stored in dynamic array `saml1__Attribute` of length `__sizeAttribute` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml1__AttributeStatementType` are available:

- `struct saml1__AttributeStatementType *soap_new_saml1__AttributeStatementType(struct soap*)` managed allocation with default initialization
- `struct saml1__AttributeStatementType *soap_new_saml1__AttributeStatementType(struct soap*, int n)` managed allocation with default initialization of array `struct saml1__AttributeStatementType[n]`
- `struct saml1__AttributeStatementType *soap_new_req_saml1__AttributeStatementType(struct soap*, struct saml1__SubjectType *saml1__Subject, int __sizeAttribute, struct saml1__AttributeType *saml1__Attribute)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml1__AttributeStatementType *soap_new_set_saml1__AttributeStatementType(struct soap*, struct saml1__SubjectType *saml1__Subject, int __sizeAttribute, struct saml1__AttributeType *saml1__Attribute)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml1__AttributeStatementType(struct soap*, struct saml1__AttributeStatementType*)` (re)set to default initialization values
- `int soap_write_saml1__AttributeStatementType(struct soap*, const struct saml1__AttributeStatementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml1__AttributeStatementType(struct soap*, struct saml1__AttributeStatementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml1__AttributeStatementType(struct soap*, const char *URL, const struct saml1__AttributeStatementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml1__AttributeStatementType(struct soap*, const char *URL, const struct saml1__AttributeStatementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml1__AttributeStatementType(struct soap*, const char *URL, const struct saml1__AttributeStatementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml1__AttributeStatementType(struct soap*, struct saml1__AttributeStatementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml1__AttributeStatementType(struct soap*, const char *URL, struct saml1__AttributeStatementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__BaseIDAbstractType"></a>

### `struct saml2__BaseIDAbstractType`

This struct is declared in [saml2.h](saml2.h) at line 75, is serialized as XML schema type *`saml2:BaseIDAbstractType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__BaseIDAbstractType {
      public:
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__BaseIDAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__BaseIDAbstractType; }
        /** Constructor with member initializations */
        saml2__BaseIDAbstractType() : NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *NameQualifier` is an optional attribute *`NameQualifier`* of XML schema type *`xsd:string`*
- `char *SPNameQualifier` is an optional attribute *`SPNameQualifier`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__BaseIDAbstractType` are available:

- `struct saml2__BaseIDAbstractType *soap_new_saml2__BaseIDAbstractType(struct soap*)` managed allocation with default initialization
- `struct saml2__BaseIDAbstractType *soap_new_saml2__BaseIDAbstractType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__BaseIDAbstractType[n]`
- `struct saml2__BaseIDAbstractType *soap_new_req_saml2__BaseIDAbstractType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__BaseIDAbstractType *soap_new_set_saml2__BaseIDAbstractType(struct soap*, char *NameQualifier, char *SPNameQualifier)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__BaseIDAbstractType(struct soap*, struct saml2__BaseIDAbstractType*)` (re)set to default initialization values
- `int soap_write_saml2__BaseIDAbstractType(struct soap*, const struct saml2__BaseIDAbstractType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__BaseIDAbstractType(struct soap*, struct saml2__BaseIDAbstractType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__BaseIDAbstractType(struct soap*, const char *URL, const struct saml2__BaseIDAbstractType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__BaseIDAbstractType(struct soap*, const char *URL, const struct saml2__BaseIDAbstractType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__BaseIDAbstractType(struct soap*, const char *URL, const struct saml2__BaseIDAbstractType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__BaseIDAbstractType(struct soap*, struct saml2__BaseIDAbstractType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__BaseIDAbstractType(struct soap*, const char *URL, struct saml2__BaseIDAbstractType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__EncryptedElementType"></a>

### `struct saml2__EncryptedElementType`

This struct is declared in [saml2.h](saml2.h) at line 81, is serialized as XML schema type *`saml2:EncryptedElementType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__EncryptedElementType {
      public:
        /** Required element 'xenc:EncryptedData' of XML schema type 'xenc:EncryptedDataType' */
        struct xenc__EncryptedDataType xenc__EncryptedData;
        /** Sequence of elements 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' stored in dynamic array xenc__EncryptedKey of length __sizexenc__EncryptedKey */
        int __sizexenc__EncryptedKey;
        struct xenc__EncryptedKeyType **xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EncryptedElementType */
        long soap_type() const { return SOAP_TYPE_saml2__EncryptedElementType; }
        /** Constructor with member initializations */
        saml2__EncryptedElementType() : xenc__EncryptedData(), __sizexenc__EncryptedKey(), xenc__EncryptedKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct xenc__EncryptedDataType xenc__EncryptedData` is a required element *`<xenc:EncryptedData>`* of XML schema type *`xenc:EncryptedDataType`*, where the type of this member is <code><a href="#xenc__EncryptedDataType"> xenc__EncryptedDataType </a></code>
- `int __sizexenc__EncryptedKey` is a sequence of elements *`<xenc:EncryptedKey>`* of XML schema type *`xenc:EncryptedKeyType`* stored in dynamic array `xenc__EncryptedKey` of length `__sizexenc__EncryptedKey` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__EncryptedElementType` are available:

- `struct saml2__EncryptedElementType *soap_new_saml2__EncryptedElementType(struct soap*)` managed allocation with default initialization
- `struct saml2__EncryptedElementType *soap_new_saml2__EncryptedElementType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__EncryptedElementType[n]`
- `struct saml2__EncryptedElementType *soap_new_req_saml2__EncryptedElementType(struct soap*, const struct xenc__EncryptedDataType& xenc__EncryptedData, int __sizexenc__EncryptedKey, struct xenc__EncryptedKeyType **xenc__EncryptedKey)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__EncryptedElementType *soap_new_set_saml2__EncryptedElementType(struct soap*, const struct xenc__EncryptedDataType& xenc__EncryptedData, int __sizexenc__EncryptedKey, struct xenc__EncryptedKeyType **xenc__EncryptedKey)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__EncryptedElementType(struct soap*, struct saml2__EncryptedElementType*)` (re)set to default initialization values
- `int soap_write_saml2__EncryptedElementType(struct soap*, const struct saml2__EncryptedElementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__EncryptedElementType(struct soap*, struct saml2__EncryptedElementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__EncryptedElementType(struct soap*, const char *URL, const struct saml2__EncryptedElementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__EncryptedElementType(struct soap*, const char *URL, const struct saml2__EncryptedElementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__EncryptedElementType(struct soap*, const char *URL, const struct saml2__EncryptedElementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__EncryptedElementType(struct soap*, struct saml2__EncryptedElementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__EncryptedElementType(struct soap*, const char *URL, struct saml2__EncryptedElementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml2__union_AssertionType"></a>

### `struct __saml2__union_AssertionType`

This struct is declared in [saml2.h](saml2.h) at line 234, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml2__union_AssertionType {
      public:
        /** Optional element 'saml2:Statement' of XML schema type 'saml2:StatementAbstractType' */
        struct saml2__StatementAbstractType *saml2__Statement;
        /** Optional element 'saml2:AuthnStatement' of XML schema type 'saml2:AuthnStatementType' */
        struct saml2__AuthnStatementType *saml2__AuthnStatement;
        /** Optional element 'saml2:AuthzDecisionStatement' of XML schema type 'saml2:AuthzDecisionStatementType' */
        struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement;
        /** Optional element 'saml2:AttributeStatement' of XML schema type 'saml2:AttributeStatementType' */
        struct saml2__AttributeStatementType *saml2__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AssertionType; }
        /** Constructor with member initializations */
        __saml2__union_AssertionType() : saml2__Statement(), saml2__AuthnStatement(), saml2__AuthzDecisionStatement(), saml2__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml2__StatementAbstractType *saml2__Statement` is an optional element *`<saml2:Statement>`* of XML schema type *`saml2:StatementAbstractType`*, where the type of this member is a pointer to <code><a href="#saml2__StatementAbstractType"> saml2__StatementAbstractType </a></code>
- `struct saml2__AuthnStatementType *saml2__AuthnStatement` is an optional element *`<saml2:AuthnStatement>`* of XML schema type *`saml2:AuthnStatementType`*, where the type of this member is a pointer to <code><a href="#saml2__AuthnStatementType"> saml2__AuthnStatementType </a></code>
- `struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement` is an optional element *`<saml2:AuthzDecisionStatement>`* of XML schema type *`saml2:AuthzDecisionStatementType`*, where the type of this member is a pointer to <code><a href="#saml2__AuthzDecisionStatementType"> saml2__AuthzDecisionStatementType </a></code>
- `struct saml2__AttributeStatementType *saml2__AttributeStatement` is an optional element *`<saml2:AttributeStatement>`* of XML schema type *`saml2:AttributeStatementType`*, where the type of this member is a pointer to <code><a href="#saml2__AttributeStatementType"> saml2__AttributeStatementType </a></code>

The following operations on `struct __saml2__union_AssertionType` are available:

- `struct __saml2__union_AssertionType *soap_new___saml2__union_AssertionType(struct soap*)` managed allocation with default initialization
- `struct __saml2__union_AssertionType *soap_new___saml2__union_AssertionType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml2__union_AssertionType[n]`
- `struct __saml2__union_AssertionType *soap_new_req___saml2__union_AssertionType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml2__union_AssertionType *soap_new_set___saml2__union_AssertionType(struct soap*, struct saml2__StatementAbstractType *saml2__Statement, struct saml2__AuthnStatementType *saml2__AuthnStatement, struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement, struct saml2__AttributeStatementType *saml2__AttributeStatement)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml2__union_AssertionType(struct soap*, struct __saml2__union_AssertionType*)` (re)set to default initialization values
- `int soap_write___saml2__union_AssertionType(struct soap*, const struct __saml2__union_AssertionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml2__union_AssertionType(struct soap*, struct __saml2__union_AssertionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml2__union_AssertionType(struct soap*, const char *URL, const struct __saml2__union_AssertionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml2__union_AssertionType(struct soap*, const char *URL, const struct __saml2__union_AssertionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml2__union_AssertionType(struct soap*, const char *URL, const struct __saml2__union_AssertionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml2__union_AssertionType(struct soap*, struct __saml2__union_AssertionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml2__union_AssertionType(struct soap*, const char *URL, struct __saml2__union_AssertionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AssertionType"></a>

### `struct saml2__AssertionType`

This struct is declared in [saml2.h](saml2.h) at line 84, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is serialized as XML schema type *`saml2:AssertionType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AssertionType {
      public:
        /** Required element 'saml2:Issuer' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__Issuer;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml2:Subject' of XML schema type 'saml2:SubjectType' */
        struct saml2__SubjectType *saml2__Subject;
        /** Optional element 'saml2:Conditions' of XML schema type 'saml2:ConditionsType' */
        struct saml2__ConditionsType *saml2__Conditions;
        /** Optional element 'saml2:Advice' of XML schema type 'saml2:AdviceType' */
        struct saml2__AdviceType *saml2__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml2:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml2__union_AssertionType *__union_AssertionType;
        /** Required attribute 'Version' of XML schema type 'xsd:string' */
        char *Version;
        /** Required attribute 'ID' of XML schema type 'xsd:string' */
        char *ID;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        struct timeval IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml2__AssertionType; }
        /** Constructor with member initializations */
        saml2__AssertionType() : saml2__Issuer(), ds__Signature(), saml2__Subject(), saml2__Conditions(), saml2__Advice(), __size_AssertionType(), __union_AssertionType(), Version(), ID(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml2__NameIDType *saml2__Issuer` is a required element *`<saml2:Issuer>`* of XML schema type *`saml2:NameIDType`*, where the type of this member is a pointer to <code><a href="#saml2__NameIDType"> saml2__NameIDType </a></code>
- `struct ds__SignatureType *ds__Signature` is an optional element *`<ds:Signature>`* of XML schema type *`ds:Signature`*, where the type of this member is a pointer to <code><a href="#ds__SignatureType"> ds__SignatureType </a></code>
- `struct saml2__SubjectType *saml2__Subject` is an optional element *`<saml2:Subject>`* of XML schema type *`saml2:SubjectType`*, where the type of this member is a pointer to <code><a href="#saml2__SubjectType"> saml2__SubjectType </a></code>
- `struct saml2__ConditionsType *saml2__Conditions` is an optional element *`<saml2:Conditions>`* of XML schema type *`saml2:ConditionsType`*, where the type of this member is a pointer to <code><a href="#saml2__ConditionsType"> saml2__ConditionsType </a></code>
- `struct saml2__AdviceType *saml2__Advice` is an optional element *`<saml2:Advice>`* of XML schema type *`saml2:AdviceType`*, where the type of this member is a pointer to <code><a href="#saml2__AdviceType"> saml2__AdviceType </a></code>
- `int __size_AssertionType` is a sequence of elements *`<-union-AssertionType>`* of XML schema type *`-saml2:union-AssertionType`* stored in dynamic array `__union_AssertionType` of length `__size_AssertionType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Version` is a required attribute *`Version`* of XML schema type *`xsd:string`*
- `char *ID` is a required attribute *`ID`* of XML schema type *`xsd:string`*
- `struct timeval IssueInstant` is a required attribute *`IssueInstant`* of XML schema type *`xsd:dateTime`* with a custom serializer `xsd__dateTime`, where the type of this member is <code><a href="#timeval"> timeval </a></code>
- `char *wsu__Id` is an optional attribute *`wsu:Id`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__AssertionType` are available:

- `struct saml2__AssertionType *soap_new_saml2__AssertionType(struct soap*)` managed allocation with default initialization
- `struct saml2__AssertionType *soap_new_saml2__AssertionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AssertionType[n]`
- `struct saml2__AssertionType *soap_new_req_saml2__AssertionType(struct soap*, struct saml2__NameIDType *saml2__Issuer, int __size_AssertionType, struct __saml2__union_AssertionType *__union_AssertionType, char *Version, char *ID, const struct timeval& IssueInstant)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AssertionType *soap_new_set_saml2__AssertionType(struct soap*, struct saml2__NameIDType *saml2__Issuer, struct ds__SignatureType *ds__Signature, struct saml2__SubjectType *saml2__Subject, struct saml2__ConditionsType *saml2__Conditions, struct saml2__AdviceType *saml2__Advice, int __size_AssertionType, struct __saml2__union_AssertionType *__union_AssertionType, char *Version, char *ID, const struct timeval& IssueInstant, char *wsu__Id)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AssertionType(struct soap*, struct saml2__AssertionType*)` (re)set to default initialization values
- `int soap_write_saml2__AssertionType(struct soap*, const struct saml2__AssertionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AssertionType(struct soap*, struct saml2__AssertionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AssertionType(struct soap*, const char *URL, const struct saml2__AssertionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AssertionType(struct soap*, const char *URL, const struct saml2__AssertionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AssertionType(struct soap*, const char *URL, const struct saml2__AssertionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AssertionType(struct soap*, struct saml2__AssertionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AssertionType(struct soap*, const char *URL, struct saml2__AssertionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__SubjectType"></a>

### `struct saml2__SubjectType`

This struct is declared in [saml2.h](saml2.h) at line 87, is serialized as XML schema type *`saml2:SubjectType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__SubjectType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XML schema type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation of length __sizeSubjectConfirmation */
        int __sizeSubjectConfirmation;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XML schema type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation_ of length __sizeSubjectConfirmation_ */
        int __sizeSubjectConfirmation_;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation_;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectType; }
        /** Constructor with member initializations */
        saml2__SubjectType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), __sizeSubjectConfirmation(), saml2__SubjectConfirmation(), __sizeSubjectConfirmation_(), saml2__SubjectConfirmation_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml2__BaseIDAbstractType *saml2__BaseID` is an optional element *`<saml2:BaseID>`* of XML schema type *`saml2:BaseIDAbstractType`*, where the type of this member is a pointer to <code><a href="#saml2__BaseIDAbstractType"> saml2__BaseIDAbstractType </a></code>
- `struct saml2__NameIDType *saml2__NameID` is an optional element *`<saml2:NameID>`* of XML schema type *`saml2:NameIDType`*, where the type of this member is a pointer to <code><a href="#saml2__NameIDType"> saml2__NameIDType </a></code>
- `struct saml2__EncryptedElementType *saml2__EncryptedID` is an optional element *`<saml2:EncryptedID>`* of XML schema type *`saml2:EncryptedElementType`*, where the type of this member is a pointer to <code><a href="#saml2__EncryptedElementType"> saml2__EncryptedElementType </a></code>
- `int __sizeSubjectConfirmation` is a sequence of elements *`<saml2:SubjectConfirmation>`* of XML schema type *`saml2:SubjectConfirmationType`* stored in dynamic array `saml2__SubjectConfirmation` of length `__sizeSubjectConfirmation` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `int __sizeSubjectConfirmation_` is a sequence of elements *`<saml2:SubjectConfirmation>`* of XML schema type *`saml2:SubjectConfirmationType`* stored in dynamic array `saml2__SubjectConfirmation_` of length `__sizeSubjectConfirmation_` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__SubjectType` are available:

- `struct saml2__SubjectType *soap_new_saml2__SubjectType(struct soap*)` managed allocation with default initialization
- `struct saml2__SubjectType *soap_new_saml2__SubjectType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__SubjectType[n]`
- `struct saml2__SubjectType *soap_new_req_saml2__SubjectType(struct soap*, int __sizeSubjectConfirmation, struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation, int __sizeSubjectConfirmation_, struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation_)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__SubjectType *soap_new_set_saml2__SubjectType(struct soap*, struct saml2__BaseIDAbstractType *saml2__BaseID, struct saml2__NameIDType *saml2__NameID, struct saml2__EncryptedElementType *saml2__EncryptedID, int __sizeSubjectConfirmation, struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation, int __sizeSubjectConfirmation_, struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation_)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__SubjectType(struct soap*, struct saml2__SubjectType*)` (re)set to default initialization values
- `int soap_write_saml2__SubjectType(struct soap*, const struct saml2__SubjectType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__SubjectType(struct soap*, struct saml2__SubjectType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__SubjectType(struct soap*, const char *URL, const struct saml2__SubjectType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__SubjectType(struct soap*, const char *URL, const struct saml2__SubjectType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__SubjectType(struct soap*, const char *URL, const struct saml2__SubjectType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__SubjectType(struct soap*, struct saml2__SubjectType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__SubjectType(struct soap*, const char *URL, struct saml2__SubjectType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__SubjectConfirmationType"></a>

### `struct saml2__SubjectConfirmationType`

This struct is declared in [saml2.h](saml2.h) at line 90, is serialized as XML schema type *`saml2:SubjectConfirmationType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__SubjectConfirmationType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Optional element 'saml2:SubjectConfirmationData' of XML schema type 'saml2:SubjectConfirmationDataType' */
        struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData;
        /** Required attribute 'Method' of XML schema type 'xsd:string' */
        char *Method;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), saml2__SubjectConfirmationData(), Method() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml2__BaseIDAbstractType *saml2__BaseID` is an optional element *`<saml2:BaseID>`* of XML schema type *`saml2:BaseIDAbstractType`*, where the type of this member is a pointer to <code><a href="#saml2__BaseIDAbstractType"> saml2__BaseIDAbstractType </a></code>
- `struct saml2__NameIDType *saml2__NameID` is an optional element *`<saml2:NameID>`* of XML schema type *`saml2:NameIDType`*, where the type of this member is a pointer to <code><a href="#saml2__NameIDType"> saml2__NameIDType </a></code>
- `struct saml2__EncryptedElementType *saml2__EncryptedID` is an optional element *`<saml2:EncryptedID>`* of XML schema type *`saml2:EncryptedElementType`*, where the type of this member is a pointer to <code><a href="#saml2__EncryptedElementType"> saml2__EncryptedElementType </a></code>
- `struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData` is an optional element *`<saml2:SubjectConfirmationData>`* of XML schema type *`saml2:SubjectConfirmationDataType`*, where the type of this member is a pointer to <code><a href="#saml2__SubjectConfirmationDataType"> saml2__SubjectConfirmationDataType </a></code>
- `char *Method` is a required attribute *`Method`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__SubjectConfirmationType` are available:

- `struct saml2__SubjectConfirmationType *soap_new_saml2__SubjectConfirmationType(struct soap*)` managed allocation with default initialization
- `struct saml2__SubjectConfirmationType *soap_new_saml2__SubjectConfirmationType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__SubjectConfirmationType[n]`
- `struct saml2__SubjectConfirmationType *soap_new_req_saml2__SubjectConfirmationType(struct soap*, char *Method)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__SubjectConfirmationType *soap_new_set_saml2__SubjectConfirmationType(struct soap*, struct saml2__BaseIDAbstractType *saml2__BaseID, struct saml2__NameIDType *saml2__NameID, struct saml2__EncryptedElementType *saml2__EncryptedID, struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData, char *Method)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__SubjectConfirmationType(struct soap*, struct saml2__SubjectConfirmationType*)` (re)set to default initialization values
- `int soap_write_saml2__SubjectConfirmationType(struct soap*, const struct saml2__SubjectConfirmationType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__SubjectConfirmationType(struct soap*, struct saml2__SubjectConfirmationType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__SubjectConfirmationType(struct soap*, const char *URL, const struct saml2__SubjectConfirmationType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__SubjectConfirmationType(struct soap*, const char *URL, const struct saml2__SubjectConfirmationType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__SubjectConfirmationType(struct soap*, const char *URL, const struct saml2__SubjectConfirmationType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__SubjectConfirmationType(struct soap*, struct saml2__SubjectConfirmationType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__SubjectConfirmationType(struct soap*, const char *URL, struct saml2__SubjectConfirmationType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml2__union_ConditionsType"></a>

### `struct __saml2__union_ConditionsType`

This struct is declared in [saml2.h](saml2.h) at line 327, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml2__union_ConditionsType {
      public:
        /** Optional element 'saml2:Condition' of XML schema type 'saml2:ConditionAbstractType' */
        struct saml2__ConditionAbstractType *saml2__Condition;
        /** Optional element 'saml2:AudienceRestriction' of XML schema type 'saml2:AudienceRestrictionType' */
        struct saml2__AudienceRestrictionType *saml2__AudienceRestriction;
        /** Optional element 'saml2:OneTimeUse' of XML schema type 'saml2:OneTimeUseType' */
        struct saml2__OneTimeUseType *saml2__OneTimeUse;
        /** Optional element 'saml2:ProxyRestriction' of XML schema type 'saml2:ProxyRestrictionType' */
        struct saml2__ProxyRestrictionType *saml2__ProxyRestriction;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml2__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml2__union_ConditionsType() : saml2__Condition(), saml2__AudienceRestriction(), saml2__OneTimeUse(), saml2__ProxyRestriction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml2__ConditionAbstractType *saml2__Condition` is an optional element *`<saml2:Condition>`* of XML schema type *`saml2:ConditionAbstractType`*, where the type of this member is a pointer to <code><a href="#saml2__ConditionAbstractType"> saml2__ConditionAbstractType </a></code>
- `struct saml2__AudienceRestrictionType *saml2__AudienceRestriction` is an optional element *`<saml2:AudienceRestriction>`* of XML schema type *`saml2:AudienceRestrictionType`*, where the type of this member is a pointer to <code><a href="#saml2__AudienceRestrictionType"> saml2__AudienceRestrictionType </a></code>
- `struct saml2__OneTimeUseType *saml2__OneTimeUse` is an optional element *`<saml2:OneTimeUse>`* of XML schema type *`saml2:OneTimeUseType`*, where the type of this member is a pointer to <code><a href="#saml2__OneTimeUseType"> saml2__OneTimeUseType </a></code>
- `struct saml2__ProxyRestrictionType *saml2__ProxyRestriction` is an optional element *`<saml2:ProxyRestriction>`* of XML schema type *`saml2:ProxyRestrictionType`*, where the type of this member is a pointer to <code><a href="#saml2__ProxyRestrictionType"> saml2__ProxyRestrictionType </a></code>

The following operations on `struct __saml2__union_ConditionsType` are available:

- `struct __saml2__union_ConditionsType *soap_new___saml2__union_ConditionsType(struct soap*)` managed allocation with default initialization
- `struct __saml2__union_ConditionsType *soap_new___saml2__union_ConditionsType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml2__union_ConditionsType[n]`
- `struct __saml2__union_ConditionsType *soap_new_req___saml2__union_ConditionsType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml2__union_ConditionsType *soap_new_set___saml2__union_ConditionsType(struct soap*, struct saml2__ConditionAbstractType *saml2__Condition, struct saml2__AudienceRestrictionType *saml2__AudienceRestriction, struct saml2__OneTimeUseType *saml2__OneTimeUse, struct saml2__ProxyRestrictionType *saml2__ProxyRestriction)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml2__union_ConditionsType(struct soap*, struct __saml2__union_ConditionsType*)` (re)set to default initialization values
- `int soap_write___saml2__union_ConditionsType(struct soap*, const struct __saml2__union_ConditionsType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml2__union_ConditionsType(struct soap*, struct __saml2__union_ConditionsType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml2__union_ConditionsType(struct soap*, const char *URL, const struct __saml2__union_ConditionsType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml2__union_ConditionsType(struct soap*, const char *URL, const struct __saml2__union_ConditionsType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml2__union_ConditionsType(struct soap*, const char *URL, const struct __saml2__union_ConditionsType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml2__union_ConditionsType(struct soap*, struct __saml2__union_ConditionsType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml2__union_ConditionsType(struct soap*, const char *URL, struct __saml2__union_ConditionsType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__ConditionsType"></a>

### `struct saml2__ConditionsType`

This struct is declared in [saml2.h](saml2.h) at line 99, is serialized as XML schema type *`saml2:ConditionsType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml2:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml2__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionsType; }
        /** Constructor with member initializations */
        saml2__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_ConditionsType` is a sequence of elements *`<-union-ConditionsType>`* of XML schema type *`-saml2:union-ConditionsType`* stored in dynamic array `__union_ConditionsType` of length `__size_ConditionsType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct timeval *NotBefore` is an optional attribute *`NotBefore`* of XML schema type *`xsd:dateTime`*, where the type of this member is a pointer to <code><a href="#timeval"> timeval </a></code>
- `struct timeval *NotOnOrAfter` is an optional attribute *`NotOnOrAfter`* of XML schema type *`xsd:dateTime`*, where the type of this member is a pointer to <code><a href="#timeval"> timeval </a></code>

The following operations on `struct saml2__ConditionsType` are available:

- `struct saml2__ConditionsType *soap_new_saml2__ConditionsType(struct soap*)` managed allocation with default initialization
- `struct saml2__ConditionsType *soap_new_saml2__ConditionsType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__ConditionsType[n]`
- `struct saml2__ConditionsType *soap_new_req_saml2__ConditionsType(struct soap*, int __size_ConditionsType, struct __saml2__union_ConditionsType *__union_ConditionsType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__ConditionsType *soap_new_set_saml2__ConditionsType(struct soap*, int __size_ConditionsType, struct __saml2__union_ConditionsType *__union_ConditionsType, struct timeval *NotBefore, struct timeval *NotOnOrAfter)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__ConditionsType(struct soap*, struct saml2__ConditionsType*)` (re)set to default initialization values
- `int soap_write_saml2__ConditionsType(struct soap*, const struct saml2__ConditionsType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__ConditionsType(struct soap*, struct saml2__ConditionsType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__ConditionsType(struct soap*, const char *URL, const struct saml2__ConditionsType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__ConditionsType(struct soap*, const char *URL, const struct saml2__ConditionsType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__ConditionsType(struct soap*, const char *URL, const struct saml2__ConditionsType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__ConditionsType(struct soap*, struct saml2__ConditionsType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__ConditionsType(struct soap*, const char *URL, struct saml2__ConditionsType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__ConditionAbstractType"></a>

### `struct saml2__ConditionAbstractType`

This struct is declared in [saml2.h](saml2.h) at line 102, is serialized as XML schema type *`saml2:ConditionAbstractType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml2__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
    };

where:


The following operations on `struct saml2__ConditionAbstractType` are available:

- `struct saml2__ConditionAbstractType *soap_new_saml2__ConditionAbstractType(struct soap*)` managed allocation with default initialization
- `struct saml2__ConditionAbstractType *soap_new_saml2__ConditionAbstractType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__ConditionAbstractType[n]`
- `struct saml2__ConditionAbstractType *soap_new_req_saml2__ConditionAbstractType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__ConditionAbstractType *soap_new_set_saml2__ConditionAbstractType(struct soap*)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__ConditionAbstractType(struct soap*, struct saml2__ConditionAbstractType*)` (re)set to default initialization values
- `int soap_write_saml2__ConditionAbstractType(struct soap*, const struct saml2__ConditionAbstractType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__ConditionAbstractType(struct soap*, struct saml2__ConditionAbstractType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__ConditionAbstractType(struct soap*, const char *URL, const struct saml2__ConditionAbstractType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__ConditionAbstractType(struct soap*, const char *URL, const struct saml2__ConditionAbstractType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__ConditionAbstractType(struct soap*, const char *URL, const struct saml2__ConditionAbstractType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__ConditionAbstractType(struct soap*, struct saml2__ConditionAbstractType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__ConditionAbstractType(struct soap*, const char *URL, struct saml2__ConditionAbstractType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml2__union_AdviceType"></a>

### `struct __saml2__union_AdviceType`

This struct is declared in [saml2.h](saml2.h) at line 376, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml2__union_AdviceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AdviceType; }
        /** Constructor with member initializations */
        __saml2__union_AdviceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *saml2__AssertionIDRef` is an optional element *`<saml2:AssertionIDRef>`* of XML schema type *`xsd:string`*
- `char *saml2__AssertionURIRef` is an optional element *`<saml2:AssertionURIRef>`* of XML schema type *`xsd:string`*
- `struct saml2__AssertionType *saml2__Assertion` is an optional element *`<saml2:Assertion>`* of XML schema type *`saml2:AssertionType`*, where the type of this member is a pointer to <code><a href="#saml2__AssertionType"> saml2__AssertionType </a></code>
- `struct saml2__EncryptedElementType *saml2__EncryptedAssertion` is an optional element *`<saml2:EncryptedAssertion>`* of XML schema type *`saml2:EncryptedElementType`*, where the type of this member is a pointer to <code><a href="#saml2__EncryptedElementType"> saml2__EncryptedElementType </a></code>

The following operations on `struct __saml2__union_AdviceType` are available:

- `struct __saml2__union_AdviceType *soap_new___saml2__union_AdviceType(struct soap*)` managed allocation with default initialization
- `struct __saml2__union_AdviceType *soap_new___saml2__union_AdviceType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml2__union_AdviceType[n]`
- `struct __saml2__union_AdviceType *soap_new_req___saml2__union_AdviceType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml2__union_AdviceType *soap_new_set___saml2__union_AdviceType(struct soap*, char *saml2__AssertionIDRef, char *saml2__AssertionURIRef, struct saml2__AssertionType *saml2__Assertion, struct saml2__EncryptedElementType *saml2__EncryptedAssertion)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml2__union_AdviceType(struct soap*, struct __saml2__union_AdviceType*)` (re)set to default initialization values
- `int soap_write___saml2__union_AdviceType(struct soap*, const struct __saml2__union_AdviceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml2__union_AdviceType(struct soap*, struct __saml2__union_AdviceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml2__union_AdviceType(struct soap*, const char *URL, const struct __saml2__union_AdviceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml2__union_AdviceType(struct soap*, const char *URL, const struct __saml2__union_AdviceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml2__union_AdviceType(struct soap*, const char *URL, const struct __saml2__union_AdviceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml2__union_AdviceType(struct soap*, struct __saml2__union_AdviceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml2__union_AdviceType(struct soap*, const char *URL, struct __saml2__union_AdviceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AdviceType"></a>

### `struct saml2__AdviceType`

This struct is declared in [saml2.h](saml2.h) at line 114, is serialized as XML schema type *`saml2:AdviceType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml2:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml2__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml2__AdviceType; }
        /** Constructor with member initializations */
        saml2__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_AdviceType` is a sequence of elements *`<-union-AdviceType>`* of XML schema type *`-saml2:union-AdviceType`* stored in dynamic array `__union_AdviceType` of length `__size_AdviceType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__AdviceType` are available:

- `struct saml2__AdviceType *soap_new_saml2__AdviceType(struct soap*)` managed allocation with default initialization
- `struct saml2__AdviceType *soap_new_saml2__AdviceType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AdviceType[n]`
- `struct saml2__AdviceType *soap_new_req_saml2__AdviceType(struct soap*, int __size_AdviceType, struct __saml2__union_AdviceType *__union_AdviceType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AdviceType *soap_new_set_saml2__AdviceType(struct soap*, int __size_AdviceType, struct __saml2__union_AdviceType *__union_AdviceType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AdviceType(struct soap*, struct saml2__AdviceType*)` (re)set to default initialization values
- `int soap_write_saml2__AdviceType(struct soap*, const struct saml2__AdviceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AdviceType(struct soap*, struct saml2__AdviceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AdviceType(struct soap*, const char *URL, const struct saml2__AdviceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AdviceType(struct soap*, const char *URL, const struct saml2__AdviceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AdviceType(struct soap*, const char *URL, const struct saml2__AdviceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AdviceType(struct soap*, struct saml2__AdviceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AdviceType(struct soap*, const char *URL, struct saml2__AdviceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__StatementAbstractType"></a>

### `struct saml2__StatementAbstractType`

This struct is declared in [saml2.h](saml2.h) at line 117, is serialized as XML schema type *`saml2:StatementAbstractType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__StatementAbstractType; }
        /** Constructor with member initializations */
        saml2__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
    };

where:


The following operations on `struct saml2__StatementAbstractType` are available:

- `struct saml2__StatementAbstractType *soap_new_saml2__StatementAbstractType(struct soap*)` managed allocation with default initialization
- `struct saml2__StatementAbstractType *soap_new_saml2__StatementAbstractType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__StatementAbstractType[n]`
- `struct saml2__StatementAbstractType *soap_new_req_saml2__StatementAbstractType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__StatementAbstractType *soap_new_set_saml2__StatementAbstractType(struct soap*)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__StatementAbstractType(struct soap*, struct saml2__StatementAbstractType*)` (re)set to default initialization values
- `int soap_write_saml2__StatementAbstractType(struct soap*, const struct saml2__StatementAbstractType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__StatementAbstractType(struct soap*, struct saml2__StatementAbstractType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__StatementAbstractType(struct soap*, const char *URL, const struct saml2__StatementAbstractType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__StatementAbstractType(struct soap*, const char *URL, const struct saml2__StatementAbstractType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__StatementAbstractType(struct soap*, const char *URL, const struct saml2__StatementAbstractType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__StatementAbstractType(struct soap*, struct saml2__StatementAbstractType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__StatementAbstractType(struct soap*, const char *URL, struct saml2__StatementAbstractType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__SubjectLocalityType"></a>

### `struct saml2__SubjectLocalityType`

This struct is declared in [saml2.h](saml2.h) at line 123, is serialized as XML schema type *`saml2:SubjectLocalityType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__SubjectLocalityType {
      public:
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional attribute 'DNSName' of XML schema type 'xsd:string' */
        char *DNSName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml2__SubjectLocalityType() : Address(), DNSName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *Address` is an optional attribute *`Address`* of XML schema type *`xsd:string`*
- `char *DNSName` is an optional attribute *`DNSName`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__SubjectLocalityType` are available:

- `struct saml2__SubjectLocalityType *soap_new_saml2__SubjectLocalityType(struct soap*)` managed allocation with default initialization
- `struct saml2__SubjectLocalityType *soap_new_saml2__SubjectLocalityType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__SubjectLocalityType[n]`
- `struct saml2__SubjectLocalityType *soap_new_req_saml2__SubjectLocalityType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__SubjectLocalityType *soap_new_set_saml2__SubjectLocalityType(struct soap*, char *Address, char *DNSName)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__SubjectLocalityType(struct soap*, struct saml2__SubjectLocalityType*)` (re)set to default initialization values
- `int soap_write_saml2__SubjectLocalityType(struct soap*, const struct saml2__SubjectLocalityType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__SubjectLocalityType(struct soap*, struct saml2__SubjectLocalityType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__SubjectLocalityType(struct soap*, const char *URL, const struct saml2__SubjectLocalityType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__SubjectLocalityType(struct soap*, const char *URL, const struct saml2__SubjectLocalityType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__SubjectLocalityType(struct soap*, const char *URL, const struct saml2__SubjectLocalityType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__SubjectLocalityType(struct soap*, struct saml2__SubjectLocalityType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__SubjectLocalityType(struct soap*, const char *URL, struct saml2__SubjectLocalityType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AuthnContextType"></a>

### `struct saml2__AuthnContextType`

This struct is declared in [saml2.h](saml2.h) at line 126, is serialized as XML schema type *`saml2:AuthnContextType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AuthnContextType {
      public:
        /** Optional element 'saml2:AuthnContextClassRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextClassRef;
        /** Optional element 'saml2:AuthnContextDecl' of XML schema type 'xsd:anyType' */
        char *saml2__AuthnContextDecl;
        /** Optional element 'saml2:AuthnContextDeclRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextDeclRef;
        /** Optional element 'saml2:AuthnContextDecl' of XML schema type 'xsd:anyType' */
        char *saml2__AuthnContextDecl_;
        /** Optional element 'saml2:AuthnContextDeclRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextDeclRef_;
        /** Sequence of elements 'saml2:AuthenticatingAuthority' of XML schema type 'xsd:string' stored in dynamic array saml2__AuthenticatingAuthority of length __sizeAuthenticatingAuthority */
        int __sizeAuthenticatingAuthority;
        char **saml2__AuthenticatingAuthority;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnContextType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnContextType; }
        /** Constructor with member initializations */
        saml2__AuthnContextType() : saml2__AuthnContextClassRef(), saml2__AuthnContextDecl(), saml2__AuthnContextDeclRef(), saml2__AuthnContextDecl_(), saml2__AuthnContextDeclRef_(), __sizeAuthenticatingAuthority(), saml2__AuthenticatingAuthority() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *saml2__AuthnContextClassRef` is an optional element *`<saml2:AuthnContextClassRef>`* of XML schema type *`xsd:string`*
- `char *saml2__AuthnContextDecl` is an optional element *`<saml2:AuthnContextDecl>`* of XML schema type *`xsd:anyType`*, where the type of this member is <code><a href="#_XML"> _XML </a></code>
- `char *saml2__AuthnContextDeclRef` is an optional element *`<saml2:AuthnContextDeclRef>`* of XML schema type *`xsd:string`*
- `char *saml2__AuthnContextDecl_` is an optional element *`<saml2:AuthnContextDecl>`* of XML schema type *`xsd:anyType`*, where the type of this member is <code><a href="#_XML"> _XML </a></code>
- `char *saml2__AuthnContextDeclRef_` is an optional element *`<saml2:AuthnContextDeclRef>`* of XML schema type *`xsd:string`*
- `int __sizeAuthenticatingAuthority` is a sequence of elements *`<saml2:AuthenticatingAuthority>`* of XML schema type *`xsd:string`* stored in dynamic array `saml2__AuthenticatingAuthority` of length `__sizeAuthenticatingAuthority` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__AuthnContextType` are available:

- `struct saml2__AuthnContextType *soap_new_saml2__AuthnContextType(struct soap*)` managed allocation with default initialization
- `struct saml2__AuthnContextType *soap_new_saml2__AuthnContextType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AuthnContextType[n]`
- `struct saml2__AuthnContextType *soap_new_req_saml2__AuthnContextType(struct soap*, int __sizeAuthenticatingAuthority, char **saml2__AuthenticatingAuthority)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AuthnContextType *soap_new_set_saml2__AuthnContextType(struct soap*, char *saml2__AuthnContextClassRef, char *saml2__AuthnContextDecl, char *saml2__AuthnContextDeclRef, char *saml2__AuthnContextDecl_, char *saml2__AuthnContextDeclRef_, int __sizeAuthenticatingAuthority, char **saml2__AuthenticatingAuthority)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AuthnContextType(struct soap*, struct saml2__AuthnContextType*)` (re)set to default initialization values
- `int soap_write_saml2__AuthnContextType(struct soap*, const struct saml2__AuthnContextType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AuthnContextType(struct soap*, struct saml2__AuthnContextType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AuthnContextType(struct soap*, const char *URL, const struct saml2__AuthnContextType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AuthnContextType(struct soap*, const char *URL, const struct saml2__AuthnContextType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AuthnContextType(struct soap*, const char *URL, const struct saml2__AuthnContextType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AuthnContextType(struct soap*, struct saml2__AuthnContextType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AuthnContextType(struct soap*, const char *URL, struct saml2__AuthnContextType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml2__union_EvidenceType"></a>

### `struct __saml2__union_EvidenceType`

This struct is declared in [saml2.h](saml2.h) at line 479, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml2__union_EvidenceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml2__union_EvidenceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *saml2__AssertionIDRef` is an optional element *`<saml2:AssertionIDRef>`* of XML schema type *`xsd:string`*
- `char *saml2__AssertionURIRef` is an optional element *`<saml2:AssertionURIRef>`* of XML schema type *`xsd:string`*
- `struct saml2__AssertionType *saml2__Assertion` is an optional element *`<saml2:Assertion>`* of XML schema type *`saml2:AssertionType`*, where the type of this member is a pointer to <code><a href="#saml2__AssertionType"> saml2__AssertionType </a></code>
- `struct saml2__EncryptedElementType *saml2__EncryptedAssertion` is an optional element *`<saml2:EncryptedAssertion>`* of XML schema type *`saml2:EncryptedElementType`*, where the type of this member is a pointer to <code><a href="#saml2__EncryptedElementType"> saml2__EncryptedElementType </a></code>

The following operations on `struct __saml2__union_EvidenceType` are available:

- `struct __saml2__union_EvidenceType *soap_new___saml2__union_EvidenceType(struct soap*)` managed allocation with default initialization
- `struct __saml2__union_EvidenceType *soap_new___saml2__union_EvidenceType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml2__union_EvidenceType[n]`
- `struct __saml2__union_EvidenceType *soap_new_req___saml2__union_EvidenceType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml2__union_EvidenceType *soap_new_set___saml2__union_EvidenceType(struct soap*, char *saml2__AssertionIDRef, char *saml2__AssertionURIRef, struct saml2__AssertionType *saml2__Assertion, struct saml2__EncryptedElementType *saml2__EncryptedAssertion)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml2__union_EvidenceType(struct soap*, struct __saml2__union_EvidenceType*)` (re)set to default initialization values
- `int soap_write___saml2__union_EvidenceType(struct soap*, const struct __saml2__union_EvidenceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml2__union_EvidenceType(struct soap*, struct __saml2__union_EvidenceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml2__union_EvidenceType(struct soap*, const char *URL, const struct __saml2__union_EvidenceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml2__union_EvidenceType(struct soap*, const char *URL, const struct __saml2__union_EvidenceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml2__union_EvidenceType(struct soap*, const char *URL, const struct __saml2__union_EvidenceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml2__union_EvidenceType(struct soap*, struct __saml2__union_EvidenceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml2__union_EvidenceType(struct soap*, const char *URL, struct __saml2__union_EvidenceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__EvidenceType"></a>

### `struct saml2__EvidenceType`

This struct is declared in [saml2.h](saml2.h) at line 135, is serialized as XML schema type *`saml2:EvidenceType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml2:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml2__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml2__EvidenceType; }
        /** Constructor with member initializations */
        saml2__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_EvidenceType` is a sequence of elements *`<-union-EvidenceType>`* of XML schema type *`-saml2:union-EvidenceType`* stored in dynamic array `__union_EvidenceType` of length `__size_EvidenceType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__EvidenceType` are available:

- `struct saml2__EvidenceType *soap_new_saml2__EvidenceType(struct soap*)` managed allocation with default initialization
- `struct saml2__EvidenceType *soap_new_saml2__EvidenceType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__EvidenceType[n]`
- `struct saml2__EvidenceType *soap_new_req_saml2__EvidenceType(struct soap*, int __size_EvidenceType, struct __saml2__union_EvidenceType *__union_EvidenceType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__EvidenceType *soap_new_set_saml2__EvidenceType(struct soap*, int __size_EvidenceType, struct __saml2__union_EvidenceType *__union_EvidenceType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__EvidenceType(struct soap*, struct saml2__EvidenceType*)` (re)set to default initialization values
- `int soap_write_saml2__EvidenceType(struct soap*, const struct saml2__EvidenceType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__EvidenceType(struct soap*, struct saml2__EvidenceType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__EvidenceType(struct soap*, const char *URL, const struct saml2__EvidenceType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__EvidenceType(struct soap*, const char *URL, const struct saml2__EvidenceType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__EvidenceType(struct soap*, const char *URL, const struct saml2__EvidenceType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__EvidenceType(struct soap*, struct saml2__EvidenceType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__EvidenceType(struct soap*, const char *URL, struct saml2__EvidenceType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AttributeType"></a>

### `struct saml2__AttributeType`

This struct is declared in [saml2.h](saml2.h) at line 141, is serialized as XML schema type *`saml2:AttributeType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AttributeType {
      public:
        /** Sequence of elements 'saml2:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml2__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml2__AttributeValue;
        /** Required attribute 'Name' of XML schema type 'xsd:string' */
        char *Name;
        /** Optional attribute 'NameFormat' of XML schema type 'xsd:string' */
        char *NameFormat;
        /** Optional attribute 'FriendlyName' of XML schema type 'xsd:string' */
        char *FriendlyName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeType; }
        /** Constructor with member initializations */
        saml2__AttributeType() : __sizeAttributeValue(), saml2__AttributeValue(), Name(), NameFormat(), FriendlyName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeAttributeValue` is a sequence of elements *`<saml2:AttributeValue>`* of XML schema type *`xsd:anyType`* stored in dynamic array `saml2__AttributeValue` of length `__sizeAttributeValue` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Name` is a required attribute *`Name`* of XML schema type *`xsd:string`*
- `char *NameFormat` is an optional attribute *`NameFormat`* of XML schema type *`xsd:string`*
- `char *FriendlyName` is an optional attribute *`FriendlyName`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__AttributeType` are available:

- `struct saml2__AttributeType *soap_new_saml2__AttributeType(struct soap*)` managed allocation with default initialization
- `struct saml2__AttributeType *soap_new_saml2__AttributeType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AttributeType[n]`
- `struct saml2__AttributeType *soap_new_req_saml2__AttributeType(struct soap*, int __sizeAttributeValue, char **saml2__AttributeValue, char *Name)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AttributeType *soap_new_set_saml2__AttributeType(struct soap*, int __sizeAttributeValue, char **saml2__AttributeValue, char *Name, char *NameFormat, char *FriendlyName)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AttributeType(struct soap*, struct saml2__AttributeType*)` (re)set to default initialization values
- `int soap_write_saml2__AttributeType(struct soap*, const struct saml2__AttributeType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AttributeType(struct soap*, struct saml2__AttributeType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AttributeType(struct soap*, const char *URL, const struct saml2__AttributeType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AttributeType(struct soap*, const char *URL, const struct saml2__AttributeType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AttributeType(struct soap*, const char *URL, const struct saml2__AttributeType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AttributeType(struct soap*, struct saml2__AttributeType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AttributeType(struct soap*, const char *URL, struct saml2__AttributeType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__NameIDType"></a>

### `struct saml2__NameIDType`

This struct is declared in [saml2.h](saml2.h) at line 78, is a simple content wrapper *`saml2:NameIDType`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__NameIDType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
        /** Optional attribute 'SPProvidedID' of XML schema type 'xsd:string' */
        char *SPProvidedID;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__NameIDType */
        long soap_type() const { return SOAP_TYPE_saml2__NameIDType; }
        /** Constructor with member initializations */
        saml2__NameIDType() : __item(), Format(), SPProvidedID(), NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`saml2:NameIDType`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Format` is an optional attribute *`Format`* of XML schema type *`xsd:string`*
- `char *SPProvidedID` is an optional attribute *`SPProvidedID`* of XML schema type *`xsd:string`*
- `char *NameQualifier` is an optional attribute *`NameQualifier`* of XML schema type *`xsd:string`*
- `char *SPNameQualifier` is an optional attribute *`SPNameQualifier`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__NameIDType` are available:

- `struct saml2__NameIDType *soap_new_saml2__NameIDType(struct soap*)` managed allocation with default initialization
- `struct saml2__NameIDType *soap_new_saml2__NameIDType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__NameIDType[n]`
- `struct saml2__NameIDType *soap_new_req_saml2__NameIDType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__NameIDType *soap_new_set_saml2__NameIDType(struct soap*, char *__item, char *Format, char *SPProvidedID, char *NameQualifier, char *SPNameQualifier)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__NameIDType(struct soap*, struct saml2__NameIDType*)` (re)set to default initialization values
- `int soap_write_saml2__NameIDType(struct soap*, const struct saml2__NameIDType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__NameIDType(struct soap*, struct saml2__NameIDType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__NameIDType(struct soap*, const char *URL, const struct saml2__NameIDType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__NameIDType(struct soap*, const char *URL, const struct saml2__NameIDType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__NameIDType(struct soap*, const char *URL, const struct saml2__NameIDType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__NameIDType(struct soap*, struct saml2__NameIDType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__NameIDType(struct soap*, const char *URL, struct saml2__NameIDType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__SubjectConfirmationDataType"></a>

### `struct saml2__SubjectConfirmationDataType`

This struct is declared in [saml2.h](saml2.h) at line 93, is serialized as XML schema type *`saml2:SubjectConfirmationDataType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__SubjectConfirmationDataType {
      public:
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
        /** Optional attribute 'InResponseTo' of XML schema type 'xsd:string' */
        char *InResponseTo;
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationDataType() : NotBefore(), NotOnOrAfter(), Recipient(), InResponseTo(), Address(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct timeval *NotBefore` is an optional attribute *`NotBefore`* of XML schema type *`xsd:dateTime`*, where the type of this member is a pointer to <code><a href="#timeval"> timeval </a></code>
- `struct timeval *NotOnOrAfter` is an optional attribute *`NotOnOrAfter`* of XML schema type *`xsd:dateTime`*, where the type of this member is a pointer to <code><a href="#timeval"> timeval </a></code>
- `char *Recipient` is an optional attribute *`Recipient`* of XML schema type *`xsd:string`*
- `char *InResponseTo` is an optional attribute *`InResponseTo`* of XML schema type *`xsd:string`*
- `char *Address` is an optional attribute *`Address`* of XML schema type *`xsd:string`*
- `char *__mixed`, where the type of this member is <code><a href="#_XML"> _XML </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__SubjectConfirmationDataType` are available:

- `struct saml2__SubjectConfirmationDataType *soap_new_saml2__SubjectConfirmationDataType(struct soap*)` managed allocation with default initialization
- `struct saml2__SubjectConfirmationDataType *soap_new_saml2__SubjectConfirmationDataType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__SubjectConfirmationDataType[n]`
- `struct saml2__SubjectConfirmationDataType *soap_new_req_saml2__SubjectConfirmationDataType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__SubjectConfirmationDataType *soap_new_set_saml2__SubjectConfirmationDataType(struct soap*, struct timeval *NotBefore, struct timeval *NotOnOrAfter, char *Recipient, char *InResponseTo, char *Address, char *__mixed)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__SubjectConfirmationDataType(struct soap*, struct saml2__SubjectConfirmationDataType*)` (re)set to default initialization values
- `int soap_write_saml2__SubjectConfirmationDataType(struct soap*, const struct saml2__SubjectConfirmationDataType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__SubjectConfirmationDataType(struct soap*, struct saml2__SubjectConfirmationDataType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__SubjectConfirmationDataType(struct soap*, const char *URL, const struct saml2__SubjectConfirmationDataType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__SubjectConfirmationDataType(struct soap*, const char *URL, const struct saml2__SubjectConfirmationDataType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__SubjectConfirmationDataType(struct soap*, const char *URL, const struct saml2__SubjectConfirmationDataType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__SubjectConfirmationDataType(struct soap*, struct saml2__SubjectConfirmationDataType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__SubjectConfirmationDataType(struct soap*, const char *URL, struct saml2__SubjectConfirmationDataType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AudienceRestrictionType"></a>

### `struct saml2__AudienceRestrictionType`

This struct is declared in [saml2.h](saml2.h) at line 105, is serialized as XML schema type *`saml2:AudienceRestrictionType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AudienceRestrictionType {
      public:
        /** Sequence of at least 1 elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AudienceRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__AudienceRestrictionType; }
        /** Constructor with member initializations */
        saml2__AudienceRestrictionType() : __sizeAudience(), saml2__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeAudience` is a sequence of at least 1 elements *`<saml2:Audience>`* of XML schema type *`xsd:string`* stored in dynamic array `saml2__Audience` of length `__sizeAudience` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__AudienceRestrictionType` are available:

- `struct saml2__AudienceRestrictionType *soap_new_saml2__AudienceRestrictionType(struct soap*)` managed allocation with default initialization
- `struct saml2__AudienceRestrictionType *soap_new_saml2__AudienceRestrictionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AudienceRestrictionType[n]`
- `struct saml2__AudienceRestrictionType *soap_new_req_saml2__AudienceRestrictionType(struct soap*, int __sizeAudience, char **saml2__Audience)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AudienceRestrictionType *soap_new_set_saml2__AudienceRestrictionType(struct soap*, int __sizeAudience, char **saml2__Audience)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AudienceRestrictionType(struct soap*, struct saml2__AudienceRestrictionType*)` (re)set to default initialization values
- `int soap_write_saml2__AudienceRestrictionType(struct soap*, const struct saml2__AudienceRestrictionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AudienceRestrictionType(struct soap*, struct saml2__AudienceRestrictionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AudienceRestrictionType(struct soap*, const char *URL, const struct saml2__AudienceRestrictionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AudienceRestrictionType(struct soap*, const char *URL, const struct saml2__AudienceRestrictionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AudienceRestrictionType(struct soap*, const char *URL, const struct saml2__AudienceRestrictionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AudienceRestrictionType(struct soap*, struct saml2__AudienceRestrictionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AudienceRestrictionType(struct soap*, const char *URL, struct saml2__AudienceRestrictionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__OneTimeUseType"></a>

### `struct saml2__OneTimeUseType`

This struct is declared in [saml2.h](saml2.h) at line 108, is serialized as XML schema type *`saml2:OneTimeUseType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__OneTimeUseType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__OneTimeUseType */
        long soap_type() const { return SOAP_TYPE_saml2__OneTimeUseType; }
        /** Constructor with member initializations */
        saml2__OneTimeUseType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap*, int, const char*, const char*, size_t*);
    };

where:


The following operations on `struct saml2__OneTimeUseType` are available:

- `struct saml2__OneTimeUseType *soap_new_saml2__OneTimeUseType(struct soap*)` managed allocation with default initialization
- `struct saml2__OneTimeUseType *soap_new_saml2__OneTimeUseType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__OneTimeUseType[n]`
- `struct saml2__OneTimeUseType *soap_new_req_saml2__OneTimeUseType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__OneTimeUseType *soap_new_set_saml2__OneTimeUseType(struct soap*)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__OneTimeUseType(struct soap*, struct saml2__OneTimeUseType*)` (re)set to default initialization values
- `int soap_write_saml2__OneTimeUseType(struct soap*, const struct saml2__OneTimeUseType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__OneTimeUseType(struct soap*, struct saml2__OneTimeUseType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__OneTimeUseType(struct soap*, const char *URL, const struct saml2__OneTimeUseType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__OneTimeUseType(struct soap*, const char *URL, const struct saml2__OneTimeUseType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__OneTimeUseType(struct soap*, const char *URL, const struct saml2__OneTimeUseType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__OneTimeUseType(struct soap*, struct saml2__OneTimeUseType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__OneTimeUseType(struct soap*, const char *URL, struct saml2__OneTimeUseType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__ProxyRestrictionType"></a>

### `struct saml2__ProxyRestrictionType`

This struct is declared in [saml2.h](saml2.h) at line 111, is serialized as XML schema type *`saml2:ProxyRestrictionType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__ProxyRestrictionType {
      public:
        /** Sequence of elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
        /** Optional attribute 'Count' of XML schema type 'xsd:string' */
        char *Count;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ProxyRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__ProxyRestrictionType; }
        /** Constructor with member initializations */
        saml2__ProxyRestrictionType() : __sizeAudience(), saml2__Audience(), Count() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeAudience` is a sequence of elements *`<saml2:Audience>`* of XML schema type *`xsd:string`* stored in dynamic array `saml2__Audience` of length `__sizeAudience` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Count` is an optional attribute *`Count`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__ProxyRestrictionType` are available:

- `struct saml2__ProxyRestrictionType *soap_new_saml2__ProxyRestrictionType(struct soap*)` managed allocation with default initialization
- `struct saml2__ProxyRestrictionType *soap_new_saml2__ProxyRestrictionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__ProxyRestrictionType[n]`
- `struct saml2__ProxyRestrictionType *soap_new_req_saml2__ProxyRestrictionType(struct soap*, int __sizeAudience, char **saml2__Audience)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__ProxyRestrictionType *soap_new_set_saml2__ProxyRestrictionType(struct soap*, int __sizeAudience, char **saml2__Audience, char *Count)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__ProxyRestrictionType(struct soap*, struct saml2__ProxyRestrictionType*)` (re)set to default initialization values
- `int soap_write_saml2__ProxyRestrictionType(struct soap*, const struct saml2__ProxyRestrictionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__ProxyRestrictionType(struct soap*, struct saml2__ProxyRestrictionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__ProxyRestrictionType(struct soap*, const char *URL, const struct saml2__ProxyRestrictionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__ProxyRestrictionType(struct soap*, const char *URL, const struct saml2__ProxyRestrictionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__ProxyRestrictionType(struct soap*, const char *URL, const struct saml2__ProxyRestrictionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__ProxyRestrictionType(struct soap*, struct saml2__ProxyRestrictionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__ProxyRestrictionType(struct soap*, const char *URL, struct saml2__ProxyRestrictionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AuthnStatementType"></a>

### `struct saml2__AuthnStatementType`

This struct is declared in [saml2.h](saml2.h) at line 120, is serialized as XML schema type *`saml2:AuthnStatementType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AuthnStatementType {
      public:
        /** Optional element 'saml2:SubjectLocality' of XML schema type 'saml2:SubjectLocalityType' */
        struct saml2__SubjectLocalityType *saml2__SubjectLocality;
        /** Required element 'saml2:AuthnContext' of XML schema type 'saml2:AuthnContextType' */
        struct saml2__AuthnContextType *saml2__AuthnContext;
        /** Required attribute 'AuthnInstant' of XML schema type 'xsd:dateTime' */
        struct timeval AuthnInstant;
        /** Optional attribute 'SessionIndex' of XML schema type 'xsd:string' */
        char *SessionIndex;
        /** Optional attribute 'SessionNotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *SessionNotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnStatementType; }
        /** Constructor with member initializations */
        saml2__AuthnStatementType() : saml2__SubjectLocality(), saml2__AuthnContext(), AuthnInstant(), SessionIndex(), SessionNotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml2__SubjectLocalityType *saml2__SubjectLocality` is an optional element *`<saml2:SubjectLocality>`* of XML schema type *`saml2:SubjectLocalityType`*, where the type of this member is a pointer to <code><a href="#saml2__SubjectLocalityType"> saml2__SubjectLocalityType </a></code>
- `struct saml2__AuthnContextType *saml2__AuthnContext` is a required element *`<saml2:AuthnContext>`* of XML schema type *`saml2:AuthnContextType`*, where the type of this member is a pointer to <code><a href="#saml2__AuthnContextType"> saml2__AuthnContextType </a></code>
- `struct timeval AuthnInstant` is a required attribute *`AuthnInstant`* of XML schema type *`xsd:dateTime`* with a custom serializer `xsd__dateTime`, where the type of this member is <code><a href="#timeval"> timeval </a></code>
- `char *SessionIndex` is an optional attribute *`SessionIndex`* of XML schema type *`xsd:string`*
- `struct timeval *SessionNotOnOrAfter` is an optional attribute *`SessionNotOnOrAfter`* of XML schema type *`xsd:dateTime`*, where the type of this member is a pointer to <code><a href="#timeval"> timeval </a></code>

The following operations on `struct saml2__AuthnStatementType` are available:

- `struct saml2__AuthnStatementType *soap_new_saml2__AuthnStatementType(struct soap*)` managed allocation with default initialization
- `struct saml2__AuthnStatementType *soap_new_saml2__AuthnStatementType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AuthnStatementType[n]`
- `struct saml2__AuthnStatementType *soap_new_req_saml2__AuthnStatementType(struct soap*, struct saml2__AuthnContextType *saml2__AuthnContext, const struct timeval& AuthnInstant)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AuthnStatementType *soap_new_set_saml2__AuthnStatementType(struct soap*, struct saml2__SubjectLocalityType *saml2__SubjectLocality, struct saml2__AuthnContextType *saml2__AuthnContext, const struct timeval& AuthnInstant, char *SessionIndex, struct timeval *SessionNotOnOrAfter)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AuthnStatementType(struct soap*, struct saml2__AuthnStatementType*)` (re)set to default initialization values
- `int soap_write_saml2__AuthnStatementType(struct soap*, const struct saml2__AuthnStatementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AuthnStatementType(struct soap*, struct saml2__AuthnStatementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AuthnStatementType(struct soap*, const char *URL, const struct saml2__AuthnStatementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AuthnStatementType(struct soap*, const char *URL, const struct saml2__AuthnStatementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AuthnStatementType(struct soap*, const char *URL, const struct saml2__AuthnStatementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AuthnStatementType(struct soap*, struct saml2__AuthnStatementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AuthnStatementType(struct soap*, const char *URL, struct saml2__AuthnStatementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AuthzDecisionStatementType"></a>

### `struct saml2__AuthzDecisionStatementType`

This struct is declared in [saml2.h](saml2.h) at line 129, is serialized as XML schema type *`saml2:AuthzDecisionStatementType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AuthzDecisionStatementType {
      public:
        /** Sequence of at least 1 elements 'saml2:Action' of XML schema type 'saml2:ActionType' stored in dynamic array saml2__Action of length __sizeAction */
        int __sizeAction;
        struct saml2__ActionType *saml2__Action;
        /** Optional element 'saml2:Evidence' of XML schema type 'saml2:EvidenceType' */
        struct saml2__EvidenceType *saml2__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml2:DecisionType' */
        enum saml2__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthzDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthzDecisionStatementType; }
        /** Constructor with member initializations */
        saml2__AuthzDecisionStatementType() : __sizeAction(), saml2__Action(), saml2__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeAction` is a sequence of at least 1 elements *`<saml2:Action>`* of XML schema type *`saml2:ActionType`* stored in dynamic array `saml2__Action` of length `__sizeAction` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct saml2__EvidenceType *saml2__Evidence` is an optional element *`<saml2:Evidence>`* of XML schema type *`saml2:EvidenceType`*, where the type of this member is a pointer to <code><a href="#saml2__EvidenceType"> saml2__EvidenceType </a></code>
- `char *Resource` is a required attribute *`Resource`* of XML schema type *`xsd:string`*
- `enum saml2__DecisionType Decision` is a required attribute *`Decision`* of XML schema type *`saml2:DecisionType`*, where the type of this member is <code><a href="#saml2__DecisionType"> saml2__DecisionType </a></code>

The following operations on `struct saml2__AuthzDecisionStatementType` are available:

- `struct saml2__AuthzDecisionStatementType *soap_new_saml2__AuthzDecisionStatementType(struct soap*)` managed allocation with default initialization
- `struct saml2__AuthzDecisionStatementType *soap_new_saml2__AuthzDecisionStatementType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AuthzDecisionStatementType[n]`
- `struct saml2__AuthzDecisionStatementType *soap_new_req_saml2__AuthzDecisionStatementType(struct soap*, int __sizeAction, struct saml2__ActionType *saml2__Action, char *Resource, enum saml2__DecisionType Decision)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AuthzDecisionStatementType *soap_new_set_saml2__AuthzDecisionStatementType(struct soap*, int __sizeAction, struct saml2__ActionType *saml2__Action, struct saml2__EvidenceType *saml2__Evidence, char *Resource, enum saml2__DecisionType Decision)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AuthzDecisionStatementType(struct soap*, struct saml2__AuthzDecisionStatementType*)` (re)set to default initialization values
- `int soap_write_saml2__AuthzDecisionStatementType(struct soap*, const struct saml2__AuthzDecisionStatementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AuthzDecisionStatementType(struct soap*, struct saml2__AuthzDecisionStatementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AuthzDecisionStatementType(struct soap*, const char *URL, const struct saml2__AuthzDecisionStatementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AuthzDecisionStatementType(struct soap*, const char *URL, const struct saml2__AuthzDecisionStatementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AuthzDecisionStatementType(struct soap*, const char *URL, const struct saml2__AuthzDecisionStatementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AuthzDecisionStatementType(struct soap*, struct saml2__AuthzDecisionStatementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AuthzDecisionStatementType(struct soap*, const char *URL, struct saml2__AuthzDecisionStatementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__ActionType"></a>

### `struct saml2__ActionType`

This struct is declared in [saml2.h](saml2.h) at line 132, is a simple content wrapper *`saml2:ActionType`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ActionType */
        long soap_type() const { return SOAP_TYPE_saml2__ActionType; }
        /** Constructor with member initializations */
        saml2__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`saml2:ActionType`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Namespace` is a required attribute *`Namespace`* of XML schema type *`xsd:string`*

The following operations on `struct saml2__ActionType` are available:

- `struct saml2__ActionType *soap_new_saml2__ActionType(struct soap*)` managed allocation with default initialization
- `struct saml2__ActionType *soap_new_saml2__ActionType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__ActionType[n]`
- `struct saml2__ActionType *soap_new_req_saml2__ActionType(struct soap*, char *Namespace)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__ActionType *soap_new_set_saml2__ActionType(struct soap*, char *__item, char *Namespace)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__ActionType(struct soap*, struct saml2__ActionType*)` (re)set to default initialization values
- `int soap_write_saml2__ActionType(struct soap*, const struct saml2__ActionType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__ActionType(struct soap*, struct saml2__ActionType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__ActionType(struct soap*, const char *URL, const struct saml2__ActionType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__ActionType(struct soap*, const char *URL, const struct saml2__ActionType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__ActionType(struct soap*, const char *URL, const struct saml2__ActionType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__ActionType(struct soap*, struct saml2__ActionType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__ActionType(struct soap*, const char *URL, struct saml2__ActionType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__saml2__union_AttributeStatementType"></a>

### `struct __saml2__union_AttributeStatementType`

This struct is declared in [saml2.h](saml2.h) at line 729, is a wrapper, meaning that it wraps data and is not visible in XML, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC __saml2__union_AttributeStatementType {
      public:
        /** Optional element 'saml2:Attribute' of XML schema type 'saml2:AttributeType' */
        struct saml2__AttributeType *saml2__Attribute;
        /** Optional element 'saml2:EncryptedAttribute' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAttribute;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AttributeStatementType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AttributeStatementType; }
        /** Constructor with member initializations */
        __saml2__union_AttributeStatementType() : saml2__Attribute(), saml2__EncryptedAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct saml2__AttributeType *saml2__Attribute` is an optional element *`<saml2:Attribute>`* of XML schema type *`saml2:AttributeType`*, where the type of this member is a pointer to <code><a href="#saml2__AttributeType"> saml2__AttributeType </a></code>
- `struct saml2__EncryptedElementType *saml2__EncryptedAttribute` is an optional element *`<saml2:EncryptedAttribute>`* of XML schema type *`saml2:EncryptedElementType`*, where the type of this member is a pointer to <code><a href="#saml2__EncryptedElementType"> saml2__EncryptedElementType </a></code>

The following operations on `struct __saml2__union_AttributeStatementType` are available:

- `struct __saml2__union_AttributeStatementType *soap_new___saml2__union_AttributeStatementType(struct soap*)` managed allocation with default initialization
- `struct __saml2__union_AttributeStatementType *soap_new___saml2__union_AttributeStatementType(struct soap*, int n)` managed allocation with default initialization of array `struct __saml2__union_AttributeStatementType[n]`
- `struct __saml2__union_AttributeStatementType *soap_new_req___saml2__union_AttributeStatementType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct __saml2__union_AttributeStatementType *soap_new_set___saml2__union_AttributeStatementType(struct soap*, struct saml2__AttributeType *saml2__Attribute, struct saml2__EncryptedElementType *saml2__EncryptedAttribute)` managed allocation with the public members assigned the values of these parameters
- `void soap_default___saml2__union_AttributeStatementType(struct soap*, struct __saml2__union_AttributeStatementType*)` (re)set to default initialization values
- `int soap_write___saml2__union_AttributeStatementType(struct soap*, const struct __saml2__union_AttributeStatementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read___saml2__union_AttributeStatementType(struct soap*, struct __saml2__union_AttributeStatementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT___saml2__union_AttributeStatementType(struct soap*, const char *URL, const struct __saml2__union_AttributeStatementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH___saml2__union_AttributeStatementType(struct soap*, const char *URL, const struct __saml2__union_AttributeStatementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send___saml2__union_AttributeStatementType(struct soap*, const char *URL, const struct __saml2__union_AttributeStatementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv___saml2__union_AttributeStatementType(struct soap*, struct __saml2__union_AttributeStatementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET___saml2__union_AttributeStatementType(struct soap*, const char *URL, struct __saml2__union_AttributeStatementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__AttributeStatementType"></a>

### `struct saml2__AttributeStatementType`

This struct is declared in [saml2.h](saml2.h) at line 138, is serialized as XML schema type *`saml2:AttributeStatementType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__AttributeStatementType {
      public:
        /** Sequence of elements '-union-AttributeStatementType' of XML schema type '-saml2:union-AttributeStatementType' stored in dynamic array __union_AttributeStatementType of length __size_AttributeStatementType */
        int __size_AttributeStatementType;
        struct __saml2__union_AttributeStatementType *__union_AttributeStatementType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeStatementType; }
        /** Constructor with member initializations */
        saml2__AttributeStatementType() : __size_AttributeStatementType(), __union_AttributeStatementType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __size_AttributeStatementType` is a sequence of elements *`<-union-AttributeStatementType>`* of XML schema type *`-saml2:union-AttributeStatementType`* stored in dynamic array `__union_AttributeStatementType` of length `__size_AttributeStatementType` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__AttributeStatementType` are available:

- `struct saml2__AttributeStatementType *soap_new_saml2__AttributeStatementType(struct soap*)` managed allocation with default initialization
- `struct saml2__AttributeStatementType *soap_new_saml2__AttributeStatementType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__AttributeStatementType[n]`
- `struct saml2__AttributeStatementType *soap_new_req_saml2__AttributeStatementType(struct soap*, int __size_AttributeStatementType, struct __saml2__union_AttributeStatementType *__union_AttributeStatementType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__AttributeStatementType *soap_new_set_saml2__AttributeStatementType(struct soap*, int __size_AttributeStatementType, struct __saml2__union_AttributeStatementType *__union_AttributeStatementType)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__AttributeStatementType(struct soap*, struct saml2__AttributeStatementType*)` (re)set to default initialization values
- `int soap_write_saml2__AttributeStatementType(struct soap*, const struct saml2__AttributeStatementType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__AttributeStatementType(struct soap*, struct saml2__AttributeStatementType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__AttributeStatementType(struct soap*, const char *URL, const struct saml2__AttributeStatementType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__AttributeStatementType(struct soap*, const char *URL, const struct saml2__AttributeStatementType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__AttributeStatementType(struct soap*, const char *URL, const struct saml2__AttributeStatementType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__AttributeStatementType(struct soap*, struct saml2__AttributeStatementType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__AttributeStatementType(struct soap*, const char *URL, struct saml2__AttributeStatementType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="saml2__KeyInfoConfirmationDataType"></a>

### `struct saml2__KeyInfoConfirmationDataType`

This struct is declared in [saml2.h](saml2.h) at line 96, is serialized as XML schema type *`saml2:KeyInfoConfirmationDataType`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC saml2__KeyInfoConfirmationDataType {
      public:
        /** Sequence of at least 1 elements 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' stored in dynamic array ds__KeyInfo of length __sizeds__KeyInfo */
        int __sizeds__KeyInfo;
        struct ds__KeyInfoType **ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml2__KeyInfoConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__KeyInfoConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__KeyInfoConfirmationDataType() : __sizeds__KeyInfo(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int __sizeds__KeyInfo` is a sequence of at least 1 elements *`<ds:KeyInfo>`* of XML schema type *`ds:KeyInfo`* stored in dynamic array `ds__KeyInfo` of length `__sizeds__KeyInfo` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `struct saml2__KeyInfoConfirmationDataType` are available:

- `struct saml2__KeyInfoConfirmationDataType *soap_new_saml2__KeyInfoConfirmationDataType(struct soap*)` managed allocation with default initialization
- `struct saml2__KeyInfoConfirmationDataType *soap_new_saml2__KeyInfoConfirmationDataType(struct soap*, int n)` managed allocation with default initialization of array `struct saml2__KeyInfoConfirmationDataType[n]`
- `struct saml2__KeyInfoConfirmationDataType *soap_new_req_saml2__KeyInfoConfirmationDataType(struct soap*, int __sizeds__KeyInfo, struct ds__KeyInfoType **ds__KeyInfo)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct saml2__KeyInfoConfirmationDataType *soap_new_set_saml2__KeyInfoConfirmationDataType(struct soap*, int __sizeds__KeyInfo, struct ds__KeyInfoType **ds__KeyInfo)` managed allocation with the public members assigned the values of these parameters
- `void soap_default_saml2__KeyInfoConfirmationDataType(struct soap*, struct saml2__KeyInfoConfirmationDataType*)` (re)set to default initialization values
- `int soap_write_saml2__KeyInfoConfirmationDataType(struct soap*, const struct saml2__KeyInfoConfirmationDataType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read_saml2__KeyInfoConfirmationDataType(struct soap*, struct saml2__KeyInfoConfirmationDataType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT_saml2__KeyInfoConfirmationDataType(struct soap*, const char *URL, const struct saml2__KeyInfoConfirmationDataType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_saml2__KeyInfoConfirmationDataType(struct soap*, const char *URL, const struct saml2__KeyInfoConfirmationDataType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_saml2__KeyInfoConfirmationDataType(struct soap*, const char *URL, const struct saml2__KeyInfoConfirmationDataType*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv_saml2__KeyInfoConfirmationDataType(struct soap*, struct saml2__KeyInfoConfirmationDataType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET_saml2__KeyInfoConfirmationDataType(struct soap*, const char *URL, struct saml2__KeyInfoConfirmationDataType*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__Security"></a>

### `struct _wsse__Security`

This struct is declared in [wsse.h](wsse.h) at line 212, is serialized as XML schema type *`wsse:Security`*, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XML schema type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XML schema type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XML schema type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XML schema type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XML schema type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional attribute 'SOAP-ENV:actor' of XML schema type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        long soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security() : wsu__Timestamp(), UsernameToken(), BinarySecurityToken(), xenc__EncryptedKey(), xenc__ReferenceList(), wsc__SecurityContextToken(), ds__Signature(), saml1__Assertion(), saml2__Assertion(), SOAP_ENV__actor(), SOAP_ENV__role() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct _wsu__Timestamp *wsu__Timestamp` is an optional element *`<wsu:Timestamp>`* of XML schema type *`wsu:Timestamp`*, where the type of this member is a pointer to <code><a href="#_wsu__Timestamp"> _wsu__Timestamp </a></code>
- `struct _wsse__UsernameToken *UsernameToken` is an optional element *`<wsse:UsernameToken>`* of XML schema type *`wsse:UsernameToken`*, where the type of this member is a pointer to <code><a href="#_wsse__UsernameToken"> _wsse__UsernameToken </a></code>
- `struct _wsse__BinarySecurityToken *BinarySecurityToken` is an optional element *`<wsse:BinarySecurityToken>`* of XML schema type *`wsse:BinarySecurityToken`*, where the type of this member is a pointer to <code><a href="#_wsse__BinarySecurityToken"> _wsse__BinarySecurityToken </a></code>
- `struct xenc__EncryptedKeyType *xenc__EncryptedKey` is an optional element *`<xenc:EncryptedKey>`* of XML schema type *`xenc:EncryptedKeyType`*, where the type of this member is a pointer to <code><a href="#xenc__EncryptedKeyType"> xenc__EncryptedKeyType </a></code>
- `struct _xenc__ReferenceList *xenc__ReferenceList` is an optional element *`<xenc:ReferenceList>`* of XML schema type *`xenc:ReferenceList`*, where the type of this member is a pointer to <code><a href="#_xenc__ReferenceList"> _xenc__ReferenceList </a></code>
- `struct wsc__SecurityContextTokenType *wsc__SecurityContextToken` is an optional element *`<wsc:SecurityContextToken>`* of XML schema type *`wsc:SecurityContextTokenType`*, where the type of this member is a pointer to <code><a href="#wsc__SecurityContextTokenType"> wsc__SecurityContextTokenType </a></code>
- `struct ds__SignatureType *ds__Signature` is an optional element *`<ds:Signature>`* of XML schema type *`ds:SignatureType`*, where the type of this member is a pointer to <code><a href="#ds__SignatureType"> ds__SignatureType </a></code>
- `struct saml1__AssertionType *saml1__Assertion` is an optional element *`<saml1:Assertion>`* of XML schema type *`saml1:AssertionType`*, where the type of this member is a pointer to <code><a href="#saml1__AssertionType"> saml1__AssertionType </a></code>
- `struct saml2__AssertionType *saml2__Assertion` is an optional element *`<saml2:Assertion>`* of XML schema type *`saml2:AssertionType`*, where the type of this member is a pointer to <code><a href="#saml2__AssertionType"> saml2__AssertionType </a></code>
- `char *SOAP_ENV__actor` is an optional attribute *`SOAP-ENV:actor`* of XML schema type *`xsd:string`*
- `char *SOAP_ENV__role` is an optional attribute *`SOAP-ENV:role`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__Security` are available:

- `struct _wsse__Security *soap_new__wsse__Security(struct soap*)` managed allocation with default initialization
- `struct _wsse__Security *soap_new__wsse__Security(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__Security[n]`
- `struct _wsse__Security *soap_new_req__wsse__Security(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__Security *soap_new_set__wsse__Security(struct soap*, struct _wsu__Timestamp *wsu__Timestamp, struct _wsse__UsernameToken *UsernameToken, struct _wsse__BinarySecurityToken *BinarySecurityToken, struct xenc__EncryptedKeyType *xenc__EncryptedKey, struct _xenc__ReferenceList *xenc__ReferenceList, struct wsc__SecurityContextTokenType *wsc__SecurityContextToken, struct ds__SignatureType *ds__Signature, struct saml1__AssertionType *saml1__Assertion, struct saml2__AssertionType *saml2__Assertion, char *SOAP_ENV__actor, char *SOAP_ENV__role)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__Security(struct soap*, struct _wsse__Security*)` (re)set to default initialization values
- `int soap_write__wsse__Security(struct soap*, const struct _wsse__Security*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__Security(struct soap*, struct _wsse__Security*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__Security(struct soap*, const char *URL, const struct _wsse__Security*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__Security(struct soap*, const char *URL, const struct _wsse__Security*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__Security(struct soap*, const char *URL, const struct _wsse__Security*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__Security(struct soap*, struct _wsse__Security*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__Security(struct soap*, const char *URL, struct _wsse__Security*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_wsse__Password"></a>

### `struct _wsse__Password`

This struct is declared in [wsse.h](wsse.h) at line 146, is a simple content wrapper *`wsse:Password`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC _wsse__Password {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        long soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password() : __item(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`wsse:Password`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `char *Type` is an optional attribute *`Type`* of XML schema type *`xsd:string`*

The following operations on `struct _wsse__Password` are available:

- `struct _wsse__Password *soap_new__wsse__Password(struct soap*)` managed allocation with default initialization
- `struct _wsse__Password *soap_new__wsse__Password(struct soap*, int n)` managed allocation with default initialization of array `struct _wsse__Password[n]`
- `struct _wsse__Password *soap_new_req__wsse__Password(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `struct _wsse__Password *soap_new_set__wsse__Password(struct soap*, char *__item, char *Type)` managed allocation with the public members assigned the values of these parameters
- `void soap_default__wsse__Password(struct soap*, struct _wsse__Password*)` (re)set to default initialization values
- `int soap_write__wsse__Password(struct soap*, const struct _wsse__Password*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_read__wsse__Password(struct soap*, struct _wsse__Password*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_PUT__wsse__Password(struct soap*, const char *URL, const struct _wsse__Password*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__wsse__Password(struct soap*, const char *URL, const struct _wsse__Password*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__wsse__Password(struct soap*, const char *URL, const struct _wsse__Password*)` REST POST send XML (should be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_POST_recv__wsse__Password(struct soap*, struct _wsse__Password*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code
- `int soap_GET__wsse__Password(struct soap*, const char *URL, struct _wsse__Password*)` REST GET XML, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="SOAP_ENV__Header"></a>

### `struct SOAP_ENV__Header`

This struct is declared in [wsse.h](wsse.h) at line 244, is the SOAP protocol *`<SOAP-ENV:Header>`* element with message-specific child elements that are mandatory to process when attributed with *`mustUnderstand="true"`*.  Headers are usually added and processed by plugins.  To remove the SOAP Header when sending or returning a message, set `soap->header = NULL`.  Use `soap_header(struct soap *soap)` to allocate a `struct SOAP_ENV__Header` which will be pointed to by `soap->header`, then initialize it with `soap_default_SOAP_ENV__Header(soap, soap->header)` and set one or more of its data members (if any):

- `struct _wsse__Security *wsse__Security` element wsse:Security with mustUnderstand="true">


This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsse__Security() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Code"></a>

### `struct SOAP_ENV__Code`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1975, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is the SOAP protocol *`<SOAP-ENV:Code>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Detail"></a>

### `struct SOAP_ENV__Detail`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1975, is the SOAP protocol *`<SOAP-ENV:Detail>`* element with details returned by a service that triggered the error.  Fault details are added and processed by plugins by setting the `detail` (for SOAP 1.1) or `SOAP_ENV__Detail` (for SOAP 1.2) member of `struct SOAP_ENV__Fault` and then setting one ore more of the detail members:

- `char *__any` catch-all XML in literal XML string, see also <code><a href="#_XML"> _XML </a></code>
- `int __type` element *`<fault>`* serialized with C/C++ type `__type` = `SOAP_TYPE_<Type>`


This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Reason"></a>

### `struct SOAP_ENV__Reason`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1975, is the SOAP protocol *`<SOAP-ENV:Reason>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Fault"></a>

### `struct SOAP_ENV__Fault`

This struct is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1975, is the SOAP protocol *`<SOAP-ENV:Fault>`* element with fault information and details returned by a service that triggered the error.  At the server side, a fault can be explicitly set within a service operation by calling and returning:

- `int soap_sender_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the sender is at fault (irrecoverable)
- `int soap_receiver_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the receiver is at fault (recoverable, sender may retry)

A service operation may also return an HTTP status or error code (200 to 599).

At the client side the (proxy) call returns the error code which is also stored in `soap->error`.  The fault structure is pointed to by `soap->fault`.  The fault can be displayed with:

- `void soap_print_fault(struct soap *soap, FILE *fd)` display fault
- `void soap_print_fault_location(struct soap *soap, FILE *fd)` display the location of the fault in the XML message that caused it
- `void soap_sprint_fault(struct soap *soap, char *buf, size_t len)` write fault to buffer
- `void soap_stream_fault(struct soap *soap, std::ostream&)` write fault to stream
- `const char *soap_fault_subcode(struct soap *soap)` returns the SOAP Fault subcode QName string or NULL when absent
- `const char *soap_fault_string(struct soap *soap)` returns the SOAP Fault string/reason or NULL when absent
- `const char *soap_fault_detail(struct soap *soap)` returns the SOAP Fault detail XML string or NULL when absent
- `const char **soap_faultsubcode(struct soap *soap)` returns a pointer to the SOAP Fault to set this QName string
- `const char **soap_faultstring(struct soap *soap)` returns a pointer to the SOAP Fault string/reason to set this string
- `const char **soap_faultdetail(struct soap *soap)` returns a pointer to the SOAP Fault detail XML string to set this string or returns NULL when not accessible

This struct will be auto-generated when it is not explicitly declared in an interface header file and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


## Typedefs {#doc-typedefs}

A typedef type is serializable if its underlying base type is serializable.  Typedefs may declare custom serializers, meaning their underlying types are custom-serialized in XML using serialization rules that differ from the serialization rules of the underlying base type:
<table class="doxtable">
<tr><th> Typedef </th><th> Type </th><th> Declared </th><th> Serializable </th><th> Custom </th></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__QName"> xsd__QName </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:178 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__byte"> xsd__byte </a></code></td><td><code> char </code></td><td> CCMovelDigitalSignature.h:189 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__unsignedByte"> xsd__unsignedByte </a></code></td><td><code> unsigned char </code></td><td> CCMovelDigitalSignature.h:192 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__ID"> xsd__ID </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:195 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__IDREF"> xsd__IDREF </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:205 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__anyURI"> xsd__anyURI </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:222 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__decimal"> xsd__decimal </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:260 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__duration"> xsd__duration </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:277 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#ns4__char"> ns4__char </a></code></td><td><code> int </code></td><td> CCMovelDigitalSignature.h:427 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#ns4__duration"> ns4__duration </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:441 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#ns4__guid"> ns4__guid </a></code></td><td><code> std::string </code></td><td> CCMovelDigitalSignature.h:454 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_ds__SignatureValue"> _ds__SignatureValue </a></code></td><td><code> char * </code></td><td> ds.h:48 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_ds__Signature"> _ds__Signature </a></code></td><td><code> struct ds__SignatureType </code></td><td> ds.h:54 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_ds__Transform"> _ds__Transform </a></code></td><td><code> struct ds__TransformType </code></td><td> ds.h:80 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_ds__KeyInfo"> _ds__KeyInfo </a></code></td><td><code> struct ds__KeyInfoType </code></td><td> ds.h:94 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#wsc__FaultCodeOpenEnumType"> wsc__FaultCodeOpenEnumType </a></code></td><td><code> char * </code></td><td> wsc.h:58 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__dateTime"> xsd__dateTime </a></code></td><td><code> struct timeval </code></td><td> custom/struct_timeval.h:77 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_saml1__AssertionIDReference"> _saml1__AssertionIDReference </a></code></td><td><code> char * </code></td><td> saml1.h:628 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Assertion"> _saml1__Assertion </a></code></td><td><code> struct saml1__AssertionType </code></td><td> saml1.h:631 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Conditions"> _saml1__Conditions </a></code></td><td><code> struct saml1__ConditionsType </code></td><td> saml1.h:634 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Condition"> _saml1__Condition </a></code></td><td><code> struct saml1__ConditionAbstractType </code></td><td> saml1.h:637 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AudienceRestrictionCondition"> _saml1__AudienceRestrictionCondition </a></code></td><td><code> struct saml1__AudienceRestrictionConditionType </code></td><td> saml1.h:640 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Audience"> _saml1__Audience </a></code></td><td><code> char * </code></td><td> saml1.h:643 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__DoNotCacheCondition"> _saml1__DoNotCacheCondition </a></code></td><td><code> struct saml1__DoNotCacheConditionType </code></td><td> saml1.h:646 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Advice"> _saml1__Advice </a></code></td><td><code> struct saml1__AdviceType </code></td><td> saml1.h:649 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Statement"> _saml1__Statement </a></code></td><td><code> struct saml1__StatementAbstractType </code></td><td> saml1.h:652 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectStatement"> _saml1__SubjectStatement </a></code></td><td><code> struct saml1__SubjectStatementAbstractType </code></td><td> saml1.h:655 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Subject"> _saml1__Subject </a></code></td><td><code> struct saml1__SubjectType </code></td><td> saml1.h:658 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__NameIdentifier"> _saml1__NameIdentifier </a></code></td><td><code> struct saml1__NameIdentifierType </code></td><td> saml1.h:661 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectConfirmation"> _saml1__SubjectConfirmation </a></code></td><td><code> struct saml1__SubjectConfirmationType </code></td><td> saml1.h:664 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectConfirmationData"> _saml1__SubjectConfirmationData </a></code></td><td><code> char * </code></td><td> saml1.h:667 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_saml1__ConfirmationMethod"> _saml1__ConfirmationMethod </a></code></td><td><code> char * </code></td><td> saml1.h:670 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AuthenticationStatement"> _saml1__AuthenticationStatement </a></code></td><td><code> struct saml1__AuthenticationStatementType </code></td><td> saml1.h:673 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectLocality"> _saml1__SubjectLocality </a></code></td><td><code> struct saml1__SubjectLocalityType </code></td><td> saml1.h:676 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AuthorityBinding"> _saml1__AuthorityBinding </a></code></td><td><code> struct saml1__AuthorityBindingType </code></td><td> saml1.h:679 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AuthorizationDecisionStatement"> _saml1__AuthorizationDecisionStatement </a></code></td><td><code> struct saml1__AuthorizationDecisionStatementType </code></td><td> saml1.h:682 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Action"> _saml1__Action </a></code></td><td><code> struct saml1__ActionType </code></td><td> saml1.h:685 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Evidence"> _saml1__Evidence </a></code></td><td><code> struct saml1__EvidenceType </code></td><td> saml1.h:688 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AttributeStatement"> _saml1__AttributeStatement </a></code></td><td><code> struct saml1__AttributeStatementType </code></td><td> saml1.h:691 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AttributeDesignator"> _saml1__AttributeDesignator </a></code></td><td><code> struct saml1__AttributeDesignatorType </code></td><td> saml1.h:694 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Attribute"> _saml1__Attribute </a></code></td><td><code> struct saml1__AttributeType </code></td><td> saml1.h:697 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AttributeValue"> _saml1__AttributeValue </a></code></td><td><code> char * </code></td><td> saml1.h:700 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_saml2__BaseID"> _saml2__BaseID </a></code></td><td><code> struct saml2__BaseIDAbstractType </code></td><td> saml2.h:781 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__NameID"> _saml2__NameID </a></code></td><td><code> struct saml2__NameIDType </code></td><td> saml2.h:784 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__EncryptedID"> _saml2__EncryptedID </a></code></td><td><code> struct saml2__EncryptedElementType </code></td><td> saml2.h:787 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Issuer"> _saml2__Issuer </a></code></td><td><code> struct saml2__NameIDType </code></td><td> saml2.h:790 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AssertionIDRef"> _saml2__AssertionIDRef </a></code></td><td><code> char * </code></td><td> saml2.h:793 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AssertionURIRef"> _saml2__AssertionURIRef </a></code></td><td><code> char * </code></td><td> saml2.h:796 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Assertion"> _saml2__Assertion </a></code></td><td><code> struct saml2__AssertionType </code></td><td> saml2.h:799 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Subject"> _saml2__Subject </a></code></td><td><code> struct saml2__SubjectType </code></td><td> saml2.h:802 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__SubjectConfirmation"> _saml2__SubjectConfirmation </a></code></td><td><code> struct saml2__SubjectConfirmationType </code></td><td> saml2.h:805 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__SubjectConfirmationData"> _saml2__SubjectConfirmationData </a></code></td><td><code> struct saml2__SubjectConfirmationDataType </code></td><td> saml2.h:808 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Conditions"> _saml2__Conditions </a></code></td><td><code> struct saml2__ConditionsType </code></td><td> saml2.h:811 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Condition"> _saml2__Condition </a></code></td><td><code> struct saml2__ConditionAbstractType </code></td><td> saml2.h:814 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AudienceRestriction"> _saml2__AudienceRestriction </a></code></td><td><code> struct saml2__AudienceRestrictionType </code></td><td> saml2.h:817 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Audience"> _saml2__Audience </a></code></td><td><code> char * </code></td><td> saml2.h:820 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__OneTimeUse"> _saml2__OneTimeUse </a></code></td><td><code> struct saml2__OneTimeUseType </code></td><td> saml2.h:823 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__ProxyRestriction"> _saml2__ProxyRestriction </a></code></td><td><code> struct saml2__ProxyRestrictionType </code></td><td> saml2.h:826 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Advice"> _saml2__Advice </a></code></td><td><code> struct saml2__AdviceType </code></td><td> saml2.h:829 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__EncryptedAssertion"> _saml2__EncryptedAssertion </a></code></td><td><code> struct saml2__EncryptedElementType </code></td><td> saml2.h:832 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Statement"> _saml2__Statement </a></code></td><td><code> struct saml2__StatementAbstractType </code></td><td> saml2.h:835 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnStatement"> _saml2__AuthnStatement </a></code></td><td><code> struct saml2__AuthnStatementType </code></td><td> saml2.h:838 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__SubjectLocality"> _saml2__SubjectLocality </a></code></td><td><code> struct saml2__SubjectLocalityType </code></td><td> saml2.h:841 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnContext"> _saml2__AuthnContext </a></code></td><td><code> struct saml2__AuthnContextType </code></td><td> saml2.h:844 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnContextClassRef"> _saml2__AuthnContextClassRef </a></code></td><td><code> char * </code></td><td> saml2.h:847 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnContextDeclRef"> _saml2__AuthnContextDeclRef </a></code></td><td><code> char * </code></td><td> saml2.h:850 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnContextDecl"> _saml2__AuthnContextDecl </a></code></td><td><code> char * </code></td><td> saml2.h:853 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_saml2__AuthenticatingAuthority"> _saml2__AuthenticatingAuthority </a></code></td><td><code> char * </code></td><td> saml2.h:856 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthzDecisionStatement"> _saml2__AuthzDecisionStatement </a></code></td><td><code> struct saml2__AuthzDecisionStatementType </code></td><td> saml2.h:859 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Action"> _saml2__Action </a></code></td><td><code> struct saml2__ActionType </code></td><td> saml2.h:862 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Evidence"> _saml2__Evidence </a></code></td><td><code> struct saml2__EvidenceType </code></td><td> saml2.h:865 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AttributeStatement"> _saml2__AttributeStatement </a></code></td><td><code> struct saml2__AttributeStatementType </code></td><td> saml2.h:868 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Attribute"> _saml2__Attribute </a></code></td><td><code> struct saml2__AttributeType </code></td><td> saml2.h:871 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AttributeValue"> _saml2__AttributeValue </a></code></td><td><code> char * </code></td><td> saml2.h:874 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_saml2__EncryptedAttribute"> _saml2__EncryptedAttribute </a></code></td><td><code> struct saml2__EncryptedElementType </code></td><td> saml2.h:877 </td><td> yes </td><td>  </td></tr>
</table>

<a name="_XML"></a>

### `_XML`

This typedef is internally generated and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_QName"></a>

### `_QName`

This typedef is internally generated and is a built-in string type to serialize a list of space-separated qualified names (*`xsd:QName`*), such that XML namespace prefixes are normalized to the XML prefixes defined in the [namespace table](#doc-namespaces) or replaced with "URI": when the namespace table has no prefix entry for the URI

[![][1] To top](#)


<a name="xsd__QName"></a>

### `xsd__QName`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 178, is serialized as XML schema type *`xsd:QName`* and is a built-in string type to serialize a list of space-separated qualified names (*`xsd:QName`*), such that XML namespace prefixes are normalized to the XML prefixes defined in the [namespace table](#doc-namespaces) or replaced with "URI": when the namespace table has no prefix entry for the URI

[![][1] To top](#)


<a name="xsd__byte"></a>

### `xsd__byte`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 189, is serialized as XML schema type *`xsd:byte`* and has underlying base type `char`

[![][1] To top](#)


<a name="xsd__unsignedByte"></a>

### `xsd__unsignedByte`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 192, is serialized as XML schema type *`xsd:unsignedByte`* and has underlying base type `unsigned char`

[![][1] To top](#)


<a name="xsd__ID"></a>

### `xsd__ID`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 195, is serialized as XML schema type *`xsd:ID`* and has underlying base type `std::string`, which should be

- matching regex pattern "[\i-[:]][\c-[:]]*"

[![][1] To top](#)


<a name="xsd__IDREF"></a>

### `xsd__IDREF`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 205, is serialized as XML schema type *`xsd:IDREF`* and has underlying base type `std::string`, which should be

- matching regex pattern "[\i-[:]][\c-[:]]*"

[![][1] To top](#)


<a name="xsd__anyURI"></a>

### `xsd__anyURI`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 222, is serialized as XML schema type *`xsd:anyURI`* and has underlying base type `std::string`

[![][1] To top](#)


<a name="xsd__decimal"></a>

### `xsd__decimal`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 260, is serialized as XML schema type *`xsd:decimal`* and has underlying base type `std::string`, which should be

- matching regex pattern "[-+]?(\d+|\d*\.\d*)"

[![][1] To top](#)


<a name="xsd__duration"></a>

### `xsd__duration`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 277, is serialized as XML schema type *`xsd:duration`* and has underlying base type `std::string`, which should be

- matching regex pattern "[-+]?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?"

[![][1] To top](#)


<a name="ns4__char"></a>

### `ns4__char`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 427, is serialized as XML schema type *`ns4:char`* and has underlying base type `int`

[![][1] To top](#)


<a name="ns4__duration"></a>

### `ns4__duration`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 441, is serialized as XML schema type *`ns4:duration`* and has underlying base type `std::string`, which should be

- matching regex pattern "\-?P(\d*D)?(T(\d*H)?(\d*M)?(\d*(\.\d*)?S)?)?"

[![][1] To top](#)


<a name="ns4__guid"></a>

### `ns4__guid`

This typedef is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 454, is serialized as XML schema type *`ns4:guid`* and has underlying base type `std::string`, which should be

- matching regex pattern "[\da-fA-F]{8}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{12}"

[![][1] To top](#)


<a name="_ds__SignatureValue"></a>

### `_ds__SignatureValue`

This typedef is declared in [ds.h](ds.h) at line 48, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_ds__Signature"></a>

### `_ds__Signature`

This typedef is declared in [ds.h](ds.h) at line 54, is serialized as XML schema type *``* and has underlying base type `struct ds__SignatureType`

[![][1] To top](#)


<a name="_ds__Transform"></a>

### `_ds__Transform`

This typedef is declared in [ds.h](ds.h) at line 80, is serialized as XML schema type *``* and has underlying base type `struct ds__TransformType`

[![][1] To top](#)


<a name="_ds__KeyInfo"></a>

### `_ds__KeyInfo`

This typedef is declared in [ds.h](ds.h) at line 94, is serialized as XML schema type *``* and has underlying base type `struct ds__KeyInfoType`

[![][1] To top](#)


<a name="wsc__FaultCodeOpenEnumType"></a>

### `wsc__FaultCodeOpenEnumType`

This typedef is declared in [wsc.h](wsc.h) at line 58, is serialized as XML schema type *`wsc:FaultCodeOpenEnumType`* and has underlying base type `char *`

[![][1] To top](#)


<a name="xsd__dateTime"></a>

### `xsd__dateTime`

This typedef is declared in [custom/struct_timeval.h](custom/struct_timeval.h) at line 77, is serialized as XML schema type *`xsd:dateTime`* and has underlying base type `struct timeval`

[![][1] To top](#)


<a name="_saml1__AssertionIDReference"></a>

### `_saml1__AssertionIDReference`

This typedef is declared in [saml1.h](saml1.h) at line 628, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml1__Assertion"></a>

### `_saml1__Assertion`

This typedef is declared in [saml1.h](saml1.h) at line 631, is serialized as XML schema type *``* and has underlying base type `struct saml1__AssertionType`

[![][1] To top](#)


<a name="_saml1__Conditions"></a>

### `_saml1__Conditions`

This typedef is declared in [saml1.h](saml1.h) at line 634, is serialized as XML schema type *``* and has underlying base type `struct saml1__ConditionsType`

[![][1] To top](#)


<a name="_saml1__Condition"></a>

### `_saml1__Condition`

This typedef is declared in [saml1.h](saml1.h) at line 637, is serialized as XML schema type *``* and has underlying base type `struct saml1__ConditionAbstractType`

[![][1] To top](#)


<a name="_saml1__AudienceRestrictionCondition"></a>

### `_saml1__AudienceRestrictionCondition`

This typedef is declared in [saml1.h](saml1.h) at line 640, is serialized as XML schema type *``* and has underlying base type `struct saml1__AudienceRestrictionConditionType`

[![][1] To top](#)


<a name="_saml1__Audience"></a>

### `_saml1__Audience`

This typedef is declared in [saml1.h](saml1.h) at line 643, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml1__DoNotCacheCondition"></a>

### `_saml1__DoNotCacheCondition`

This typedef is declared in [saml1.h](saml1.h) at line 646, is serialized as XML schema type *``* and has underlying base type `struct saml1__DoNotCacheConditionType`

[![][1] To top](#)


<a name="_saml1__Advice"></a>

### `_saml1__Advice`

This typedef is declared in [saml1.h](saml1.h) at line 649, is serialized as XML schema type *``* and has underlying base type `struct saml1__AdviceType`

[![][1] To top](#)


<a name="_saml1__Statement"></a>

### `_saml1__Statement`

This typedef is declared in [saml1.h](saml1.h) at line 652, is serialized as XML schema type *``* and has underlying base type `struct saml1__StatementAbstractType`

[![][1] To top](#)


<a name="_saml1__SubjectStatement"></a>

### `_saml1__SubjectStatement`

This typedef is declared in [saml1.h](saml1.h) at line 655, is serialized as XML schema type *``* and has underlying base type `struct saml1__SubjectStatementAbstractType`

[![][1] To top](#)


<a name="_saml1__Subject"></a>

### `_saml1__Subject`

This typedef is declared in [saml1.h](saml1.h) at line 658, is serialized as XML schema type *``* and has underlying base type `struct saml1__SubjectType`

[![][1] To top](#)


<a name="_saml1__NameIdentifier"></a>

### `_saml1__NameIdentifier`

This typedef is declared in [saml1.h](saml1.h) at line 661, is serialized as XML schema type *``* and has underlying base type `struct saml1__NameIdentifierType`

[![][1] To top](#)


<a name="_saml1__SubjectConfirmation"></a>

### `_saml1__SubjectConfirmation`

This typedef is declared in [saml1.h](saml1.h) at line 664, is serialized as XML schema type *``* and has underlying base type `struct saml1__SubjectConfirmationType`

[![][1] To top](#)


<a name="_saml1__SubjectConfirmationData"></a>

### `_saml1__SubjectConfirmationData`

This typedef is declared in [saml1.h](saml1.h) at line 667, is serialized as XML schema type *``* and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_saml1__ConfirmationMethod"></a>

### `_saml1__ConfirmationMethod`

This typedef is declared in [saml1.h](saml1.h) at line 670, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml1__AuthenticationStatement"></a>

### `_saml1__AuthenticationStatement`

This typedef is declared in [saml1.h](saml1.h) at line 673, is serialized as XML schema type *``* and has underlying base type `struct saml1__AuthenticationStatementType`

[![][1] To top](#)


<a name="_saml1__SubjectLocality"></a>

### `_saml1__SubjectLocality`

This typedef is declared in [saml1.h](saml1.h) at line 676, is serialized as XML schema type *``* and has underlying base type `struct saml1__SubjectLocalityType`

[![][1] To top](#)


<a name="_saml1__AuthorityBinding"></a>

### `_saml1__AuthorityBinding`

This typedef is declared in [saml1.h](saml1.h) at line 679, is serialized as XML schema type *``* and has underlying base type `struct saml1__AuthorityBindingType`

[![][1] To top](#)


<a name="_saml1__AuthorizationDecisionStatement"></a>

### `_saml1__AuthorizationDecisionStatement`

This typedef is declared in [saml1.h](saml1.h) at line 682, is serialized as XML schema type *``* and has underlying base type `struct saml1__AuthorizationDecisionStatementType`

[![][1] To top](#)


<a name="_saml1__Action"></a>

### `_saml1__Action`

This typedef is declared in [saml1.h](saml1.h) at line 685, is serialized as XML schema type *``* and has underlying base type `struct saml1__ActionType`

[![][1] To top](#)


<a name="_saml1__Evidence"></a>

### `_saml1__Evidence`

This typedef is declared in [saml1.h](saml1.h) at line 688, is serialized as XML schema type *``* and has underlying base type `struct saml1__EvidenceType`

[![][1] To top](#)


<a name="_saml1__AttributeStatement"></a>

### `_saml1__AttributeStatement`

This typedef is declared in [saml1.h](saml1.h) at line 691, is serialized as XML schema type *``* and has underlying base type `struct saml1__AttributeStatementType`

[![][1] To top](#)


<a name="_saml1__AttributeDesignator"></a>

### `_saml1__AttributeDesignator`

This typedef is declared in [saml1.h](saml1.h) at line 694, is serialized as XML schema type *``* and has underlying base type `struct saml1__AttributeDesignatorType`

[![][1] To top](#)


<a name="_saml1__Attribute"></a>

### `_saml1__Attribute`

This typedef is declared in [saml1.h](saml1.h) at line 697, is serialized as XML schema type *``* and has underlying base type `struct saml1__AttributeType`

[![][1] To top](#)


<a name="_saml1__AttributeValue"></a>

### `_saml1__AttributeValue`

This typedef is declared in [saml1.h](saml1.h) at line 700, is serialized as XML schema type *``* and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_saml2__BaseID"></a>

### `_saml2__BaseID`

This typedef is declared in [saml2.h](saml2.h) at line 781, is serialized as XML schema type *``* and has underlying base type `struct saml2__BaseIDAbstractType`

[![][1] To top](#)


<a name="_saml2__NameID"></a>

### `_saml2__NameID`

This typedef is declared in [saml2.h](saml2.h) at line 784, is serialized as XML schema type *``* and has underlying base type `struct saml2__NameIDType`

[![][1] To top](#)


<a name="_saml2__EncryptedID"></a>

### `_saml2__EncryptedID`

This typedef is declared in [saml2.h](saml2.h) at line 787, is serialized as XML schema type *``* and has underlying base type `struct saml2__EncryptedElementType`

[![][1] To top](#)


<a name="_saml2__Issuer"></a>

### `_saml2__Issuer`

This typedef is declared in [saml2.h](saml2.h) at line 790, is serialized as XML schema type *``* and has underlying base type `struct saml2__NameIDType`

[![][1] To top](#)


<a name="_saml2__AssertionIDRef"></a>

### `_saml2__AssertionIDRef`

This typedef is declared in [saml2.h](saml2.h) at line 793, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml2__AssertionURIRef"></a>

### `_saml2__AssertionURIRef`

This typedef is declared in [saml2.h](saml2.h) at line 796, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml2__Assertion"></a>

### `_saml2__Assertion`

This typedef is declared in [saml2.h](saml2.h) at line 799, is serialized as XML schema type *``* and has underlying base type `struct saml2__AssertionType`

[![][1] To top](#)


<a name="_saml2__Subject"></a>

### `_saml2__Subject`

This typedef is declared in [saml2.h](saml2.h) at line 802, is serialized as XML schema type *``* and has underlying base type `struct saml2__SubjectType`

[![][1] To top](#)


<a name="_saml2__SubjectConfirmation"></a>

### `_saml2__SubjectConfirmation`

This typedef is declared in [saml2.h](saml2.h) at line 805, is serialized as XML schema type *``* and has underlying base type `struct saml2__SubjectConfirmationType`

[![][1] To top](#)


<a name="_saml2__SubjectConfirmationData"></a>

### `_saml2__SubjectConfirmationData`

This typedef is declared in [saml2.h](saml2.h) at line 808, is serialized as XML schema type *``* and has underlying base type `struct saml2__SubjectConfirmationDataType`

[![][1] To top](#)


<a name="_saml2__Conditions"></a>

### `_saml2__Conditions`

This typedef is declared in [saml2.h](saml2.h) at line 811, is serialized as XML schema type *``* and has underlying base type `struct saml2__ConditionsType`

[![][1] To top](#)


<a name="_saml2__Condition"></a>

### `_saml2__Condition`

This typedef is declared in [saml2.h](saml2.h) at line 814, is serialized as XML schema type *``* and has underlying base type `struct saml2__ConditionAbstractType`

[![][1] To top](#)


<a name="_saml2__AudienceRestriction"></a>

### `_saml2__AudienceRestriction`

This typedef is declared in [saml2.h](saml2.h) at line 817, is serialized as XML schema type *``* and has underlying base type `struct saml2__AudienceRestrictionType`

[![][1] To top](#)


<a name="_saml2__Audience"></a>

### `_saml2__Audience`

This typedef is declared in [saml2.h](saml2.h) at line 820, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml2__OneTimeUse"></a>

### `_saml2__OneTimeUse`

This typedef is declared in [saml2.h](saml2.h) at line 823, is serialized as XML schema type *``* and has underlying base type `struct saml2__OneTimeUseType`

[![][1] To top](#)


<a name="_saml2__ProxyRestriction"></a>

### `_saml2__ProxyRestriction`

This typedef is declared in [saml2.h](saml2.h) at line 826, is serialized as XML schema type *``* and has underlying base type `struct saml2__ProxyRestrictionType`

[![][1] To top](#)


<a name="_saml2__Advice"></a>

### `_saml2__Advice`

This typedef is declared in [saml2.h](saml2.h) at line 829, is serialized as XML schema type *``* and has underlying base type `struct saml2__AdviceType`

[![][1] To top](#)


<a name="_saml2__EncryptedAssertion"></a>

### `_saml2__EncryptedAssertion`

This typedef is declared in [saml2.h](saml2.h) at line 832, is serialized as XML schema type *``* and has underlying base type `struct saml2__EncryptedElementType`

[![][1] To top](#)


<a name="_saml2__Statement"></a>

### `_saml2__Statement`

This typedef is declared in [saml2.h](saml2.h) at line 835, is serialized as XML schema type *``* and has underlying base type `struct saml2__StatementAbstractType`

[![][1] To top](#)


<a name="_saml2__AuthnStatement"></a>

### `_saml2__AuthnStatement`

This typedef is declared in [saml2.h](saml2.h) at line 838, is serialized as XML schema type *``* and has underlying base type `struct saml2__AuthnStatementType`

[![][1] To top](#)


<a name="_saml2__SubjectLocality"></a>

### `_saml2__SubjectLocality`

This typedef is declared in [saml2.h](saml2.h) at line 841, is serialized as XML schema type *``* and has underlying base type `struct saml2__SubjectLocalityType`

[![][1] To top](#)


<a name="_saml2__AuthnContext"></a>

### `_saml2__AuthnContext`

This typedef is declared in [saml2.h](saml2.h) at line 844, is serialized as XML schema type *``* and has underlying base type `struct saml2__AuthnContextType`

[![][1] To top](#)


<a name="_saml2__AuthnContextClassRef"></a>

### `_saml2__AuthnContextClassRef`

This typedef is declared in [saml2.h](saml2.h) at line 847, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml2__AuthnContextDeclRef"></a>

### `_saml2__AuthnContextDeclRef`

This typedef is declared in [saml2.h](saml2.h) at line 850, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml2__AuthnContextDecl"></a>

### `_saml2__AuthnContextDecl`

This typedef is declared in [saml2.h](saml2.h) at line 853, is serialized as XML schema type *``* and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_saml2__AuthenticatingAuthority"></a>

### `_saml2__AuthenticatingAuthority`

This typedef is declared in [saml2.h](saml2.h) at line 856, is serialized as XML schema type *``* and has underlying base type `char *`

[![][1] To top](#)


<a name="_saml2__AuthzDecisionStatement"></a>

### `_saml2__AuthzDecisionStatement`

This typedef is declared in [saml2.h](saml2.h) at line 859, is serialized as XML schema type *``* and has underlying base type `struct saml2__AuthzDecisionStatementType`

[![][1] To top](#)


<a name="_saml2__Action"></a>

### `_saml2__Action`

This typedef is declared in [saml2.h](saml2.h) at line 862, is serialized as XML schema type *``* and has underlying base type `struct saml2__ActionType`

[![][1] To top](#)


<a name="_saml2__Evidence"></a>

### `_saml2__Evidence`

This typedef is declared in [saml2.h](saml2.h) at line 865, is serialized as XML schema type *``* and has underlying base type `struct saml2__EvidenceType`

[![][1] To top](#)


<a name="_saml2__AttributeStatement"></a>

### `_saml2__AttributeStatement`

This typedef is declared in [saml2.h](saml2.h) at line 868, is serialized as XML schema type *``* and has underlying base type `struct saml2__AttributeStatementType`

[![][1] To top](#)


<a name="_saml2__Attribute"></a>

### `_saml2__Attribute`

This typedef is declared in [saml2.h](saml2.h) at line 871, is serialized as XML schema type *``* and has underlying base type `struct saml2__AttributeType`

[![][1] To top](#)


<a name="_saml2__AttributeValue"></a>

### `_saml2__AttributeValue`

This typedef is declared in [saml2.h](saml2.h) at line 874, is serialized as XML schema type *``* and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_saml2__EncryptedAttribute"></a>

### `_saml2__EncryptedAttribute`

This typedef is declared in [saml2.h](saml2.h) at line 877, is serialized as XML schema type *``* and has underlying base type `struct saml2__EncryptedElementType`

[![][1] To top](#)


## Summary of Serializable Types {#doc-types}

Each serializable C/C++ *Type* with binding name *Name* has a set of auto-generated functions:

- `Type *soap_new_Name(struct soap*)` managed allocation and default initialization
- `Type *soap_new_Name(struct soap*, int n)` managed allocation and default initialization of an array `Type[n]`
- `void soap_default_Name(struct soap*, Type*)` initialize or reset non-class *Type* to default)
- `void Type::soap_default(struct soap*)` non-volatile class *Type* reset to default
- `Type *soap_dup_Name(struct soap*, Type *dst, const Type *src)` requires soapcpp2 option -Ec, deep copy `src` to `dst` managed by context or unmanaged when context is NULL, returning `dst` (if `dst` is NULL then allocates `dst` copy)
- `void soap_del_Name(struct soap*, Type*)` requires soapcpp2 option -Ec, deep delete *Type* which must be unmanaged
- `const char *soap_Name2s(struct soap*, Type)` primitive *Type* only, returns string-converted *Type* in temporary string buffer
- `int soap_s2Name(struct soap*, const char*, Type*)` primitive *Type* only, convert string to value, returns `SOAP_OK` or error code
- `int soap_write_Name(struct soap*, const Type*)` serialize *Type* to XML, returns `SOAP_OK` or error code
- `int soap_PUT_Name(struct soap*, const char *URL, const Type*)` REST PUT *Type* in XML, returns `SOAP_OK` or error code
- `int soap_PATCH_Name(struct soap*, const char *URL, const Type*)` REST PATCH *Type* in XML, returns `SOAP_OK` or error code
- `int soap_POST_send_Name(struct soap*, const char *URL, const Type*)` REST POST send *Type* in XML (MUST be followed by a `soap_POST_recv_OtherName`), returns `SOAP_OK` or error code
- `int soap_read_Name(struct soap*, Type*)` deserialize *Type* from XML, returns `SOAP_OK` or error code
- `int soap_GET_Name(struct soap*, const char *URL, Type*)` REST GET *Type* from XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_Name(struct soap*, Type*)` REST GET *Type* from XML (after a `soap_POST_send_OtherName`), returns `SOAP_OK` or error code
- `(Type *)soap_malloc(struct soap*, sizeof(Type))` raw managed allocation of primitive *Type* (types that are not structs or classes) without initialization
- `const char *soap_strdup(struct soap*, const char*)` managed allocation and duplication of string
- `const wchar_t *soap_wstrdup(struct soap*, const wchar_t*)` managed allocation and duplication of wide string

Each *Type* also has a unique type id `SOAP_TYPE_<Type>` that you can use to serialize `void*` in a struct/class by setting the `int __type` member to this type id. The unique type id is also used to distinguish derived class instances from base class instances by calling their `virtual soap_type()` methods that return this type id.

From the toolkit documentation:

- Set `soap->sendfd = fd` to serialize to an `int fd` file descriptor
- Set `soap->os = &os` to serialize to a `std::ostream os`
- Set `soap->recvfd = fd` to deserialize from an `int fd` file descriptor
- Set `soap->is = &is` to deserialize from a `std::istream`
- All managed allocated data is deleted by `soap_destroy(soap)` followed by `soap_end(soap)` with context `soap`

The table below lists the serializable types by *Type*, binding *Name*, *Kind*, and the XSD data binding type and/or element.  Pointers, arrays, and containers of these types are also serializable:

<table class="doxtable">
<tr><th> C/C++ Type </th><th> Name </th><th> Kind </th><th> XML schema name </th></tr>
<tr><td><code><a href="#xsd__byte"> xsd__byte </a></code></td><td><code> xsd__byte </code></td><td> char </td><td> xsd:byte </td></tr>
<tr><td><code> char </code></td><td><code> byte </code></td><td> char </td><td> xsd:byte </td></tr>
<tr><td><code> short </code></td><td><code> short </code></td><td> short </td><td> xsd:short </td></tr>
<tr><td><code><a href="#ns4__char"> ns4__char </a></code></td><td><code> ns4__char </code></td><td> int </td><td> ns4:char </td></tr>
<tr><td><code> int </code></td><td><code> int </code></td><td> int </td><td> xsd:int </td></tr>
<tr><td><code> LONG64 </code></td><td><code> LONG64 </code></td><td> LONG64 </td><td> xsd:long </td></tr>
<tr><td><code> float </code></td><td><code> float </code></td><td> float </td><td> xsd:float </td></tr>
<tr><td><code> double </code></td><td><code> double </code></td><td> double </td><td> xsd:double </td></tr>
<tr><td><code><a href="#xsd__unsignedByte"> xsd__unsignedByte </a></code></td><td><code> xsd__unsignedByte </code></td><td> unsigned char </td><td> xsd:unsignedByte </td></tr>
<tr><td><code> unsigned char </code></td><td><code> unsignedByte </code></td><td> unsigned char </td><td> xsd:unsignedByte </td></tr>
<tr><td><code> unsigned short </code></td><td><code> unsignedShort </code></td><td> unsigned short </td><td> xsd:unsignedShort </td></tr>
<tr><td><code> unsigned int </code></td><td><code> unsignedInt </code></td><td> unsigned int </td><td> xsd:unsignedInt </td></tr>
<tr><td><code> ULONG64 </code></td><td><code> ULONG64 </code></td><td> ULONG64 </td><td> xsd:unsignedLong </td></tr>
<tr><td><code> time_t </code></td><td><code> dateTime </code></td><td> time_t </td><td> xsd:dateTime </td></tr>
<tr><td><code><a href="#saml2__DecisionType"> enum saml2__DecisionType </a></code></td><td><code> saml2__DecisionType </code></td><td> enum </td><td> saml2:DecisionType </td></tr>
<tr><td><code><a href="#saml1__DecisionType"> enum saml1__DecisionType </a></code></td><td><code> saml1__DecisionType </code></td><td> enum </td><td> saml1:DecisionType </td></tr>
<tr><td><code><a href="#wsc__FaultCodeType"> enum wsc__FaultCodeType </a></code></td><td><code> wsc__FaultCodeType </code></td><td> enum </td><td> wsc:FaultCodeType </td></tr>
<tr><td><code><a href="#wsse__FaultcodeEnum"> enum wsse__FaultcodeEnum </a></code></td><td><code> wsse__FaultcodeEnum </code></td><td> enum </td><td> wsse:FaultcodeEnum </td></tr>
<tr><td><code><a href="#wsu__tTimestampFault"> enum wsu__tTimestampFault </a></code></td><td><code> wsu__tTimestampFault </code></td><td> enum </td><td> wsu:tTimestampFault </td></tr>
<tr><td><code><a href="#bool"> bool </a></code></td><td><code> bool </code></td><td> bool </td><td> xsd:boolean </td></tr>
<tr><td><code><a href="#ns4__guid__"> ns4__guid__ </a></code></td><td><code> ns4__guid__ </code></td><td> class </td><td> ns4:guid </td></tr>
<tr><td><code> ns4__guid </code></td><td><code> ns4__guid </code></td><td> std::string </td><td> ns4:guid </td></tr>
<tr><td><code><a href="#ns4__duration__"> ns4__duration__ </a></code></td><td><code> ns4__duration__ </code></td><td> class </td><td> ns4:duration </td></tr>
<tr><td><code> ns4__duration </code></td><td><code> ns4__duration </code></td><td> std::string </td><td> ns4:duration </td></tr>
<tr><td><code><a href="#ns4__char__"> ns4__char__ </a></code></td><td><code> ns4__char__ </code></td><td> class </td><td> ns4:char </td></tr>
<tr><td><code><a href="#ns5__MultipleSignRequest"> ns5__MultipleSignRequest </a></code></td><td><code> ns5__MultipleSignRequest </code></td><td> class </td><td> ns5:MultipleSignRequest </td></tr>
<tr><td><code><a href="#ns5__HashStructure"> ns5__HashStructure </a></code></td><td><code> ns5__HashStructure </code></td><td> class </td><td> ns5:HashStructure </td></tr>
<tr><td><code><a href="#ns5__ArrayOfHashStructure"> ns5__ArrayOfHashStructure </a></code></td><td><code> ns5__ArrayOfHashStructure </code></td><td> class </td><td> ns5:ArrayOfHashStructure </td></tr>
<tr><td><code><a href="#ns5__SignResponse"> ns5__SignResponse </a></code></td><td><code> ns5__SignResponse </code></td><td> class </td><td> ns5:SignResponse </td></tr>
<tr><td><code><a href="#ns5__SignStatus"> ns5__SignStatus </a></code></td><td><code> ns5__SignStatus </code></td><td> class </td><td> ns5:SignStatus </td></tr>
<tr><td><code><a href="#ns5__SignRequest"> ns5__SignRequest </a></code></td><td><code> ns5__SignRequest </code></td><td> class </td><td> ns5:SignRequest </td></tr>
<tr><td><code><a href="#_ns3__GetCertificateWithPinResponse"> _ns3__GetCertificateWithPinResponse </a></code></td><td><code> _ns3__GetCertificateWithPinResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__GetCertificateWithPin"> _ns3__GetCertificateWithPin </a></code></td><td><code> _ns3__GetCertificateWithPin </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__ForceSMSResponse"> _ns3__ForceSMSResponse </a></code></td><td><code> _ns3__ForceSMSResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__ForceSMS"> _ns3__ForceSMS </a></code></td><td><code> _ns3__ForceSMS </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__CCMovelMultipleSignResponse"> _ns3__CCMovelMultipleSignResponse </a></code></td><td><code> _ns3__CCMovelMultipleSignResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__CCMovelMultipleSign"> _ns3__CCMovelMultipleSign </a></code></td><td><code> _ns3__CCMovelMultipleSign </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__ValidateOtpResponse"> _ns3__ValidateOtpResponse </a></code></td><td><code> _ns3__ValidateOtpResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__ValidateOtp"> _ns3__ValidateOtp </a></code></td><td><code> _ns3__ValidateOtp </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__GetCertificateResponse"> _ns3__GetCertificateResponse </a></code></td><td><code> _ns3__GetCertificateResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__GetCertificate"> _ns3__GetCertificate </a></code></td><td><code> _ns3__GetCertificate </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__CCMovelSignResponse"> _ns3__CCMovelSignResponse </a></code></td><td><code> _ns3__CCMovelSignResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns3__CCMovelSign"> _ns3__CCMovelSign </a></code></td><td><code> _ns3__CCMovelSign </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#xsd__unsignedShort_"> xsd__unsignedShort_ </a></code></td><td><code> xsd__unsignedShort_ </code></td><td> class </td><td> xsd:unsignedShort </td></tr>
<tr><td><code><a href="#xsd__unsignedLong_"> xsd__unsignedLong_ </a></code></td><td><code> xsd__unsignedLong_ </code></td><td> class </td><td> xsd:unsignedLong </td></tr>
<tr><td><code><a href="#xsd__unsignedInt_"> xsd__unsignedInt_ </a></code></td><td><code> xsd__unsignedInt_ </code></td><td> class </td><td> xsd:unsignedInt </td></tr>
<tr><td><code><a href="#xsd__unsignedByte__"> xsd__unsignedByte__ </a></code></td><td><code> xsd__unsignedByte__ </code></td><td> class </td><td> xsd:unsignedByte </td></tr>
<tr><td><code><a href="#xsd__string_"> xsd__string_ </a></code></td><td><code> xsd__string_ </code></td><td> class </td><td> xsd:string </td></tr>
<tr><td><code><a href="#xsd__short_"> xsd__short_ </a></code></td><td><code> xsd__short_ </code></td><td> class </td><td> xsd:short </td></tr>
<tr><td><code><a href="#xsd__long_"> xsd__long_ </a></code></td><td><code> xsd__long_ </code></td><td> class </td><td> xsd:long </td></tr>
<tr><td><code><a href="#xsd__int_"> xsd__int_ </a></code></td><td><code> xsd__int_ </code></td><td> class </td><td> xsd:int </td></tr>
<tr><td><code><a href="#xsd__float_"> xsd__float_ </a></code></td><td><code> xsd__float_ </code></td><td> class </td><td> xsd:float </td></tr>
<tr><td><code><a href="#xsd__duration__"> xsd__duration__ </a></code></td><td><code> xsd__duration__ </code></td><td> class </td><td> xsd:duration </td></tr>
<tr><td><code> xsd__duration </code></td><td><code> xsd__duration </code></td><td> std::string </td><td> xsd:duration </td></tr>
<tr><td><code><a href="#xsd__double_"> xsd__double_ </a></code></td><td><code> xsd__double_ </code></td><td> class </td><td> xsd:double </td></tr>
<tr><td><code><a href="#xsd__decimal__"> xsd__decimal__ </a></code></td><td><code> xsd__decimal__ </code></td><td> class </td><td> xsd:decimal </td></tr>
<tr><td><code> xsd__decimal </code></td><td><code> xsd__decimal </code></td><td> std::string </td><td> xsd:decimal </td></tr>
<tr><td><code><a href="#xsd__dateTime_"> xsd__dateTime_ </a></code></td><td><code> xsd__dateTime_ </code></td><td> class </td><td> xsd:dateTime </td></tr>
<tr><td><code><a href="#xsd__byte__"> xsd__byte__ </a></code></td><td><code> xsd__byte__ </code></td><td> class </td><td> xsd:byte </td></tr>
<tr><td><code><a href="#xsd__boolean_"> xsd__boolean_ </a></code></td><td><code> xsd__boolean_ </code></td><td> class </td><td> xsd:boolean </td></tr>
<tr><td><code><a href="#xsd__base64Binary__"> xsd__base64Binary__ </a></code></td><td><code> xsd__base64Binary__ </code></td><td> class </td><td> xsd:base64Binary </td></tr>
<tr><td><code><a href="#xsd__anyURI__"> xsd__anyURI__ </a></code></td><td><code> xsd__anyURI__ </code></td><td> class </td><td> xsd:anyURI </td></tr>
<tr><td><code> xsd__anyURI </code></td><td><code> xsd__anyURI </code></td><td> std::string </td><td> xsd:anyURI </td></tr>
<tr><td><code><a href="#xsd__QName__"> xsd__QName__ </a></code></td><td><code> xsd__QName__ </code></td><td> class </td><td> xsd:QName </td></tr>
<tr><td><code><a href="#xsd__IDREF__"> xsd__IDREF__ </a></code></td><td><code> xsd__IDREF__ </code></td><td> class </td><td> xsd:IDREF </td></tr>
<tr><td><code> xsd__IDREF </code></td><td><code> xsd__IDREF </code></td><td> std::string </td><td> xsd:IDREF </td></tr>
<tr><td><code><a href="#xsd__ID__"> xsd__ID__ </a></code></td><td><code> xsd__ID__ </code></td><td> class </td><td> xsd:ID </td></tr>
<tr><td><code> xsd__ID </code></td><td><code> xsd__ID </code></td><td> std::string </td><td> xsd:ID </td></tr>
<tr><td><code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code></td><td><code> xsd__base64Binary </code></td><td> base64 binary or attachment </td><td> xsd:base64Binary </td></tr>
<tr><td><code> xsd__QName </code></td><td><code> xsd__QName </code></td><td> std::string </td><td> xsd:QName </td></tr>
<tr><td><code> std::string </code></td><td><code> std__string </code></td><td> std::string </td><td> xsd:string </td></tr>
<tr><td><code><a href="#xsd__anyType"> xsd__anyType </a></code></td><td><code> xsd__anyType </code></td><td> class </td><td> xsd:anyType </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td><code> SOAP_ENV__Fault </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td><code> SOAP_ENV__Reason </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td><code> SOAP_ENV__Detail </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td><code> SOAP_ENV__Code </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td><code> SOAP_ENV__Header </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_wsse__Security"> struct _wsse__Security </a></code></td><td><code> _wsse__Security </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__EncryptedAttribute"> _saml2__EncryptedAttribute </a></code></td><td><code> _saml2__EncryptedAttribute </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Attribute"> _saml2__Attribute </a></code></td><td><code> _saml2__Attribute </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AttributeStatement"> _saml2__AttributeStatement </a></code></td><td><code> _saml2__AttributeStatement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Evidence"> _saml2__Evidence </a></code></td><td><code> _saml2__Evidence </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Action"> _saml2__Action </a></code></td><td><code> _saml2__Action </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthzDecisionStatement"> _saml2__AuthzDecisionStatement </a></code></td><td><code> _saml2__AuthzDecisionStatement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnContext"> _saml2__AuthnContext </a></code></td><td><code> _saml2__AuthnContext </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__SubjectLocality"> _saml2__SubjectLocality </a></code></td><td><code> _saml2__SubjectLocality </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnStatement"> _saml2__AuthnStatement </a></code></td><td><code> _saml2__AuthnStatement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Statement"> _saml2__Statement </a></code></td><td><code> _saml2__Statement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__EncryptedAssertion"> _saml2__EncryptedAssertion </a></code></td><td><code> _saml2__EncryptedAssertion </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Advice"> _saml2__Advice </a></code></td><td><code> _saml2__Advice </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__ProxyRestriction"> _saml2__ProxyRestriction </a></code></td><td><code> _saml2__ProxyRestriction </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__OneTimeUse"> _saml2__OneTimeUse </a></code></td><td><code> _saml2__OneTimeUse </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AudienceRestriction"> _saml2__AudienceRestriction </a></code></td><td><code> _saml2__AudienceRestriction </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Condition"> _saml2__Condition </a></code></td><td><code> _saml2__Condition </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Conditions"> _saml2__Conditions </a></code></td><td><code> _saml2__Conditions </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__SubjectConfirmationData"> _saml2__SubjectConfirmationData </a></code></td><td><code> _saml2__SubjectConfirmationData </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__SubjectConfirmation"> _saml2__SubjectConfirmation </a></code></td><td><code> _saml2__SubjectConfirmation </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Subject"> _saml2__Subject </a></code></td><td><code> _saml2__Subject </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Assertion"> _saml2__Assertion </a></code></td><td><code> _saml2__Assertion </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Issuer"> _saml2__Issuer </a></code></td><td><code> _saml2__Issuer </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__EncryptedID"> _saml2__EncryptedID </a></code></td><td><code> _saml2__EncryptedID </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__NameID"> _saml2__NameID </a></code></td><td><code> _saml2__NameID </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__BaseID"> _saml2__BaseID </a></code></td><td><code> _saml2__BaseID </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#saml2__AttributeType"> struct saml2__AttributeType </a></code></td><td><code> saml2__AttributeType </code></td><td> struct </td><td> saml2:AttributeType </td></tr>
<tr><td><code><a href="#saml2__AttributeStatementType"> struct saml2__AttributeStatementType </a></code></td><td><code> saml2__AttributeStatementType </code></td><td> struct </td><td> saml2:AttributeStatementType </td></tr>
<tr><td><code><a href="#saml2__EvidenceType"> struct saml2__EvidenceType </a></code></td><td><code> saml2__EvidenceType </code></td><td> struct </td><td> saml2:EvidenceType </td></tr>
<tr><td><code><a href="#saml2__ActionType"> struct saml2__ActionType </a></code></td><td><code> saml2__ActionType </code></td><td> struct </td><td> saml2:ActionType </td></tr>
<tr><td><code><a href="#saml2__AuthzDecisionStatementType"> struct saml2__AuthzDecisionStatementType </a></code></td><td><code> saml2__AuthzDecisionStatementType </code></td><td> struct </td><td> saml2:AuthzDecisionStatementType </td></tr>
<tr><td><code><a href="#saml2__AuthnContextType"> struct saml2__AuthnContextType </a></code></td><td><code> saml2__AuthnContextType </code></td><td> struct </td><td> saml2:AuthnContextType </td></tr>
<tr><td><code><a href="#saml2__SubjectLocalityType"> struct saml2__SubjectLocalityType </a></code></td><td><code> saml2__SubjectLocalityType </code></td><td> struct </td><td> saml2:SubjectLocalityType </td></tr>
<tr><td><code><a href="#saml2__AuthnStatementType"> struct saml2__AuthnStatementType </a></code></td><td><code> saml2__AuthnStatementType </code></td><td> struct </td><td> saml2:AuthnStatementType </td></tr>
<tr><td><code><a href="#saml2__StatementAbstractType"> struct saml2__StatementAbstractType </a></code></td><td><code> saml2__StatementAbstractType </code></td><td> struct </td><td> saml2:StatementAbstractType </td></tr>
<tr><td><code><a href="#saml2__AdviceType"> struct saml2__AdviceType </a></code></td><td><code> saml2__AdviceType </code></td><td> struct </td><td> saml2:AdviceType </td></tr>
<tr><td><code><a href="#saml2__ProxyRestrictionType"> struct saml2__ProxyRestrictionType </a></code></td><td><code> saml2__ProxyRestrictionType </code></td><td> struct </td><td> saml2:ProxyRestrictionType </td></tr>
<tr><td><code><a href="#saml2__OneTimeUseType"> struct saml2__OneTimeUseType </a></code></td><td><code> saml2__OneTimeUseType </code></td><td> struct </td><td> saml2:OneTimeUseType </td></tr>
<tr><td><code><a href="#saml2__AudienceRestrictionType"> struct saml2__AudienceRestrictionType </a></code></td><td><code> saml2__AudienceRestrictionType </code></td><td> struct </td><td> saml2:AudienceRestrictionType </td></tr>
<tr><td><code><a href="#saml2__ConditionAbstractType"> struct saml2__ConditionAbstractType </a></code></td><td><code> saml2__ConditionAbstractType </code></td><td> struct </td><td> saml2:ConditionAbstractType </td></tr>
<tr><td><code><a href="#saml2__ConditionsType"> struct saml2__ConditionsType </a></code></td><td><code> saml2__ConditionsType </code></td><td> struct </td><td> saml2:ConditionsType </td></tr>
<tr><td><code><a href="#saml2__KeyInfoConfirmationDataType"> struct saml2__KeyInfoConfirmationDataType </a></code></td><td><code> saml2__KeyInfoConfirmationDataType </code></td><td> struct </td><td> saml2:KeyInfoConfirmationDataType </td></tr>
<tr><td><code><a href="#saml2__SubjectConfirmationDataType"> struct saml2__SubjectConfirmationDataType </a></code></td><td><code> saml2__SubjectConfirmationDataType </code></td><td> struct </td><td> saml2:SubjectConfirmationDataType </td></tr>
<tr><td><code><a href="#saml2__SubjectConfirmationType"> struct saml2__SubjectConfirmationType </a></code></td><td><code> saml2__SubjectConfirmationType </code></td><td> struct </td><td> saml2:SubjectConfirmationType </td></tr>
<tr><td><code><a href="#saml2__SubjectType"> struct saml2__SubjectType </a></code></td><td><code> saml2__SubjectType </code></td><td> struct </td><td> saml2:SubjectType </td></tr>
<tr><td><code><a href="#saml2__AssertionType"> struct saml2__AssertionType </a></code></td><td><code> saml2__AssertionType </code></td><td> struct </td><td> saml2:AssertionType </td></tr>
<tr><td><code><a href="#saml2__EncryptedElementType"> struct saml2__EncryptedElementType </a></code></td><td><code> saml2__EncryptedElementType </code></td><td> struct </td><td> saml2:EncryptedElementType </td></tr>
<tr><td><code><a href="#saml2__NameIDType"> struct saml2__NameIDType </a></code></td><td><code> saml2__NameIDType </code></td><td> struct </td><td> saml2:NameIDType </td></tr>
<tr><td><code><a href="#saml2__BaseIDAbstractType"> struct saml2__BaseIDAbstractType </a></code></td><td><code> saml2__BaseIDAbstractType </code></td><td> struct </td><td> saml2:BaseIDAbstractType </td></tr>
<tr><td><code><a href="#_saml1__Attribute"> _saml1__Attribute </a></code></td><td><code> _saml1__Attribute </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AttributeDesignator"> _saml1__AttributeDesignator </a></code></td><td><code> _saml1__AttributeDesignator </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AttributeStatement"> _saml1__AttributeStatement </a></code></td><td><code> _saml1__AttributeStatement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Evidence"> _saml1__Evidence </a></code></td><td><code> _saml1__Evidence </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Action"> _saml1__Action </a></code></td><td><code> _saml1__Action </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AuthorizationDecisionStatement"> _saml1__AuthorizationDecisionStatement </a></code></td><td><code> _saml1__AuthorizationDecisionStatement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AuthorityBinding"> _saml1__AuthorityBinding </a></code></td><td><code> _saml1__AuthorityBinding </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectLocality"> _saml1__SubjectLocality </a></code></td><td><code> _saml1__SubjectLocality </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AuthenticationStatement"> _saml1__AuthenticationStatement </a></code></td><td><code> _saml1__AuthenticationStatement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectConfirmation"> _saml1__SubjectConfirmation </a></code></td><td><code> _saml1__SubjectConfirmation </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__NameIdentifier"> _saml1__NameIdentifier </a></code></td><td><code> _saml1__NameIdentifier </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Subject"> _saml1__Subject </a></code></td><td><code> _saml1__Subject </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectStatement"> _saml1__SubjectStatement </a></code></td><td><code> _saml1__SubjectStatement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Statement"> _saml1__Statement </a></code></td><td><code> _saml1__Statement </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Advice"> _saml1__Advice </a></code></td><td><code> _saml1__Advice </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__DoNotCacheCondition"> _saml1__DoNotCacheCondition </a></code></td><td><code> _saml1__DoNotCacheCondition </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AudienceRestrictionCondition"> _saml1__AudienceRestrictionCondition </a></code></td><td><code> _saml1__AudienceRestrictionCondition </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Condition"> _saml1__Condition </a></code></td><td><code> _saml1__Condition </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Conditions"> _saml1__Conditions </a></code></td><td><code> _saml1__Conditions </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__Assertion"> _saml1__Assertion </a></code></td><td><code> _saml1__Assertion </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#saml1__AttributeType"> struct saml1__AttributeType </a></code></td><td><code> saml1__AttributeType </code></td><td> struct </td><td> saml1:AttributeType </td></tr>
<tr><td><code><a href="#saml1__AttributeDesignatorType"> struct saml1__AttributeDesignatorType </a></code></td><td><code> saml1__AttributeDesignatorType </code></td><td> struct </td><td> saml1:AttributeDesignatorType </td></tr>
<tr><td><code><a href="#saml1__AttributeStatementType"> struct saml1__AttributeStatementType </a></code></td><td><code> saml1__AttributeStatementType </code></td><td> struct </td><td> saml1:AttributeStatementType </td></tr>
<tr><td><code><a href="#saml1__EvidenceType"> struct saml1__EvidenceType </a></code></td><td><code> saml1__EvidenceType </code></td><td> struct </td><td> saml1:EvidenceType </td></tr>
<tr><td><code><a href="#saml1__ActionType"> struct saml1__ActionType </a></code></td><td><code> saml1__ActionType </code></td><td> struct </td><td> saml1:ActionType </td></tr>
<tr><td><code><a href="#saml1__AuthorizationDecisionStatementType"> struct saml1__AuthorizationDecisionStatementType </a></code></td><td><code> saml1__AuthorizationDecisionStatementType </code></td><td> struct </td><td> saml1:AuthorizationDecisionStatementType </td></tr>
<tr><td><code><a href="#saml1__AuthorityBindingType"> struct saml1__AuthorityBindingType </a></code></td><td><code> saml1__AuthorityBindingType </code></td><td> struct </td><td> saml1:AuthorityBindingType </td></tr>
<tr><td><code><a href="#saml1__SubjectLocalityType"> struct saml1__SubjectLocalityType </a></code></td><td><code> saml1__SubjectLocalityType </code></td><td> struct </td><td> saml1:SubjectLocalityType </td></tr>
<tr><td><code><a href="#saml1__AuthenticationStatementType"> struct saml1__AuthenticationStatementType </a></code></td><td><code> saml1__AuthenticationStatementType </code></td><td> struct </td><td> saml1:AuthenticationStatementType </td></tr>
<tr><td><code><a href="#saml1__SubjectConfirmationType"> struct saml1__SubjectConfirmationType </a></code></td><td><code> saml1__SubjectConfirmationType </code></td><td> struct </td><td> saml1:SubjectConfirmationType </td></tr>
<tr><td><code><a href="#saml1__NameIdentifierType"> struct saml1__NameIdentifierType </a></code></td><td><code> saml1__NameIdentifierType </code></td><td> struct </td><td> saml1:NameIdentifierType </td></tr>
<tr><td><code><a href="#saml1__SubjectType"> struct saml1__SubjectType </a></code></td><td><code> saml1__SubjectType </code></td><td> struct </td><td> saml1:SubjectType </td></tr>
<tr><td><code><a href="#saml1__SubjectStatementAbstractType"> struct saml1__SubjectStatementAbstractType </a></code></td><td><code> saml1__SubjectStatementAbstractType </code></td><td> struct </td><td> saml1:SubjectStatementAbstractType </td></tr>
<tr><td><code><a href="#saml1__StatementAbstractType"> struct saml1__StatementAbstractType </a></code></td><td><code> saml1__StatementAbstractType </code></td><td> struct </td><td> saml1:StatementAbstractType </td></tr>
<tr><td><code><a href="#saml1__AdviceType"> struct saml1__AdviceType </a></code></td><td><code> saml1__AdviceType </code></td><td> struct </td><td> saml1:AdviceType </td></tr>
<tr><td><code><a href="#saml1__DoNotCacheConditionType"> struct saml1__DoNotCacheConditionType </a></code></td><td><code> saml1__DoNotCacheConditionType </code></td><td> struct </td><td> saml1:DoNotCacheConditionType </td></tr>
<tr><td><code><a href="#saml1__AudienceRestrictionConditionType"> struct saml1__AudienceRestrictionConditionType </a></code></td><td><code> saml1__AudienceRestrictionConditionType </code></td><td> struct </td><td> saml1:AudienceRestrictionConditionType </td></tr>
<tr><td><code><a href="#saml1__ConditionAbstractType"> struct saml1__ConditionAbstractType </a></code></td><td><code> saml1__ConditionAbstractType </code></td><td> struct </td><td> saml1:ConditionAbstractType </td></tr>
<tr><td><code><a href="#saml1__ConditionsType"> struct saml1__ConditionsType </a></code></td><td><code> saml1__ConditionsType </code></td><td> struct </td><td> saml1:ConditionsType </td></tr>
<tr><td><code><a href="#saml1__AssertionType"> struct saml1__AssertionType </a></code></td><td><code> saml1__AssertionType </code></td><td> struct </td><td> saml1:AssertionType </td></tr>
<tr><td><code><a href="#xsd__dateTime"> xsd__dateTime </a></code></td><td><code> xsd__dateTime </code></td><td> custom </td><td> xsd:dateTime </td></tr>
<tr><td><code><a href="#wsc__PropertiesType"> struct wsc__PropertiesType </a></code></td><td><code> wsc__PropertiesType </code></td><td> struct </td><td> wsc:PropertiesType </td></tr>
<tr><td><code><a href="#wsc__DerivedKeyTokenType"> struct wsc__DerivedKeyTokenType </a></code></td><td><code> wsc__DerivedKeyTokenType </code></td><td> struct </td><td> wsc:DerivedKeyTokenType </td></tr>
<tr><td><code><a href="#wsc__SecurityContextTokenType"> struct wsc__SecurityContextTokenType </a></code></td><td><code> wsc__SecurityContextTokenType </code></td><td> struct </td><td> wsc:SecurityContextTokenType </td></tr>
<tr><td><code><a href="#_xenc__ReferenceList"> struct _xenc__ReferenceList </a></code></td><td><code> _xenc__ReferenceList </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#xenc__EncryptionPropertyType"> struct xenc__EncryptionPropertyType </a></code></td><td><code> xenc__EncryptionPropertyType </code></td><td> struct </td><td> xenc:EncryptionPropertyType </td></tr>
<tr><td><code><a href="#xenc__EncryptionPropertiesType"> struct xenc__EncryptionPropertiesType </a></code></td><td><code> xenc__EncryptionPropertiesType </code></td><td> struct </td><td> xenc:EncryptionPropertiesType </td></tr>
<tr><td><code><a href="#xenc__ReferenceType"> struct xenc__ReferenceType </a></code></td><td><code> xenc__ReferenceType </code></td><td> struct </td><td> xenc:ReferenceType </td></tr>
<tr><td><code><a href="#xenc__AgreementMethodType"> struct xenc__AgreementMethodType </a></code></td><td><code> xenc__AgreementMethodType </code></td><td> struct </td><td> xenc:AgreementMethodType </td></tr>
<tr><td><code><a href="#xenc__EncryptedDataType"> struct xenc__EncryptedDataType </a></code></td><td><code> xenc__EncryptedDataType </code></td><td> struct </td><td> xenc:EncryptedDataType </td></tr>
<tr><td><code><a href="#xenc__TransformsType"> struct xenc__TransformsType </a></code></td><td><code> xenc__TransformsType </code></td><td> struct </td><td> xenc:TransformsType </td></tr>
<tr><td><code><a href="#xenc__CipherReferenceType"> struct xenc__CipherReferenceType </a></code></td><td><code> xenc__CipherReferenceType </code></td><td> struct </td><td> xenc:CipherReferenceType </td></tr>
<tr><td><code><a href="#xenc__CipherDataType"> struct xenc__CipherDataType </a></code></td><td><code> xenc__CipherDataType </code></td><td> struct </td><td> xenc:CipherDataType </td></tr>
<tr><td><code><a href="#xenc__EncryptionMethodType"> struct xenc__EncryptionMethodType </a></code></td><td><code> xenc__EncryptionMethodType </code></td><td> struct </td><td> xenc:EncryptionMethodType </td></tr>
<tr><td><code><a href="#xenc__EncryptedType"> struct xenc__EncryptedType </a></code></td><td><code> xenc__EncryptedType </code></td><td> struct </td><td> xenc:EncryptedType </td></tr>
<tr><td><code><a href="#ds__RSAKeyValueType"> struct ds__RSAKeyValueType </a></code></td><td><code> ds__RSAKeyValueType </code></td><td> struct </td><td> ds:RSAKeyValueType </td></tr>
<tr><td><code><a href="#ds__DSAKeyValueType"> struct ds__DSAKeyValueType </a></code></td><td><code> ds__DSAKeyValueType </code></td><td> struct </td><td> ds:DSAKeyValueType </td></tr>
<tr><td><code><a href="#ds__X509IssuerSerialType"> struct ds__X509IssuerSerialType </a></code></td><td><code> ds__X509IssuerSerialType </code></td><td> struct </td><td> ds:X509IssuerSerialType </td></tr>
<tr><td><code><a href="#_ds__KeyInfo"> _ds__KeyInfo </a></code></td><td><code> _ds__KeyInfo </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#ds__RetrievalMethodType"> struct ds__RetrievalMethodType </a></code></td><td><code> ds__RetrievalMethodType </code></td><td> struct </td><td> ds:RetrievalMethodType </td></tr>
<tr><td><code><a href="#ds__KeyValueType"> struct ds__KeyValueType </a></code></td><td><code> ds__KeyValueType </code></td><td> struct </td><td> ds:KeyValueType </td></tr>
<tr><td><code><a href="#ds__DigestMethodType"> struct ds__DigestMethodType </a></code></td><td><code> ds__DigestMethodType </code></td><td> struct </td><td> ds:DigestMethodType </td></tr>
<tr><td><code><a href="#_ds__Transform"> _ds__Transform </a></code></td><td><code> _ds__Transform </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#ds__TransformType"> struct ds__TransformType </a></code></td><td><code> ds__TransformType </code></td><td> struct </td><td> ds:TransformType </td></tr>
<tr><td><code><a href="#_c14n__InclusiveNamespaces"> struct _c14n__InclusiveNamespaces </a></code></td><td><code> _c14n__InclusiveNamespaces </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#ds__TransformsType"> struct ds__TransformsType </a></code></td><td><code> ds__TransformsType </code></td><td> struct </td><td> ds:TransformsType </td></tr>
<tr><td><code><a href="#ds__ReferenceType"> struct ds__ReferenceType </a></code></td><td><code> ds__ReferenceType </code></td><td> struct </td><td> ds:ReferenceType </td></tr>
<tr><td><code><a href="#ds__SignatureMethodType"> struct ds__SignatureMethodType </a></code></td><td><code> ds__SignatureMethodType </code></td><td> struct </td><td> ds:SignatureMethodType </td></tr>
<tr><td><code><a href="#ds__CanonicalizationMethodType"> struct ds__CanonicalizationMethodType </a></code></td><td><code> ds__CanonicalizationMethodType </code></td><td> struct </td><td> ds:CanonicalizationMethodType </td></tr>
<tr><td><code><a href="#_ds__Signature"> _ds__Signature </a></code></td><td><code> _ds__Signature </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#ds__SignedInfoType"> struct ds__SignedInfoType </a></code></td><td><code> ds__SignedInfoType </code></td><td> struct </td><td> ds:SignedInfoType </td></tr>
<tr><td><code><a href="#ds__SignatureType"> struct ds__SignatureType </a></code></td><td><code> ds__SignatureType </code></td><td> struct </td><td> ds:SignatureType </td></tr>
<tr><td><code><a href="#xenc__EncryptedKeyType"> struct xenc__EncryptedKeyType </a></code></td><td><code> xenc__EncryptedKeyType </code></td><td> struct </td><td> xenc:EncryptedKeyType </td></tr>
<tr><td><code><a href="#ds__KeyInfoType"> struct ds__KeyInfoType </a></code></td><td><code> ds__KeyInfoType </code></td><td> struct </td><td> ds:KeyInfoType </td></tr>
<tr><td><code><a href="#ds__X509DataType"> struct ds__X509DataType </a></code></td><td><code> ds__X509DataType </code></td><td> struct </td><td> ds:X509DataType </td></tr>
<tr><td><code><a href="#_wsse__SecurityTokenReference"> struct _wsse__SecurityTokenReference </a></code></td><td><code> _wsse__SecurityTokenReference </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_wsse__KeyIdentifier"> struct _wsse__KeyIdentifier </a></code></td><td><code> _wsse__KeyIdentifier </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_wsse__Embedded"> struct _wsse__Embedded </a></code></td><td><code> _wsse__Embedded </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_wsse__Reference"> struct _wsse__Reference </a></code></td><td><code> _wsse__Reference </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_wsse__BinarySecurityToken"> struct _wsse__BinarySecurityToken </a></code></td><td><code> _wsse__BinarySecurityToken </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_wsse__Password"> struct _wsse__Password </a></code></td><td><code> _wsse__Password </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_wsse__UsernameToken"> struct _wsse__UsernameToken </a></code></td><td><code> _wsse__UsernameToken </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#wsse__EncodedString"> struct wsse__EncodedString </a></code></td><td><code> wsse__EncodedString </code></td><td> struct </td><td> wsse:EncodedString </td></tr>
<tr><td><code><a href="#_wsu__Timestamp"> struct _wsu__Timestamp </a></code></td><td><code> _wsu__Timestamp </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AttributeValue"> _saml2__AttributeValue </a></code></td><td><code> _saml2__AttributeValue </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code><a href="#_saml2__AuthenticatingAuthority"> _saml2__AuthenticatingAuthority </a></code></td><td><code> _saml2__AuthenticatingAuthority </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnContextDecl"> _saml2__AuthnContextDecl </a></code></td><td><code> _saml2__AuthnContextDecl </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code><a href="#_saml2__AuthnContextDeclRef"> _saml2__AuthnContextDeclRef </a></code></td><td><code> _saml2__AuthnContextDeclRef </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AuthnContextClassRef"> _saml2__AuthnContextClassRef </a></code></td><td><code> _saml2__AuthnContextClassRef </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__Audience"> _saml2__Audience </a></code></td><td><code> _saml2__Audience </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AssertionURIRef"> _saml2__AssertionURIRef </a></code></td><td><code> _saml2__AssertionURIRef </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml2__AssertionIDRef"> _saml2__AssertionIDRef </a></code></td><td><code> _saml2__AssertionIDRef </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AttributeValue"> _saml1__AttributeValue </a></code></td><td><code> _saml1__AttributeValue </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code><a href="#_saml1__ConfirmationMethod"> _saml1__ConfirmationMethod </a></code></td><td><code> _saml1__ConfirmationMethod </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__SubjectConfirmationData"> _saml1__SubjectConfirmationData </a></code></td><td><code> _saml1__SubjectConfirmationData </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code><a href="#_saml1__Audience"> _saml1__Audience </a></code></td><td><code> _saml1__Audience </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_saml1__AssertionIDReference"> _saml1__AssertionIDReference </a></code></td><td><code> _saml1__AssertionIDReference </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#wsc__FaultCodeOpenEnumType"> wsc__FaultCodeOpenEnumType </a></code></td><td><code> wsc__FaultCodeOpenEnumType </code></td><td> string </td><td> wsc:FaultCodeOpenEnumType </td></tr>
<tr><td><code><a href="#_ds__SignatureValue"> _ds__SignatureValue </a></code></td><td><code> _ds__SignatureValue </code></td><td> string </td><td>  </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> _QName </code></td><td> string </td><td> xsd:QName </td></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> _XML </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code> char * </code></td><td><code> string </code></td><td> string </td><td> xsd:string </td></tr>
<tr><td><code> std::vector<ns5__HashStructure *>  </code></td><td><code> std__vectorTemplateOfPointerTons5__HashStructure </code></td><td> container </td><td> ns5:HashStructure </td></tr>
</table>

[![][1] To top](#)


## Web Client Proxy Class BasicHttpBinding_USCORECCMovelSignatureProxy {#doc-client}

This client proxy class is declared in [soapBasicHttpBinding_USCORECCMovelSignatureProxy.h](soapBasicHttpBinding_USCORECCMovelSignatureProxy.h) and defined in [soapBasicHttpBinding_USCORECCMovelSignatureProxy.cpp](soapBasicHttpBinding_USCORECCMovelSignatureProxy.cpp):

    class SOAP_CMAC BasicHttpBinding_USCORECCMovelSignatureProxy {
      public:
        /// Context to manage proxy IO and data
        struct soap *soap;
        /// flag indicating that this context is owned by this proxy and should be deleted by the destructor
        bool soap_own;
        /// Endpoint URL of service 'BasicHttpBinding_USCORECCMovelSignatureProxy' (change as needed)
        const char *soap_endpoint;
        /// Variables globally declared in CCMovelDigitalSignature.h, if any
        /// Construct a proxy with new managing context
        BasicHttpBinding_USCORECCMovelSignatureProxy();
        /// Copy constructor
        BasicHttpBinding_USCORECCMovelSignatureProxy(const BasicHttpBinding_USCORECCMovelSignatureProxy& rhs);
        /// Construct proxy given a shared managing context
        BasicHttpBinding_USCORECCMovelSignatureProxy(struct soap*);
        /// Construct proxy given a shared managing context and endpoint URL
        BasicHttpBinding_USCORECCMovelSignatureProxy(struct soap*, const char *soap_endpoint_url);
        /// Constructor taking an endpoint URL
        BasicHttpBinding_USCORECCMovelSignatureProxy(const char *soap_endpoint_url);
        /// Constructor taking input and output mode flags for the new managing context
        BasicHttpBinding_USCORECCMovelSignatureProxy(soap_mode iomode);
        /// Constructor taking endpoint URL and input and output mode flags for the new managing context
        BasicHttpBinding_USCORECCMovelSignatureProxy(const char *soap_endpoint_url, soap_mode iomode);
        /// Constructor taking input and output mode flags for the new managing context
        BasicHttpBinding_USCORECCMovelSignatureProxy(soap_mode imode, soap_mode omode);
        /// Destructor deletes deserialized data and its managing context, when the context was allocated by the constructor
        virtual ~BasicHttpBinding_USCORECCMovelSignatureProxy();
        /// Initializer used by constructors
        virtual void BasicHttpBinding_USCORECCMovelSignatureProxy_init(soap_mode imode, soap_mode omode);
        /// Return a copy that has a new managing context with the same engine state
        virtual BasicHttpBinding_USCORECCMovelSignatureProxy *copy();
        /// Copy assignment
        BasicHttpBinding_USCORECCMovelSignatureProxy& operator=(const BasicHttpBinding_USCORECCMovelSignatureProxy&);
        /// Delete all deserialized data (uses soap_destroy() and soap_end())
        virtual void destroy();
        /// Delete all deserialized data and reset to default
        virtual void reset();
        /// Disables and removes SOAP Header from message by setting soap->header = NULL
        virtual void soap_noheader();
        /// Add SOAP Header to message
        virtual void soap_header(struct _wsse__Security *wsse__Security);
        /// Get SOAP Header structure (i.e. soap->header, which is NULL when absent)
        virtual ::SOAP_ENV__Header *soap_header();
        /// Get SOAP Fault structure (i.e. soap->fault, which is NULL when absent)
        virtual ::SOAP_ENV__Fault *soap_fault();
        /// Get SOAP Fault subcode QName string (NULL when absent)
        virtual const char *soap_fault_subcode();
        /// Get SOAP Fault string/reason (NULL when absent)
        virtual const char *soap_fault_string();
        /// Get SOAP Fault detail XML string (NULL when absent)
        virtual const char *soap_fault_detail();
        /// Close connection (normally automatic, except for send_X ops)
        virtual int soap_close_socket();
        /// Force close connection (can kill a thread blocked on IO)
        virtual int soap_force_close_socket();
        /// Print fault
        virtual void soap_print_fault(FILE*);
    #ifndef WITH_LEAN
    #ifndef WITH_COMPAT
        /// Print fault to stream
        virtual void soap_stream_fault(std::ostream&);
    #endif
        /// Write fault to buffer
        virtual char *soap_sprint_fault(char *buf, size_t len);
    #endif
        //
        /// Web service synchronous operation 'CCMovelSign' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelSign(_ns3__CCMovelSign *ns3__CCMovelSign, _ns3__CCMovelSignResponse &ns3__CCMovelSignResponse) { return this->CCMovelSign(NULL, NULL, ns3__CCMovelSign, ns3__CCMovelSignResponse); }
        /// Web service synchronous operation 'CCMovelSign' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelSign *ns3__CCMovelSign, _ns3__CCMovelSignResponse &ns3__CCMovelSignResponse) { return this->send_CCMovelSign(soap_endpoint_url, soap_action, ns3__CCMovelSign) || this->recv_CCMovelSign(ns3__CCMovelSignResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_CCMovelSign' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_CCMovelSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelSign *ns3__CCMovelSign);
        /// Web service asynchronous operation 'recv_CCMovelSign' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_CCMovelSign(_ns3__CCMovelSignResponse &ns3__CCMovelSignResponse);
        //
        /// Web service synchronous operation 'GetCertificate' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificate(_ns3__GetCertificate *ns3__GetCertificate, _ns3__GetCertificateResponse &ns3__GetCertificateResponse) { return this->GetCertificate(NULL, NULL, ns3__GetCertificate, ns3__GetCertificateResponse); }
        /// Web service synchronous operation 'GetCertificate' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificate(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificate *ns3__GetCertificate, _ns3__GetCertificateResponse &ns3__GetCertificateResponse) { return this->send_GetCertificate(soap_endpoint_url, soap_action, ns3__GetCertificate) || this->recv_GetCertificate(ns3__GetCertificateResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_GetCertificate' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_GetCertificate(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificate *ns3__GetCertificate);
        /// Web service asynchronous operation 'recv_GetCertificate' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_GetCertificate(_ns3__GetCertificateResponse &ns3__GetCertificateResponse);
        //
        /// Web service synchronous operation 'ValidateOtp' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int ValidateOtp(_ns3__ValidateOtp *ns3__ValidateOtp, _ns3__ValidateOtpResponse &ns3__ValidateOtpResponse) { return this->ValidateOtp(NULL, NULL, ns3__ValidateOtp, ns3__ValidateOtpResponse); }
        /// Web service synchronous operation 'ValidateOtp' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int ValidateOtp(const char *soap_endpoint_url, const char *soap_action, _ns3__ValidateOtp *ns3__ValidateOtp, _ns3__ValidateOtpResponse &ns3__ValidateOtpResponse) { return this->send_ValidateOtp(soap_endpoint_url, soap_action, ns3__ValidateOtp) || this->recv_ValidateOtp(ns3__ValidateOtpResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_ValidateOtp' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_ValidateOtp(const char *soap_endpoint_url, const char *soap_action, _ns3__ValidateOtp *ns3__ValidateOtp);
        /// Web service asynchronous operation 'recv_ValidateOtp' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_ValidateOtp(_ns3__ValidateOtpResponse &ns3__ValidateOtpResponse);
        //
        /// Web service synchronous operation 'CCMovelMultipleSign' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelMultipleSign(_ns3__CCMovelMultipleSign *ns3__CCMovelMultipleSign, _ns3__CCMovelMultipleSignResponse &ns3__CCMovelMultipleSignResponse) { return this->CCMovelMultipleSign(NULL, NULL, ns3__CCMovelMultipleSign, ns3__CCMovelMultipleSignResponse); }
        /// Web service synchronous operation 'CCMovelMultipleSign' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelMultipleSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelMultipleSign *ns3__CCMovelMultipleSign, _ns3__CCMovelMultipleSignResponse &ns3__CCMovelMultipleSignResponse) { return this->send_CCMovelMultipleSign(soap_endpoint_url, soap_action, ns3__CCMovelMultipleSign) || this->recv_CCMovelMultipleSign(ns3__CCMovelMultipleSignResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_CCMovelMultipleSign' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_CCMovelMultipleSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelMultipleSign *ns3__CCMovelMultipleSign);
        /// Web service asynchronous operation 'recv_CCMovelMultipleSign' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_CCMovelMultipleSign(_ns3__CCMovelMultipleSignResponse &ns3__CCMovelMultipleSignResponse);
        //
        /// Web service synchronous operation 'ForceSMS' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int ForceSMS(_ns3__ForceSMS *ns3__ForceSMS, _ns3__ForceSMSResponse &ns3__ForceSMSResponse) { return this->ForceSMS(NULL, NULL, ns3__ForceSMS, ns3__ForceSMSResponse); }
        /// Web service synchronous operation 'ForceSMS' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int ForceSMS(const char *soap_endpoint_url, const char *soap_action, _ns3__ForceSMS *ns3__ForceSMS, _ns3__ForceSMSResponse &ns3__ForceSMSResponse) { return this->send_ForceSMS(soap_endpoint_url, soap_action, ns3__ForceSMS) || this->recv_ForceSMS(ns3__ForceSMSResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_ForceSMS' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_ForceSMS(const char *soap_endpoint_url, const char *soap_action, _ns3__ForceSMS *ns3__ForceSMS);
        /// Web service asynchronous operation 'recv_ForceSMS' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_ForceSMS(_ns3__ForceSMSResponse &ns3__ForceSMSResponse);
        //
        /// Web service synchronous operation 'GetCertificateWithPin' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificateWithPin(_ns3__GetCertificateWithPin *ns3__GetCertificateWithPin, _ns3__GetCertificateWithPinResponse &ns3__GetCertificateWithPinResponse) { return this->GetCertificateWithPin(NULL, NULL, ns3__GetCertificateWithPin, ns3__GetCertificateWithPinResponse); }
        /// Web service synchronous operation 'GetCertificateWithPin' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificateWithPin(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificateWithPin *ns3__GetCertificateWithPin, _ns3__GetCertificateWithPinResponse &ns3__GetCertificateWithPinResponse) { return this->send_GetCertificateWithPin(soap_endpoint_url, soap_action, ns3__GetCertificateWithPin) || this->recv_GetCertificateWithPin(ns3__GetCertificateWithPinResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_GetCertificateWithPin' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_GetCertificateWithPin(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificateWithPin *ns3__GetCertificateWithPin);
        /// Web service asynchronous operation 'recv_GetCertificateWithPin' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_GetCertificateWithPin(_ns3__GetCertificateWithPinResponse &ns3__GetCertificateWithPinResponse);
    };

### Proxy Operation `BasicHttpBinding_USCORECCMovelSignatureProxy::CCMovelSign()`

This service operation is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1230 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://Ama.Authentication.Service/CCMovelSignature/CCMovelSign"
- SOAP response action "http://Ama.Authentication.Service/CCMovelSignature/CCMovelSignResponse"
- Default service endpoint URL "CCMovelDigitalSignature1.wsdl"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'CCMovelSign' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelSign(_ns3__CCMovelSign *ns3__CCMovelSign, _ns3__CCMovelSignResponse &ns3__CCMovelSignResponse) { return this->CCMovelSign(NULL, NULL, ns3__CCMovelSign, ns3__CCMovelSignResponse); }
        /// Web service synchronous operation 'CCMovelSign' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelSign *ns3__CCMovelSign, _ns3__CCMovelSignResponse &ns3__CCMovelSignResponse) { return this->send_CCMovelSign(soap_endpoint_url, soap_action, ns3__CCMovelSign) || this->recv_CCMovelSign(ns3__CCMovelSignResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_CCMovelSign' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_CCMovelSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelSign *ns3__CCMovelSign);
        /// Web service asynchronous operation 'recv_CCMovelSign' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_CCMovelSign(_ns3__CCMovelSignResponse &ns3__CCMovelSignResponse);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `_ns3__CCMovelSign *ns3__CCMovelSign` is optional, where the type of this parameter is a pointer to <code><a href="#_ns3__CCMovelSign"> _ns3__CCMovelSign </a></code>
- `_ns3__CCMovelSignResponse &ns3__CCMovelSignResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns3__CCMovelSignResponse"> _ns3__CCMovelSignResponse </a></code>

The `CCMovelSign` method sends the request message and receives the response message, assigning the last parameter `ns3__CCMovelSignResponse` the response value received. The `send_CCMovelSign` method sends the request message and the `recv_CCMovelSign` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `BasicHttpBinding_USCORECCMovelSignatureProxy::GetCertificate()`

This service operation is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1300 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://Ama.Authentication.Service/CCMovelSignature/GetCertificate"
- SOAP response action "http://Ama.Authentication.Service/CCMovelSignature/GetCertificateResponse"
- Default service endpoint URL "CCMovelDigitalSignature1.wsdl"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'GetCertificate' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificate(_ns3__GetCertificate *ns3__GetCertificate, _ns3__GetCertificateResponse &ns3__GetCertificateResponse) { return this->GetCertificate(NULL, NULL, ns3__GetCertificate, ns3__GetCertificateResponse); }
        /// Web service synchronous operation 'GetCertificate' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificate(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificate *ns3__GetCertificate, _ns3__GetCertificateResponse &ns3__GetCertificateResponse) { return this->send_GetCertificate(soap_endpoint_url, soap_action, ns3__GetCertificate) || this->recv_GetCertificate(ns3__GetCertificateResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_GetCertificate' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_GetCertificate(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificate *ns3__GetCertificate);
        /// Web service asynchronous operation 'recv_GetCertificate' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_GetCertificate(_ns3__GetCertificateResponse &ns3__GetCertificateResponse);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `_ns3__GetCertificate *ns3__GetCertificate` is optional, where the type of this parameter is a pointer to <code><a href="#_ns3__GetCertificate"> _ns3__GetCertificate </a></code>
- `_ns3__GetCertificateResponse &ns3__GetCertificateResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns3__GetCertificateResponse"> _ns3__GetCertificateResponse </a></code>

The `GetCertificate` method sends the request message and receives the response message, assigning the last parameter `ns3__GetCertificateResponse` the response value received. The `send_GetCertificate` method sends the request message and the `recv_GetCertificate` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `BasicHttpBinding_USCORECCMovelSignatureProxy::ValidateOtp()`

This service operation is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1370 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://Ama.Authentication.Service/CCMovelSignature/ValidateOtp"
- SOAP response action "http://Ama.Authentication.Service/CCMovelSignature/ValidateOtpResponse"
- Default service endpoint URL "CCMovelDigitalSignature1.wsdl"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'ValidateOtp' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int ValidateOtp(_ns3__ValidateOtp *ns3__ValidateOtp, _ns3__ValidateOtpResponse &ns3__ValidateOtpResponse) { return this->ValidateOtp(NULL, NULL, ns3__ValidateOtp, ns3__ValidateOtpResponse); }
        /// Web service synchronous operation 'ValidateOtp' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int ValidateOtp(const char *soap_endpoint_url, const char *soap_action, _ns3__ValidateOtp *ns3__ValidateOtp, _ns3__ValidateOtpResponse &ns3__ValidateOtpResponse) { return this->send_ValidateOtp(soap_endpoint_url, soap_action, ns3__ValidateOtp) || this->recv_ValidateOtp(ns3__ValidateOtpResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_ValidateOtp' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_ValidateOtp(const char *soap_endpoint_url, const char *soap_action, _ns3__ValidateOtp *ns3__ValidateOtp);
        /// Web service asynchronous operation 'recv_ValidateOtp' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_ValidateOtp(_ns3__ValidateOtpResponse &ns3__ValidateOtpResponse);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `_ns3__ValidateOtp *ns3__ValidateOtp` is optional, where the type of this parameter is a pointer to <code><a href="#_ns3__ValidateOtp"> _ns3__ValidateOtp </a></code>
- `_ns3__ValidateOtpResponse &ns3__ValidateOtpResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns3__ValidateOtpResponse"> _ns3__ValidateOtpResponse </a></code>

The `ValidateOtp` method sends the request message and receives the response message, assigning the last parameter `ns3__ValidateOtpResponse` the response value received. The `send_ValidateOtp` method sends the request message and the `recv_ValidateOtp` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `BasicHttpBinding_USCORECCMovelSignatureProxy::CCMovelMultipleSign()`

This service operation is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1440 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://Ama.Authentication.Service/CCMovelSignature/CCMovelMultipleSign"
- SOAP response action "http://Ama.Authentication.Service/CCMovelSignature/CCMovelMultipleSignResponse"
- Default service endpoint URL "CCMovelDigitalSignature1.wsdl"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'CCMovelMultipleSign' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelMultipleSign(_ns3__CCMovelMultipleSign *ns3__CCMovelMultipleSign, _ns3__CCMovelMultipleSignResponse &ns3__CCMovelMultipleSignResponse) { return this->CCMovelMultipleSign(NULL, NULL, ns3__CCMovelMultipleSign, ns3__CCMovelMultipleSignResponse); }
        /// Web service synchronous operation 'CCMovelMultipleSign' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int CCMovelMultipleSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelMultipleSign *ns3__CCMovelMultipleSign, _ns3__CCMovelMultipleSignResponse &ns3__CCMovelMultipleSignResponse) { return this->send_CCMovelMultipleSign(soap_endpoint_url, soap_action, ns3__CCMovelMultipleSign) || this->recv_CCMovelMultipleSign(ns3__CCMovelMultipleSignResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_CCMovelMultipleSign' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_CCMovelMultipleSign(const char *soap_endpoint_url, const char *soap_action, _ns3__CCMovelMultipleSign *ns3__CCMovelMultipleSign);
        /// Web service asynchronous operation 'recv_CCMovelMultipleSign' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_CCMovelMultipleSign(_ns3__CCMovelMultipleSignResponse &ns3__CCMovelMultipleSignResponse);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `_ns3__CCMovelMultipleSign *ns3__CCMovelMultipleSign` is optional, where the type of this parameter is a pointer to <code><a href="#_ns3__CCMovelMultipleSign"> _ns3__CCMovelMultipleSign </a></code>
- `_ns3__CCMovelMultipleSignResponse &ns3__CCMovelMultipleSignResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns3__CCMovelMultipleSignResponse"> _ns3__CCMovelMultipleSignResponse </a></code>

The `CCMovelMultipleSign` method sends the request message and receives the response message, assigning the last parameter `ns3__CCMovelMultipleSignResponse` the response value received. The `send_CCMovelMultipleSign` method sends the request message and the `recv_CCMovelMultipleSign` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `BasicHttpBinding_USCORECCMovelSignatureProxy::ForceSMS()`

This service operation is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1510 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://Ama.Authentication.Service/CCMovelSignature/ForceSMS"
- SOAP response action "http://Ama.Authentication.Service/CCMovelSignature/ForceSMSResponse"
- Default service endpoint URL "CCMovelDigitalSignature1.wsdl"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'ForceSMS' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int ForceSMS(_ns3__ForceSMS *ns3__ForceSMS, _ns3__ForceSMSResponse &ns3__ForceSMSResponse) { return this->ForceSMS(NULL, NULL, ns3__ForceSMS, ns3__ForceSMSResponse); }
        /// Web service synchronous operation 'ForceSMS' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int ForceSMS(const char *soap_endpoint_url, const char *soap_action, _ns3__ForceSMS *ns3__ForceSMS, _ns3__ForceSMSResponse &ns3__ForceSMSResponse) { return this->send_ForceSMS(soap_endpoint_url, soap_action, ns3__ForceSMS) || this->recv_ForceSMS(ns3__ForceSMSResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_ForceSMS' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_ForceSMS(const char *soap_endpoint_url, const char *soap_action, _ns3__ForceSMS *ns3__ForceSMS);
        /// Web service asynchronous operation 'recv_ForceSMS' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_ForceSMS(_ns3__ForceSMSResponse &ns3__ForceSMSResponse);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `_ns3__ForceSMS *ns3__ForceSMS` is optional, where the type of this parameter is a pointer to <code><a href="#_ns3__ForceSMS"> _ns3__ForceSMS </a></code>
- `_ns3__ForceSMSResponse &ns3__ForceSMSResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns3__ForceSMSResponse"> _ns3__ForceSMSResponse </a></code>

The `ForceSMS` method sends the request message and receives the response message, assigning the last parameter `ns3__ForceSMSResponse` the response value received. The `send_ForceSMS` method sends the request message and the `recv_ForceSMS` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `BasicHttpBinding_USCORECCMovelSignatureProxy::GetCertificateWithPin()`

This service operation is declared in [CCMovelDigitalSignature.h](CCMovelDigitalSignature.h) at line 1580 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://Ama.Authentication.Service/CCMovelSignature/GetCertificateWithPin"
- SOAP response action "http://Ama.Authentication.Service/CCMovelSignature/GetCertificateWithPinResponse"
- Default service endpoint URL "CCMovelDigitalSignature1.wsdl"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'GetCertificateWithPin' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificateWithPin(_ns3__GetCertificateWithPin *ns3__GetCertificateWithPin, _ns3__GetCertificateWithPinResponse &ns3__GetCertificateWithPinResponse) { return this->GetCertificateWithPin(NULL, NULL, ns3__GetCertificateWithPin, ns3__GetCertificateWithPinResponse); }
        /// Web service synchronous operation 'GetCertificateWithPin' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int GetCertificateWithPin(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificateWithPin *ns3__GetCertificateWithPin, _ns3__GetCertificateWithPinResponse &ns3__GetCertificateWithPinResponse) { return this->send_GetCertificateWithPin(soap_endpoint_url, soap_action, ns3__GetCertificateWithPin) || this->recv_GetCertificateWithPin(ns3__GetCertificateWithPinResponse) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_GetCertificateWithPin' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_GetCertificateWithPin(const char *soap_endpoint_url, const char *soap_action, _ns3__GetCertificateWithPin *ns3__GetCertificateWithPin);
        /// Web service asynchronous operation 'recv_GetCertificateWithPin' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_GetCertificateWithPin(_ns3__GetCertificateWithPinResponse &ns3__GetCertificateWithPinResponse);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `_ns3__GetCertificateWithPin *ns3__GetCertificateWithPin` is optional, where the type of this parameter is a pointer to <code><a href="#_ns3__GetCertificateWithPin"> _ns3__GetCertificateWithPin </a></code>
- `_ns3__GetCertificateWithPinResponse &ns3__GetCertificateWithPinResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns3__GetCertificateWithPinResponse"> _ns3__GetCertificateWithPinResponse </a></code>

The `GetCertificateWithPin` method sends the request message and receives the response message, assigning the last parameter `ns3__GetCertificateWithPinResponse` the response value received. The `send_GetCertificateWithPin` method sends the request message and the `recv_GetCertificateWithPin` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


## Schemas and Namespaces {#doc-namespaces}

The following schemas and namespaces are used in addition to the predefined SOAP and built-in XSD namespaces:

- Prefix `ns5` is bound to namespace URI *`http://schemas.datacontract.org/2004/07/Ama.Structures.CCMovelSignature`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `ns4` is bound to namespace URI *`http://schemas.microsoft.com/2003/10/Serialization/`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `ns1` is bound to namespace URI *`http://tempuri.org/`* with local element and attribute form default *`unqualified`*
- Prefix `ns3` is bound to namespace URI *`http://Ama.Authentication.Service/`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `c14n` is bound to namespace URI *`http://www.w3.org/2001/10/xml-exc-c14n#`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `ds` is bound to namespace URI *`http://www.w3.org/2000/09/xmldsig#`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `saml1` is bound to namespace URI *`urn:oasis:names:tc:SAML:1.0:assertion`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `saml2` is bound to namespace URI *`urn:oasis:names:tc:SAML:2.0:assertion`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `wsu` is bound to namespace URI *`http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `xenc` is bound to namespace URI *`http://www.w3.org/2001/04/xmlenc#`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `wsc` is bound to namespace URI *`http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512`* with local element form default *`unqualified`* and attribute form default *`unqualified`*
- Prefix `wsse` is bound to namespace URI *`http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd`* with local element form default *`unqualified`* and attribute form default *`unqualified`*


The following namespace table is saved to BasicHttpBinding_USCORECCMovelSignature.nsmap:

    struct Namespace namespaces[] = {
        { "SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL },
        { "SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL },
        { "xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL },
        { "xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL },
        { "ns5", "http://schemas.datacontract.org/2004/07/Ama.Structures.CCMovelSignature", NULL, NULL },
        { "ns4", "http://schemas.microsoft.com/2003/10/Serialization/", NULL, NULL },
        { "ns1", "http://tempuri.org/", NULL, NULL },
        { "ns3", "http://Ama.Authentication.Service/", NULL, NULL },
        { "c14n", "http://www.w3.org/2001/10/xml-exc-c14n#", NULL, NULL },
        { "ds", "http://www.w3.org/2000/09/xmldsig#", NULL, NULL },
        { "saml1", "urn:oasis:names:tc:SAML:1.0:assertion", NULL, NULL },
        { "saml2", "urn:oasis:names:tc:SAML:2.0:assertion", NULL, NULL },
        { "wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", NULL, NULL },
        { "xenc", "http://www.w3.org/2001/04/xmlenc#", NULL, NULL },
        { "wsc", "http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512", "http://schemas.xmlsoap.org/ws/2005/02/sc", NULL },
        { "wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "http://docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd", NULL },
        { NULL, NULL, NULL, NULL}
    };

The table binds XML namespace prefixes (first column) to namespace URIs (second column), similar to xmlns:prefix="URI" in XML.  The third column is a URI pattern with `*` wildcards that is also accepted as a valid namespace URI for inbound XML messages.  The fourth column is NULL.  This table is globally defined for the gSOAP engine.  The engine context will look for it unless you compiled the gSOAP source codes with `-DWITH_NONAMESPACES`.  You must assign this or another namespace table with `soap_set_namespaces(struct soap *soap, struct Namespace *namespaces)` after initializing the context and before processing XML.

[![][1] To top](#)



  [1]: https://www.genivia.com/images/go-up.png

--------------------------------------------------------------------------------

_Generated on Tue Jun 23 2020 16:45:23 UTC by soapcpp2 v2.8.103 for CCMovelDigitalSignature.h._
_The gSOAP XML Web services tools are Copyright (C) Robert van Engelen, Genivia Inc. All Rights Reserved._
