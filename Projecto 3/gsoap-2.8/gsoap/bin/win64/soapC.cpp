/* soapC.cpp
   Generated by gSOAP 2.8.103 for CCMovelDigitalSignature.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.103 2020-06-23 16:45:23 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, tag, NULL, "xsd:short");
	case SOAP_TYPE_ns4__char:
		return soap_in_ns4__char(soap, tag, NULL, "ns4:char");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, tag, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_saml2__DecisionType:
		return soap_in_saml2__DecisionType(soap, tag, NULL, "saml2:DecisionType");
	case SOAP_TYPE_saml1__DecisionType:
		return soap_in_saml1__DecisionType(soap, tag, NULL, "saml1:DecisionType");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_in_wsc__FaultCodeType(soap, tag, NULL, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, tag, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, tag, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_ns4__guid__:
		return soap_in_ns4__guid__(soap, tag, NULL, "ns4:guid");
	case SOAP_TYPE_ns4__guid:
		return soap_in_ns4__guid(soap, tag, NULL, "ns4:guid");
	case SOAP_TYPE_ns4__duration__:
		return soap_in_ns4__duration__(soap, tag, NULL, "ns4:duration");
	case SOAP_TYPE_ns4__duration:
		return soap_in_ns4__duration(soap, tag, NULL, "ns4:duration");
	case SOAP_TYPE_ns4__char__:
		return soap_in_ns4__char__(soap, tag, NULL, "ns4:char");
	case SOAP_TYPE_ns5__MultipleSignRequest:
		return soap_in_ns5__MultipleSignRequest(soap, tag, NULL, "ns5:MultipleSignRequest");
	case SOAP_TYPE_ns5__HashStructure:
		return soap_in_ns5__HashStructure(soap, tag, NULL, "ns5:HashStructure");
	case SOAP_TYPE_ns5__ArrayOfHashStructure:
		return soap_in_ns5__ArrayOfHashStructure(soap, tag, NULL, "ns5:ArrayOfHashStructure");
	case SOAP_TYPE_ns5__SignResponse:
		return soap_in_ns5__SignResponse(soap, tag, NULL, "ns5:SignResponse");
	case SOAP_TYPE_ns5__SignStatus:
		return soap_in_ns5__SignStatus(soap, tag, NULL, "ns5:SignStatus");
	case SOAP_TYPE_ns5__SignRequest:
		return soap_in_ns5__SignRequest(soap, tag, NULL, "ns5:SignRequest");
	case SOAP_TYPE_xsd__unsignedShort_:
		return soap_in_xsd__unsignedShort_(soap, tag, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong_:
		return soap_in_xsd__unsignedLong_(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt_:
		return soap_in_xsd__unsignedInt_(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte__:
		return soap_in_xsd__unsignedByte__(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string_:
		return soap_in_xsd__string_(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_xsd__short_:
		return soap_in_xsd__short_(soap, tag, NULL, "xsd:short");
	case SOAP_TYPE_xsd__long_:
		return soap_in_xsd__long_(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int_:
		return soap_in_xsd__int_(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_xsd__float_:
		return soap_in_xsd__float_(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_xsd__duration__:
		return soap_in_xsd__duration__(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return soap_in_xsd__double_(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_xsd__decimal__:
		return soap_in_xsd__decimal__(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime_:
		return soap_in_xsd__dateTime_(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte__:
		return soap_in_xsd__byte__(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__boolean_:
		return soap_in_xsd__boolean_(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary__:
		return soap_in_xsd__base64Binary__(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI__:
		return soap_in_xsd__anyURI__(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName__:
		return soap_in_xsd__QName__(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__IDREF__:
		return soap_in_xsd__IDREF__(soap, tag, NULL, "xsd:IDREF");
	case SOAP_TYPE_xsd__IDREF:
		return soap_in_xsd__IDREF(soap, tag, NULL, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID__:
		return soap_in_xsd__ID__(soap, tag, NULL, "xsd:ID");
	case SOAP_TYPE_xsd__ID:
		return soap_in_xsd__ID(soap, tag, NULL, "xsd:ID");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType");
	case SOAP_TYPE_saml2__AttributeType:
		return soap_in_saml2__AttributeType(soap, tag, NULL, "saml2:AttributeType");
	case SOAP_TYPE_saml2__AttributeStatementType:
		return soap_in_saml2__AttributeStatementType(soap, tag, NULL, "saml2:AttributeStatementType");
	case SOAP_TYPE_saml2__EvidenceType:
		return soap_in_saml2__EvidenceType(soap, tag, NULL, "saml2:EvidenceType");
	case SOAP_TYPE_saml2__ActionType:
		return soap_in_saml2__ActionType(soap, tag, NULL, "saml2:ActionType");
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return soap_in_saml2__AuthzDecisionStatementType(soap, tag, NULL, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_saml2__AuthnContextType:
		return soap_in_saml2__AuthnContextType(soap, tag, NULL, "saml2:AuthnContextType");
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return soap_in_saml2__SubjectLocalityType(soap, tag, NULL, "saml2:SubjectLocalityType");
	case SOAP_TYPE_saml2__AuthnStatementType:
		return soap_in_saml2__AuthnStatementType(soap, tag, NULL, "saml2:AuthnStatementType");
	case SOAP_TYPE_saml2__StatementAbstractType:
		return soap_in_saml2__StatementAbstractType(soap, tag, NULL, "saml2:StatementAbstractType");
	case SOAP_TYPE_saml2__AdviceType:
		return soap_in_saml2__AdviceType(soap, tag, NULL, "saml2:AdviceType");
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return soap_in_saml2__ProxyRestrictionType(soap, tag, NULL, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_saml2__OneTimeUseType:
		return soap_in_saml2__OneTimeUseType(soap, tag, NULL, "saml2:OneTimeUseType");
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return soap_in_saml2__AudienceRestrictionType(soap, tag, NULL, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return soap_in_saml2__ConditionAbstractType(soap, tag, NULL, "saml2:ConditionAbstractType");
	case SOAP_TYPE_saml2__ConditionsType:
		return soap_in_saml2__ConditionsType(soap, tag, NULL, "saml2:ConditionsType");
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, NULL, "saml2:KeyInfoConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return soap_in_saml2__SubjectConfirmationDataType(soap, tag, NULL, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return soap_in_saml2__SubjectConfirmationType(soap, tag, NULL, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_saml2__SubjectType:
		return soap_in_saml2__SubjectType(soap, tag, NULL, "saml2:SubjectType");
	case SOAP_TYPE_saml2__AssertionType:
		return soap_in_saml2__AssertionType(soap, tag, NULL, "saml2:AssertionType");
	case SOAP_TYPE_saml2__EncryptedElementType:
		return soap_in_saml2__EncryptedElementType(soap, tag, NULL, "saml2:EncryptedElementType");
	case SOAP_TYPE_saml2__NameIDType:
		return soap_in_saml2__NameIDType(soap, tag, NULL, "saml2:NameIDType");
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return soap_in_saml2__BaseIDAbstractType(soap, tag, NULL, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_saml1__AttributeType:
		return soap_in_saml1__AttributeType(soap, tag, NULL, "saml1:AttributeType");
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return soap_in_saml1__AttributeDesignatorType(soap, tag, NULL, "saml1:AttributeDesignatorType");
	case SOAP_TYPE_saml1__AttributeStatementType:
		return soap_in_saml1__AttributeStatementType(soap, tag, NULL, "saml1:AttributeStatementType");
	case SOAP_TYPE_saml1__EvidenceType:
		return soap_in_saml1__EvidenceType(soap, tag, NULL, "saml1:EvidenceType");
	case SOAP_TYPE_saml1__ActionType:
		return soap_in_saml1__ActionType(soap, tag, NULL, "saml1:ActionType");
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, NULL, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return soap_in_saml1__AuthorityBindingType(soap, tag, NULL, "saml1:AuthorityBindingType");
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return soap_in_saml1__SubjectLocalityType(soap, tag, NULL, "saml1:SubjectLocalityType");
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return soap_in_saml1__AuthenticationStatementType(soap, tag, NULL, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return soap_in_saml1__SubjectConfirmationType(soap, tag, NULL, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_saml1__NameIdentifierType:
		return soap_in_saml1__NameIdentifierType(soap, tag, NULL, "saml1:NameIdentifierType");
	case SOAP_TYPE_saml1__SubjectType:
		return soap_in_saml1__SubjectType(soap, tag, NULL, "saml1:SubjectType");
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return soap_in_saml1__SubjectStatementAbstractType(soap, tag, NULL, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_saml1__StatementAbstractType:
		return soap_in_saml1__StatementAbstractType(soap, tag, NULL, "saml1:StatementAbstractType");
	case SOAP_TYPE_saml1__AdviceType:
		return soap_in_saml1__AdviceType(soap, tag, NULL, "saml1:AdviceType");
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return soap_in_saml1__DoNotCacheConditionType(soap, tag, NULL, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return soap_in_saml1__AudienceRestrictionConditionType(soap, tag, NULL, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return soap_in_saml1__ConditionAbstractType(soap, tag, NULL, "saml1:ConditionAbstractType");
	case SOAP_TYPE_saml1__ConditionsType:
		return soap_in_saml1__ConditionsType(soap, tag, NULL, "saml1:ConditionsType");
	case SOAP_TYPE_saml1__AssertionType:
		return soap_in_saml1__AssertionType(soap, tag, NULL, "saml1:AssertionType");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_in_wsc__PropertiesType(soap, tag, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_in_wsc__DerivedKeyTokenType(soap, tag, NULL, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_in_wsc__SecurityContextTokenType(soap, tag, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_in_xenc__EncryptionPropertyType(soap, tag, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_in_xenc__EncryptionPropertiesType(soap, tag, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_in_xenc__ReferenceType(soap, tag, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_in_xenc__AgreementMethodType(soap, tag, NULL, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_in_xenc__EncryptedDataType(soap, tag, NULL, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_in_xenc__TransformsType(soap, tag, NULL, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_in_xenc__CipherReferenceType(soap, tag, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_in_xenc__CipherDataType(soap, tag, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_in_xenc__EncryptionMethodType(soap, tag, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_in_xenc__EncryptedType(soap, tag, NULL, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, tag, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, tag, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, tag, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, tag, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, tag, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, tag, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, tag, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, tag, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, tag, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, tag, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, tag, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, tag, NULL, "ds:SignatureType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_in_xenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, tag, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, tag, NULL, "ds:X509DataType");
	case SOAP_TYPE_wsse__EncodedString:
		return soap_in_wsse__EncodedString(soap, tag, NULL, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, tag, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, tag, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, tag, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, tag, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		return soap_in_PointerToPointerTo_ds__KeyInfo(soap, tag, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		return soap_in_PointerTosaml2__AttributeType(soap, tag, NULL, "saml2:AttributeType");
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		return soap_in_PointerTosaml2__EvidenceType(soap, tag, NULL, "saml2:EvidenceType");
	case SOAP_TYPE_PointerTosaml2__ActionType:
		return soap_in_PointerTosaml2__ActionType(soap, tag, NULL, "saml2:ActionType");
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		return soap_in_PointerTosaml2__AuthnContextType(soap, tag, NULL, "saml2:AuthnContextType");
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		return soap_in_PointerTosaml2__SubjectLocalityType(soap, tag, NULL, "saml2:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		return soap_in_PointerTosaml2__AssertionType(soap, tag, NULL, "saml2:AssertionType");
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		return soap_in_PointerTosaml2__ProxyRestrictionType(soap, tag, NULL, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		return soap_in_PointerTosaml2__OneTimeUseType(soap, tag, NULL, "saml2:OneTimeUseType");
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		return soap_in_PointerTosaml2__AudienceRestrictionType(soap, tag, NULL, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		return soap_in_PointerTosaml2__ConditionAbstractType(soap, tag, NULL, "saml2:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		return soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, tag, NULL, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		return soap_in_PointerTosaml2__SubjectConfirmationType(soap, tag, NULL, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		return soap_in_PointerTosaml2__EncryptedElementType(soap, tag, NULL, "saml2:EncryptedElementType");
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		return soap_in_PointerTosaml2__BaseIDAbstractType(soap, tag, NULL, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		return soap_in_PointerTosaml2__AttributeStatementType(soap, tag, NULL, "saml2:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		return soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, tag, NULL, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		return soap_in_PointerTosaml2__AuthnStatementType(soap, tag, NULL, "saml2:AuthnStatementType");
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		return soap_in_PointerTosaml2__StatementAbstractType(soap, tag, NULL, "saml2:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		return soap_in_PointerTosaml2__AdviceType(soap, tag, NULL, "saml2:AdviceType");
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		return soap_in_PointerTosaml2__ConditionsType(soap, tag, NULL, "saml2:ConditionsType");
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		return soap_in_PointerTosaml2__SubjectType(soap, tag, NULL, "saml2:SubjectType");
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		return soap_in_PointerTosaml2__NameIDType(soap, tag, NULL, "saml2:NameIDType");
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		return soap_in_PointerToPointerToxenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		return soap_in_PointerTosaml1__AttributeType(soap, tag, NULL, "saml1:AttributeType");
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		return soap_in_PointerTosaml1__EvidenceType(soap, tag, NULL, "saml1:EvidenceType");
	case SOAP_TYPE_PointerTosaml1__ActionType:
		return soap_in_PointerTosaml1__ActionType(soap, tag, NULL, "saml1:ActionType");
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		return soap_in_PointerTosaml1__AuthorityBindingType(soap, tag, NULL, "saml1:AuthorityBindingType");
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		return soap_in_PointerTosaml1__SubjectLocalityType(soap, tag, NULL, "saml1:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		return soap_in_PointerTosaml1__SubjectType(soap, tag, NULL, "saml1:SubjectType");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		return soap_in_PointerTosaml1__SubjectConfirmationType(soap, tag, NULL, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		return soap_in_PointerTosaml1__NameIdentifierType(soap, tag, NULL, "saml1:NameIdentifierType");
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		return soap_in_PointerTosaml1__AssertionType(soap, tag, NULL, "saml1:AssertionType");
	case SOAP_TYPE_PointerToxsd__dateTime:
		return soap_in_PointerToxsd__dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		return soap_in_PointerTosaml1__ConditionAbstractType(soap, tag, NULL, "saml1:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		return soap_in_PointerTosaml1__DoNotCacheConditionType(soap, tag, NULL, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		return soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, NULL, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_PointerTo_ds__Signature:
		return soap_in_PointerTo_ds__Signature(soap, tag, NULL, "ds:Signature");
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		return soap_in_PointerTosaml1__AttributeStatementType(soap, tag, NULL, "saml1:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		return soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, NULL, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		return soap_in_PointerTosaml1__AuthenticationStatementType(soap, tag, NULL, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		return soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, tag, NULL, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		return soap_in_PointerTosaml1__StatementAbstractType(soap, tag, NULL, "saml1:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		return soap_in_PointerTosaml1__AdviceType(soap, tag, NULL, "saml1:AdviceType");
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		return soap_in_PointerTosaml1__ConditionsType(soap, tag, NULL, "saml1:ConditionsType");
	case SOAP_TYPE_PointerToULONG64:
		return soap_in_PointerToULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_in_PointerTowsc__PropertiesType(soap, tag, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
	{	char **s;
		s = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, NULL, "wsc:FaultCodeOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_in_PointerTo_xenc__ReferenceList(soap, tag, NULL, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_in_PointerToxenc__ReferenceType(soap, tag, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_in_PointerToxenc__TransformsType(soap, tag, NULL, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_in_PointerToxenc__CipherReferenceType(soap, tag, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_in_PointerToxenc__CipherDataType(soap, tag, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_in_PointerTo_ds__KeyInfo(soap, tag, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_in_PointerToxenc__EncryptionMethodType(soap, tag, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, tag, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, tag, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, tag, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, tag, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, tag, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, tag, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, tag, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, tag, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, tag, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, tag, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, tag, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, tag, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_in_PointerToxenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, tag, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, tag, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, tag, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_in_PointerTowsse__EncodedString(soap, tag, NULL, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, tag, NULL, "wsse:Password");
	case SOAP_TYPE_PointerTo_ns3__GetCertificateWithPin:
		return soap_in_PointerTo_ns3__GetCertificateWithPin(soap, tag, NULL, "ns3:GetCertificateWithPin");
	case SOAP_TYPE_PointerTo_ns3__ForceSMS:
		return soap_in_PointerTo_ns3__ForceSMS(soap, tag, NULL, "ns3:ForceSMS");
	case SOAP_TYPE_PointerTo_ns3__CCMovelMultipleSign:
		return soap_in_PointerTo_ns3__CCMovelMultipleSign(soap, tag, NULL, "ns3:CCMovelMultipleSign");
	case SOAP_TYPE_PointerTo_ns3__ValidateOtp:
		return soap_in_PointerTo_ns3__ValidateOtp(soap, tag, NULL, "ns3:ValidateOtp");
	case SOAP_TYPE_PointerTo_ns3__GetCertificate:
		return soap_in_PointerTo_ns3__GetCertificate(soap, tag, NULL, "ns3:GetCertificate");
	case SOAP_TYPE_PointerTo_ns3__CCMovelSign:
		return soap_in_PointerTo_ns3__CCMovelSign(soap, tag, NULL, "ns3:CCMovelSign");
	case SOAP_TYPE_PointerTons5__HashStructure:
		return soap_in_PointerTons5__HashStructure(soap, tag, NULL, "ns5:HashStructure");
	case SOAP_TYPE_PointerTons5__ArrayOfHashStructure:
		return soap_in_PointerTons5__ArrayOfHashStructure(soap, tag, NULL, "ns5:ArrayOfHashStructure");
	case SOAP_TYPE_PointerTons5__MultipleSignRequest:
		return soap_in_PointerTons5__MultipleSignRequest(soap, tag, NULL, "ns5:MultipleSignRequest");
	case SOAP_TYPE_PointerTons5__SignResponse:
		return soap_in_PointerTons5__SignResponse(soap, tag, NULL, "ns5:SignResponse");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons5__SignStatus:
		return soap_in_PointerTons5__SignStatus(soap, tag, NULL, "ns5:SignStatus");
	case SOAP_TYPE_PointerTons5__SignRequest:
		return soap_in_PointerTons5__SignRequest(soap, tag, NULL, "ns5:SignRequest");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns4:guid"))
		{	*type = SOAP_TYPE_ns4__guid__;
			return soap_in_ns4__guid__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:guid"))
		{	*type = SOAP_TYPE_ns4__guid;
			return soap_in_ns4__guid(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:duration"))
		{	*type = SOAP_TYPE_ns4__duration__;
			return soap_in_ns4__duration__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:duration"))
		{	*type = SOAP_TYPE_ns4__duration;
			return soap_in_ns4__duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:char"))
		{	*type = SOAP_TYPE_ns4__char__;
			return soap_in_ns4__char__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:MultipleSignRequest"))
		{	*type = SOAP_TYPE_ns5__MultipleSignRequest;
			return soap_in_ns5__MultipleSignRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:HashStructure"))
		{	*type = SOAP_TYPE_ns5__HashStructure;
			return soap_in_ns5__HashStructure(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfHashStructure"))
		{	*type = SOAP_TYPE_ns5__ArrayOfHashStructure;
			return soap_in_ns5__ArrayOfHashStructure(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignResponse"))
		{	*type = SOAP_TYPE_ns5__SignResponse;
			return soap_in_ns5__SignResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignStatus"))
		{	*type = SOAP_TYPE_ns5__SignStatus;
			return soap_in_ns5__SignStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignRequest"))
		{	*type = SOAP_TYPE_ns5__SignRequest;
			return soap_in_ns5__SignRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort_;
			return soap_in_xsd__unsignedShort_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong_;
			return soap_in_xsd__unsignedLong_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt_;
			return soap_in_xsd__unsignedInt_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte__;
			return soap_in_xsd__unsignedByte__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string_;
			return soap_in_xsd__string_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short_;
			return soap_in_xsd__short_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long_;
			return soap_in_xsd__long_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int_;
			return soap_in_xsd__int_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float_;
			return soap_in_xsd__float_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration__;
			return soap_in_xsd__duration__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double_;
			return soap_in_xsd__double_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal__;
			return soap_in_xsd__decimal__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime_;
			return soap_in_xsd__dateTime_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte__;
			return soap_in_xsd__byte__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean_;
			return soap_in_xsd__boolean_(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary__;
			return soap_in_xsd__base64Binary__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI__;
			return soap_in_xsd__anyURI__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName__;
			return soap_in_xsd__QName__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	*type = SOAP_TYPE_xsd__IDREF__;
			return soap_in_xsd__IDREF__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	*type = SOAP_TYPE_xsd__IDREF;
			return soap_in_xsd__IDREF(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID__;
			return soap_in_xsd__ID__(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID;
			return soap_in_xsd__ID(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:char"))
		{	*type = SOAP_TYPE_ns4__char;
			return soap_in_ns4__char(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:DecisionType"))
		{	*type = SOAP_TYPE_saml2__DecisionType;
			return soap_in_saml2__DecisionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DecisionType"))
		{	*type = SOAP_TYPE_saml1__DecisionType;
			return soap_in_saml1__DecisionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeType"))
		{	*type = SOAP_TYPE_wsc__FaultCodeType;
			return soap_in_wsc__FaultCodeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeType"))
		{	*type = SOAP_TYPE_saml2__AttributeType;
			return soap_in_saml2__AttributeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeStatementType"))
		{	*type = SOAP_TYPE_saml2__AttributeStatementType;
			return soap_in_saml2__AttributeStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EvidenceType"))
		{	*type = SOAP_TYPE_saml2__EvidenceType;
			return soap_in_saml2__EvidenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ActionType"))
		{	*type = SOAP_TYPE_saml2__ActionType;
			return soap_in_saml2__ActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthzDecisionStatementType"))
		{	*type = SOAP_TYPE_saml2__AuthzDecisionStatementType;
			return soap_in_saml2__AuthzDecisionStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextType"))
		{	*type = SOAP_TYPE_saml2__AuthnContextType;
			return soap_in_saml2__AuthnContextType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectLocalityType"))
		{	*type = SOAP_TYPE_saml2__SubjectLocalityType;
			return soap_in_saml2__SubjectLocalityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnStatementType"))
		{	*type = SOAP_TYPE_saml2__AuthnStatementType;
			return soap_in_saml2__AuthnStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:StatementAbstractType"))
		{	*type = SOAP_TYPE_saml2__StatementAbstractType;
			return soap_in_saml2__StatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AdviceType"))
		{	*type = SOAP_TYPE_saml2__AdviceType;
			return soap_in_saml2__AdviceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ProxyRestrictionType"))
		{	*type = SOAP_TYPE_saml2__ProxyRestrictionType;
			return soap_in_saml2__ProxyRestrictionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:OneTimeUseType"))
		{	*type = SOAP_TYPE_saml2__OneTimeUseType;
			return soap_in_saml2__OneTimeUseType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AudienceRestrictionType"))
		{	*type = SOAP_TYPE_saml2__AudienceRestrictionType;
			return soap_in_saml2__AudienceRestrictionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ConditionAbstractType"))
		{	*type = SOAP_TYPE_saml2__ConditionAbstractType;
			return soap_in_saml2__ConditionAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ConditionsType"))
		{	*type = SOAP_TYPE_saml2__ConditionsType;
			return soap_in_saml2__ConditionsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:KeyInfoConfirmationDataType"))
		{	*type = SOAP_TYPE_saml2__KeyInfoConfirmationDataType;
			return soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationDataType"))
		{	*type = SOAP_TYPE_saml2__SubjectConfirmationDataType;
			return soap_in_saml2__SubjectConfirmationDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationType"))
		{	*type = SOAP_TYPE_saml2__SubjectConfirmationType;
			return soap_in_saml2__SubjectConfirmationType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectType"))
		{	*type = SOAP_TYPE_saml2__SubjectType;
			return soap_in_saml2__SubjectType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionType"))
		{	*type = SOAP_TYPE_saml2__AssertionType;
			return soap_in_saml2__AssertionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedElementType"))
		{	*type = SOAP_TYPE_saml2__EncryptedElementType;
			return soap_in_saml2__EncryptedElementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:NameIDType"))
		{	*type = SOAP_TYPE_saml2__NameIDType;
			return soap_in_saml2__NameIDType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:BaseIDAbstractType"))
		{	*type = SOAP_TYPE_saml2__BaseIDAbstractType;
			return soap_in_saml2__BaseIDAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeType"))
		{	*type = SOAP_TYPE_saml1__AttributeType;
			return soap_in_saml1__AttributeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeDesignatorType"))
		{	*type = SOAP_TYPE_saml1__AttributeDesignatorType;
			return soap_in_saml1__AttributeDesignatorType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeStatementType"))
		{	*type = SOAP_TYPE_saml1__AttributeStatementType;
			return soap_in_saml1__AttributeStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:EvidenceType"))
		{	*type = SOAP_TYPE_saml1__EvidenceType;
			return soap_in_saml1__EvidenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ActionType"))
		{	*type = SOAP_TYPE_saml1__ActionType;
			return soap_in_saml1__ActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorizationDecisionStatementType"))
		{	*type = SOAP_TYPE_saml1__AuthorizationDecisionStatementType;
			return soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorityBindingType"))
		{	*type = SOAP_TYPE_saml1__AuthorityBindingType;
			return soap_in_saml1__AuthorityBindingType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectLocalityType"))
		{	*type = SOAP_TYPE_saml1__SubjectLocalityType;
			return soap_in_saml1__SubjectLocalityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthenticationStatementType"))
		{	*type = SOAP_TYPE_saml1__AuthenticationStatementType;
			return soap_in_saml1__AuthenticationStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectConfirmationType"))
		{	*type = SOAP_TYPE_saml1__SubjectConfirmationType;
			return soap_in_saml1__SubjectConfirmationType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:NameIdentifierType"))
		{	*type = SOAP_TYPE_saml1__NameIdentifierType;
			return soap_in_saml1__NameIdentifierType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectType"))
		{	*type = SOAP_TYPE_saml1__SubjectType;
			return soap_in_saml1__SubjectType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectStatementAbstractType"))
		{	*type = SOAP_TYPE_saml1__SubjectStatementAbstractType;
			return soap_in_saml1__SubjectStatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:StatementAbstractType"))
		{	*type = SOAP_TYPE_saml1__StatementAbstractType;
			return soap_in_saml1__StatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AdviceType"))
		{	*type = SOAP_TYPE_saml1__AdviceType;
			return soap_in_saml1__AdviceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DoNotCacheConditionType"))
		{	*type = SOAP_TYPE_saml1__DoNotCacheConditionType;
			return soap_in_saml1__DoNotCacheConditionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AudienceRestrictionConditionType"))
		{	*type = SOAP_TYPE_saml1__AudienceRestrictionConditionType;
			return soap_in_saml1__AudienceRestrictionConditionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ConditionAbstractType"))
		{	*type = SOAP_TYPE_saml1__ConditionAbstractType;
			return soap_in_saml1__ConditionAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ConditionsType"))
		{	*type = SOAP_TYPE_saml1__ConditionsType;
			return soap_in_saml1__ConditionsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AssertionType"))
		{	*type = SOAP_TYPE_saml1__AssertionType;
			return soap_in_saml1__AssertionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:PropertiesType"))
		{	*type = SOAP_TYPE_wsc__PropertiesType;
			return soap_in_wsc__PropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:DerivedKeyTokenType"))
		{	*type = SOAP_TYPE_wsc__DerivedKeyTokenType;
			return soap_in_wsc__DerivedKeyTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:SecurityContextTokenType"))
		{	*type = SOAP_TYPE_wsc__SecurityContextTokenType;
			return soap_in_wsc__SecurityContextTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertyType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertyType;
			return soap_in_xenc__EncryptionPropertyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertiesType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertiesType;
			return soap_in_xenc__EncryptionPropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceType"))
		{	*type = SOAP_TYPE_xenc__ReferenceType;
			return soap_in_xenc__ReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:AgreementMethodType"))
		{	*type = SOAP_TYPE_xenc__AgreementMethodType;
			return soap_in_xenc__AgreementMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedDataType"))
		{	*type = SOAP_TYPE_xenc__EncryptedDataType;
			return soap_in_xenc__EncryptedDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:TransformsType"))
		{	*type = SOAP_TYPE_xenc__TransformsType;
			return soap_in_xenc__TransformsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherReferenceType"))
		{	*type = SOAP_TYPE_xenc__CipherReferenceType;
			return soap_in_xenc__CipherReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherDataType"))
		{	*type = SOAP_TYPE_xenc__CipherDataType;
			return soap_in_xenc__CipherDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionMethodType"))
		{	*type = SOAP_TYPE_xenc__EncryptionMethodType;
			return soap_in_xenc__EncryptionMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedType"))
		{	*type = SOAP_TYPE_xenc__EncryptedType;
			return soap_in_xenc__EncryptedType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedKeyType"))
		{	*type = SOAP_TYPE_xenc__EncryptedKeyType;
			return soap_in_xenc__EncryptedKeyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:EncodedString"))
		{	*type = SOAP_TYPE_wsse__EncodedString;
			return soap_in_wsse__EncodedString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsc__FaultCodeOpenEnumType;
			s = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:GetCertificateWithPinResponse"))
		{	*type = SOAP_TYPE__ns3__GetCertificateWithPinResponse;
			return soap_in__ns3__GetCertificateWithPinResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCertificateWithPin"))
		{	*type = SOAP_TYPE__ns3__GetCertificateWithPin;
			return soap_in__ns3__GetCertificateWithPin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ForceSMSResponse"))
		{	*type = SOAP_TYPE__ns3__ForceSMSResponse;
			return soap_in__ns3__ForceSMSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ForceSMS"))
		{	*type = SOAP_TYPE__ns3__ForceSMS;
			return soap_in__ns3__ForceSMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CCMovelMultipleSignResponse"))
		{	*type = SOAP_TYPE__ns3__CCMovelMultipleSignResponse;
			return soap_in__ns3__CCMovelMultipleSignResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CCMovelMultipleSign"))
		{	*type = SOAP_TYPE__ns3__CCMovelMultipleSign;
			return soap_in__ns3__CCMovelMultipleSign(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ValidateOtpResponse"))
		{	*type = SOAP_TYPE__ns3__ValidateOtpResponse;
			return soap_in__ns3__ValidateOtpResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ValidateOtp"))
		{	*type = SOAP_TYPE__ns3__ValidateOtp;
			return soap_in__ns3__ValidateOtp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCertificateResponse"))
		{	*type = SOAP_TYPE__ns3__GetCertificateResponse;
			return soap_in__ns3__GetCertificateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCertificate"))
		{	*type = SOAP_TYPE__ns3__GetCertificate;
			return soap_in__ns3__GetCertificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CCMovelSignResponse"))
		{	*type = SOAP_TYPE__ns3__CCMovelSignResponse;
			return soap_in__ns3__CCMovelSignResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CCMovelSign"))
		{	*type = SOAP_TYPE__ns3__CCMovelSign;
			return soap_in__ns3__CCMovelSign(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedAttribute"))
		{	*type = SOAP_TYPE__saml2__EncryptedAttribute;
			return soap_in__saml2__EncryptedAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Attribute"))
		{	*type = SOAP_TYPE__saml2__Attribute;
			return soap_in__saml2__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeStatement"))
		{	*type = SOAP_TYPE__saml2__AttributeStatement;
			return soap_in__saml2__AttributeStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Evidence"))
		{	*type = SOAP_TYPE__saml2__Evidence;
			return soap_in__saml2__Evidence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Action"))
		{	*type = SOAP_TYPE__saml2__Action;
			return soap_in__saml2__Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthzDecisionStatement"))
		{	*type = SOAP_TYPE__saml2__AuthzDecisionStatement;
			return soap_in__saml2__AuthzDecisionStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContext"))
		{	*type = SOAP_TYPE__saml2__AuthnContext;
			return soap_in__saml2__AuthnContext(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectLocality"))
		{	*type = SOAP_TYPE__saml2__SubjectLocality;
			return soap_in__saml2__SubjectLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnStatement"))
		{	*type = SOAP_TYPE__saml2__AuthnStatement;
			return soap_in__saml2__AuthnStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Statement"))
		{	*type = SOAP_TYPE__saml2__Statement;
			return soap_in__saml2__Statement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedAssertion"))
		{	*type = SOAP_TYPE__saml2__EncryptedAssertion;
			return soap_in__saml2__EncryptedAssertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Advice"))
		{	*type = SOAP_TYPE__saml2__Advice;
			return soap_in__saml2__Advice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ProxyRestriction"))
		{	*type = SOAP_TYPE__saml2__ProxyRestriction;
			return soap_in__saml2__ProxyRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:OneTimeUse"))
		{	*type = SOAP_TYPE__saml2__OneTimeUse;
			return soap_in__saml2__OneTimeUse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AudienceRestriction"))
		{	*type = SOAP_TYPE__saml2__AudienceRestriction;
			return soap_in__saml2__AudienceRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Condition"))
		{	*type = SOAP_TYPE__saml2__Condition;
			return soap_in__saml2__Condition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Conditions"))
		{	*type = SOAP_TYPE__saml2__Conditions;
			return soap_in__saml2__Conditions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationData"))
		{	*type = SOAP_TYPE__saml2__SubjectConfirmationData;
			return soap_in__saml2__SubjectConfirmationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmation"))
		{	*type = SOAP_TYPE__saml2__SubjectConfirmation;
			return soap_in__saml2__SubjectConfirmation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Subject"))
		{	*type = SOAP_TYPE__saml2__Subject;
			return soap_in__saml2__Subject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Assertion"))
		{	*type = SOAP_TYPE__saml2__Assertion;
			return soap_in__saml2__Assertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Issuer"))
		{	*type = SOAP_TYPE__saml2__Issuer;
			return soap_in__saml2__Issuer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedID"))
		{	*type = SOAP_TYPE__saml2__EncryptedID;
			return soap_in__saml2__EncryptedID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:NameID"))
		{	*type = SOAP_TYPE__saml2__NameID;
			return soap_in__saml2__NameID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:BaseID"))
		{	*type = SOAP_TYPE__saml2__BaseID;
			return soap_in__saml2__BaseID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Attribute"))
		{	*type = SOAP_TYPE__saml1__Attribute;
			return soap_in__saml1__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeDesignator"))
		{	*type = SOAP_TYPE__saml1__AttributeDesignator;
			return soap_in__saml1__AttributeDesignator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeStatement"))
		{	*type = SOAP_TYPE__saml1__AttributeStatement;
			return soap_in__saml1__AttributeStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Evidence"))
		{	*type = SOAP_TYPE__saml1__Evidence;
			return soap_in__saml1__Evidence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Action"))
		{	*type = SOAP_TYPE__saml1__Action;
			return soap_in__saml1__Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorizationDecisionStatement"))
		{	*type = SOAP_TYPE__saml1__AuthorizationDecisionStatement;
			return soap_in__saml1__AuthorizationDecisionStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorityBinding"))
		{	*type = SOAP_TYPE__saml1__AuthorityBinding;
			return soap_in__saml1__AuthorityBinding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectLocality"))
		{	*type = SOAP_TYPE__saml1__SubjectLocality;
			return soap_in__saml1__SubjectLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthenticationStatement"))
		{	*type = SOAP_TYPE__saml1__AuthenticationStatement;
			return soap_in__saml1__AuthenticationStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectConfirmation"))
		{	*type = SOAP_TYPE__saml1__SubjectConfirmation;
			return soap_in__saml1__SubjectConfirmation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:NameIdentifier"))
		{	*type = SOAP_TYPE__saml1__NameIdentifier;
			return soap_in__saml1__NameIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Subject"))
		{	*type = SOAP_TYPE__saml1__Subject;
			return soap_in__saml1__Subject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectStatement"))
		{	*type = SOAP_TYPE__saml1__SubjectStatement;
			return soap_in__saml1__SubjectStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Statement"))
		{	*type = SOAP_TYPE__saml1__Statement;
			return soap_in__saml1__Statement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Advice"))
		{	*type = SOAP_TYPE__saml1__Advice;
			return soap_in__saml1__Advice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DoNotCacheCondition"))
		{	*type = SOAP_TYPE__saml1__DoNotCacheCondition;
			return soap_in__saml1__DoNotCacheCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AudienceRestrictionCondition"))
		{	*type = SOAP_TYPE__saml1__AudienceRestrictionCondition;
			return soap_in__saml1__AudienceRestrictionCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Condition"))
		{	*type = SOAP_TYPE__saml1__Condition;
			return soap_in__saml1__Condition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Conditions"))
		{	*type = SOAP_TYPE__saml1__Conditions;
			return soap_in__saml1__Conditions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Assertion"))
		{	*type = SOAP_TYPE__saml1__Assertion;
			return soap_in__saml1__Assertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceList"))
		{	*type = SOAP_TYPE__xenc__ReferenceList;
			return soap_in__xenc__ReferenceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfo"))
		{	*type = SOAP_TYPE__ds__KeyInfo;
			return soap_in__ds__KeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Transform"))
		{	*type = SOAP_TYPE__ds__Transform;
			return soap_in__ds__Transform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Signature"))
		{	*type = SOAP_TYPE__ds__Signature;
			return soap_in__ds__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthenticatingAuthority"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthenticatingAuthority;
			s = soap_in__saml2__AuthenticatingAuthority(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextDeclRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthnContextDeclRef;
			s = soap_in__saml2__AuthnContextDeclRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextClassRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthnContextClassRef;
			s = soap_in__saml2__AuthnContextClassRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:Audience"))
		{	char **s;
			*type = SOAP_TYPE__saml2__Audience;
			s = soap_in__saml2__Audience(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionURIRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AssertionURIRef;
			s = soap_in__saml2__AssertionURIRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionIDRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AssertionIDRef;
			s = soap_in__saml2__AssertionIDRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:ConfirmationMethod"))
		{	char **s;
			*type = SOAP_TYPE__saml1__ConfirmationMethod;
			s = soap_in__saml1__ConfirmationMethod(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:Audience"))
		{	char **s;
			*type = SOAP_TYPE__saml1__Audience;
			s = soap_in__saml1__Audience(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:AssertionIDReference"))
		{	char **s;
			*type = SOAP_TYPE__saml1__AssertionIDReference;
			s = soap_in__saml1__AssertionIDReference(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ds:SignatureValue"))
		{	char **s;
			*type = SOAP_TYPE__ds__SignatureValue;
			s = soap_in__ds__SignatureValue(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_ns4__char:
		return soap_out_ns4__char(soap, tag, id, (const int *)ptr, "ns4:char");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_saml2__DecisionType:
		return soap_out_saml2__DecisionType(soap, tag, id, (const enum saml2__DecisionType *)ptr, "saml2:DecisionType");
	case SOAP_TYPE_saml1__DecisionType:
		return soap_out_saml1__DecisionType(soap, tag, id, (const enum saml1__DecisionType *)ptr, "saml1:DecisionType");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_out_wsc__FaultCodeType(soap, tag, id, (const enum wsc__FaultCodeType *)ptr, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns4__guid__:
		return ((ns4__guid__ *)ptr)->soap_out(soap, tag, id, "ns4:guid");
	case SOAP_TYPE_ns4__guid:
		return soap_out_ns4__guid(soap, tag, id, (const std::string *)ptr, "ns4:guid");
	case SOAP_TYPE_ns4__duration__:
		return ((ns4__duration__ *)ptr)->soap_out(soap, tag, id, "ns4:duration");
	case SOAP_TYPE_ns4__duration:
		return soap_out_ns4__duration(soap, tag, id, (const std::string *)ptr, "ns4:duration");
	case SOAP_TYPE_ns4__char__:
		return ((ns4__char__ *)ptr)->soap_out(soap, tag, id, "ns4:char");
	case SOAP_TYPE_ns5__MultipleSignRequest:
		return ((ns5__MultipleSignRequest *)ptr)->soap_out(soap, tag, id, "ns5:MultipleSignRequest");
	case SOAP_TYPE_ns5__HashStructure:
		return ((ns5__HashStructure *)ptr)->soap_out(soap, tag, id, "ns5:HashStructure");
	case SOAP_TYPE_ns5__ArrayOfHashStructure:
		return ((ns5__ArrayOfHashStructure *)ptr)->soap_out(soap, tag, id, "ns5:ArrayOfHashStructure");
	case SOAP_TYPE_ns5__SignResponse:
		return ((ns5__SignResponse *)ptr)->soap_out(soap, tag, id, "ns5:SignResponse");
	case SOAP_TYPE_ns5__SignStatus:
		return ((ns5__SignStatus *)ptr)->soap_out(soap, tag, id, "ns5:SignStatus");
	case SOAP_TYPE_ns5__SignRequest:
		return ((ns5__SignRequest *)ptr)->soap_out(soap, tag, id, "ns5:SignRequest");
	case SOAP_TYPE__ns3__GetCertificateWithPinResponse:
		return ((_ns3__GetCertificateWithPinResponse *)ptr)->soap_out(soap, "ns3:GetCertificateWithPinResponse", id, "");
	case SOAP_TYPE__ns3__GetCertificateWithPin:
		return ((_ns3__GetCertificateWithPin *)ptr)->soap_out(soap, "ns3:GetCertificateWithPin", id, "");
	case SOAP_TYPE__ns3__ForceSMSResponse:
		return ((_ns3__ForceSMSResponse *)ptr)->soap_out(soap, "ns3:ForceSMSResponse", id, "");
	case SOAP_TYPE__ns3__ForceSMS:
		return ((_ns3__ForceSMS *)ptr)->soap_out(soap, "ns3:ForceSMS", id, "");
	case SOAP_TYPE__ns3__CCMovelMultipleSignResponse:
		return ((_ns3__CCMovelMultipleSignResponse *)ptr)->soap_out(soap, "ns3:CCMovelMultipleSignResponse", id, "");
	case SOAP_TYPE__ns3__CCMovelMultipleSign:
		return ((_ns3__CCMovelMultipleSign *)ptr)->soap_out(soap, "ns3:CCMovelMultipleSign", id, "");
	case SOAP_TYPE__ns3__ValidateOtpResponse:
		return ((_ns3__ValidateOtpResponse *)ptr)->soap_out(soap, "ns3:ValidateOtpResponse", id, "");
	case SOAP_TYPE__ns3__ValidateOtp:
		return ((_ns3__ValidateOtp *)ptr)->soap_out(soap, "ns3:ValidateOtp", id, "");
	case SOAP_TYPE__ns3__GetCertificateResponse:
		return ((_ns3__GetCertificateResponse *)ptr)->soap_out(soap, "ns3:GetCertificateResponse", id, "");
	case SOAP_TYPE__ns3__GetCertificate:
		return ((_ns3__GetCertificate *)ptr)->soap_out(soap, "ns3:GetCertificate", id, "");
	case SOAP_TYPE__ns3__CCMovelSignResponse:
		return ((_ns3__CCMovelSignResponse *)ptr)->soap_out(soap, "ns3:CCMovelSignResponse", id, "");
	case SOAP_TYPE__ns3__CCMovelSign:
		return ((_ns3__CCMovelSign *)ptr)->soap_out(soap, "ns3:CCMovelSign", id, "");
	case SOAP_TYPE_xsd__unsignedShort_:
		return ((xsd__unsignedShort_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong_:
		return ((xsd__unsignedLong_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt_:
		return ((xsd__unsignedInt_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte__:
		return ((xsd__unsignedByte__ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string_:
		return ((xsd__string_ *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__short_:
		return ((xsd__short_ *)ptr)->soap_out(soap, tag, id, "xsd:short");
	case SOAP_TYPE_xsd__long_:
		return ((xsd__long_ *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int_:
		return ((xsd__int_ *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__float_:
		return ((xsd__float_ *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__duration__:
		return ((xsd__duration__ *)ptr)->soap_out(soap, tag, id, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const std::string *)ptr, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return ((xsd__double_ *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__decimal__:
		return ((xsd__decimal__ *)ptr)->soap_out(soap, tag, id, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime_:
		return ((xsd__dateTime_ *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte__:
		return ((xsd__byte__ *)ptr)->soap_out(soap, tag, id, "xsd:byte");
	case SOAP_TYPE_xsd__boolean_:
		return ((xsd__boolean_ *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary__:
		return ((xsd__base64Binary__ *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI__:
		return ((xsd__anyURI__ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName__:
		return ((xsd__QName__ *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_xsd__IDREF__:
		return ((xsd__IDREF__ *)ptr)->soap_out(soap, tag, id, "xsd:IDREF");
	case SOAP_TYPE_xsd__IDREF:
		return soap_out_xsd__IDREF(soap, tag, id, (const std::string *)ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID__:
		return ((xsd__ID__ *)ptr)->soap_out(soap, tag, id, "xsd:ID");
	case SOAP_TYPE_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedAttribute:
		return soap_out__saml2__EncryptedAttribute(soap, "saml2:EncryptedAttribute", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__Attribute:
		return soap_out__saml2__Attribute(soap, "saml2:Attribute", id, (const struct saml2__AttributeType *)ptr, "");
	case SOAP_TYPE__saml2__AttributeStatement:
		return soap_out__saml2__AttributeStatement(soap, "saml2:AttributeStatement", id, (const struct saml2__AttributeStatementType *)ptr, "");
	case SOAP_TYPE__saml2__Evidence:
		return soap_out__saml2__Evidence(soap, "saml2:Evidence", id, (const struct saml2__EvidenceType *)ptr, "");
	case SOAP_TYPE__saml2__Action:
		return soap_out__saml2__Action(soap, "saml2:Action", id, (const struct saml2__ActionType *)ptr, "");
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		return soap_out__saml2__AuthzDecisionStatement(soap, "saml2:AuthzDecisionStatement", id, (const struct saml2__AuthzDecisionStatementType *)ptr, "");
	case SOAP_TYPE__saml2__AuthnContext:
		return soap_out__saml2__AuthnContext(soap, "saml2:AuthnContext", id, (const struct saml2__AuthnContextType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectLocality:
		return soap_out__saml2__SubjectLocality(soap, "saml2:SubjectLocality", id, (const struct saml2__SubjectLocalityType *)ptr, "");
	case SOAP_TYPE__saml2__AuthnStatement:
		return soap_out__saml2__AuthnStatement(soap, "saml2:AuthnStatement", id, (const struct saml2__AuthnStatementType *)ptr, "");
	case SOAP_TYPE__saml2__Statement:
		return soap_out__saml2__Statement(soap, "saml2:Statement", id, (const struct saml2__StatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedAssertion:
		return soap_out__saml2__EncryptedAssertion(soap, "saml2:EncryptedAssertion", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__Advice:
		return soap_out__saml2__Advice(soap, "saml2:Advice", id, (const struct saml2__AdviceType *)ptr, "");
	case SOAP_TYPE__saml2__ProxyRestriction:
		return soap_out__saml2__ProxyRestriction(soap, "saml2:ProxyRestriction", id, (const struct saml2__ProxyRestrictionType *)ptr, "");
	case SOAP_TYPE__saml2__OneTimeUse:
		return soap_out__saml2__OneTimeUse(soap, "saml2:OneTimeUse", id, (const struct saml2__OneTimeUseType *)ptr, "");
	case SOAP_TYPE__saml2__AudienceRestriction:
		return soap_out__saml2__AudienceRestriction(soap, "saml2:AudienceRestriction", id, (const struct saml2__AudienceRestrictionType *)ptr, "");
	case SOAP_TYPE__saml2__Condition:
		return soap_out__saml2__Condition(soap, "saml2:Condition", id, (const struct saml2__ConditionAbstractType *)ptr, "");
	case SOAP_TYPE__saml2__Conditions:
		return soap_out__saml2__Conditions(soap, "saml2:Conditions", id, (const struct saml2__ConditionsType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		return soap_out__saml2__SubjectConfirmationData(soap, "saml2:SubjectConfirmationData", id, (const struct saml2__SubjectConfirmationDataType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectConfirmation:
		return soap_out__saml2__SubjectConfirmation(soap, "saml2:SubjectConfirmation", id, (const struct saml2__SubjectConfirmationType *)ptr, "");
	case SOAP_TYPE__saml2__Subject:
		return soap_out__saml2__Subject(soap, "saml2:Subject", id, (const struct saml2__SubjectType *)ptr, "");
	case SOAP_TYPE__saml2__Assertion:
		return soap_out__saml2__Assertion(soap, "saml2:Assertion", id, (const struct saml2__AssertionType *)ptr, "");
	case SOAP_TYPE__saml2__Issuer:
		return soap_out__saml2__Issuer(soap, "saml2:Issuer", id, (const struct saml2__NameIDType *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedID:
		return soap_out__saml2__EncryptedID(soap, "saml2:EncryptedID", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__NameID:
		return soap_out__saml2__NameID(soap, "saml2:NameID", id, (const struct saml2__NameIDType *)ptr, "");
	case SOAP_TYPE__saml2__BaseID:
		return soap_out__saml2__BaseID(soap, "saml2:BaseID", id, (const struct saml2__BaseIDAbstractType *)ptr, "");
	case SOAP_TYPE_saml2__AttributeType:
		return soap_out_saml2__AttributeType(soap, tag, id, (const struct saml2__AttributeType *)ptr, "saml2:AttributeType");
	case SOAP_TYPE_saml2__AttributeStatementType:
		return soap_out_saml2__AttributeStatementType(soap, tag, id, (const struct saml2__AttributeStatementType *)ptr, "saml2:AttributeStatementType");
	case SOAP_TYPE_saml2__EvidenceType:
		return soap_out_saml2__EvidenceType(soap, tag, id, (const struct saml2__EvidenceType *)ptr, "saml2:EvidenceType");
	case SOAP_TYPE_saml2__ActionType:
		return soap_out_saml2__ActionType(soap, tag, id, (const struct saml2__ActionType *)ptr, "saml2:ActionType");
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return soap_out_saml2__AuthzDecisionStatementType(soap, tag, id, (const struct saml2__AuthzDecisionStatementType *)ptr, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_saml2__AuthnContextType:
		return soap_out_saml2__AuthnContextType(soap, tag, id, (const struct saml2__AuthnContextType *)ptr, "saml2:AuthnContextType");
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return soap_out_saml2__SubjectLocalityType(soap, tag, id, (const struct saml2__SubjectLocalityType *)ptr, "saml2:SubjectLocalityType");
	case SOAP_TYPE_saml2__AuthnStatementType:
		return soap_out_saml2__AuthnStatementType(soap, tag, id, (const struct saml2__AuthnStatementType *)ptr, "saml2:AuthnStatementType");
	case SOAP_TYPE_saml2__StatementAbstractType:
		return soap_out_saml2__StatementAbstractType(soap, tag, id, (const struct saml2__StatementAbstractType *)ptr, "saml2:StatementAbstractType");
	case SOAP_TYPE_saml2__AdviceType:
		return soap_out_saml2__AdviceType(soap, tag, id, (const struct saml2__AdviceType *)ptr, "saml2:AdviceType");
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return soap_out_saml2__ProxyRestrictionType(soap, tag, id, (const struct saml2__ProxyRestrictionType *)ptr, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_saml2__OneTimeUseType:
		return soap_out_saml2__OneTimeUseType(soap, tag, id, (const struct saml2__OneTimeUseType *)ptr, "saml2:OneTimeUseType");
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return soap_out_saml2__AudienceRestrictionType(soap, tag, id, (const struct saml2__AudienceRestrictionType *)ptr, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return soap_out_saml2__ConditionAbstractType(soap, tag, id, (const struct saml2__ConditionAbstractType *)ptr, "saml2:ConditionAbstractType");
	case SOAP_TYPE_saml2__ConditionsType:
		return soap_out_saml2__ConditionsType(soap, tag, id, (const struct saml2__ConditionsType *)ptr, "saml2:ConditionsType");
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return soap_out_saml2__KeyInfoConfirmationDataType(soap, tag, id, (const struct saml2__KeyInfoConfirmationDataType *)ptr, "saml2:KeyInfoConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return soap_out_saml2__SubjectConfirmationDataType(soap, tag, id, (const struct saml2__SubjectConfirmationDataType *)ptr, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return soap_out_saml2__SubjectConfirmationType(soap, tag, id, (const struct saml2__SubjectConfirmationType *)ptr, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_saml2__SubjectType:
		return soap_out_saml2__SubjectType(soap, tag, id, (const struct saml2__SubjectType *)ptr, "saml2:SubjectType");
	case SOAP_TYPE_saml2__AssertionType:
		return soap_out_saml2__AssertionType(soap, tag, id, (const struct saml2__AssertionType *)ptr, "saml2:AssertionType");
	case SOAP_TYPE_saml2__EncryptedElementType:
		return soap_out_saml2__EncryptedElementType(soap, tag, id, (const struct saml2__EncryptedElementType *)ptr, "saml2:EncryptedElementType");
	case SOAP_TYPE_saml2__NameIDType:
		return soap_out_saml2__NameIDType(soap, tag, id, (const struct saml2__NameIDType *)ptr, "saml2:NameIDType");
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return soap_out_saml2__BaseIDAbstractType(soap, tag, id, (const struct saml2__BaseIDAbstractType *)ptr, "saml2:BaseIDAbstractType");
	case SOAP_TYPE__saml1__Attribute:
		return soap_out__saml1__Attribute(soap, "saml1:Attribute", id, (const struct saml1__AttributeType *)ptr, "");
	case SOAP_TYPE__saml1__AttributeDesignator:
		return soap_out__saml1__AttributeDesignator(soap, "saml1:AttributeDesignator", id, (const struct saml1__AttributeDesignatorType *)ptr, "");
	case SOAP_TYPE__saml1__AttributeStatement:
		return soap_out__saml1__AttributeStatement(soap, "saml1:AttributeStatement", id, (const struct saml1__AttributeStatementType *)ptr, "");
	case SOAP_TYPE__saml1__Evidence:
		return soap_out__saml1__Evidence(soap, "saml1:Evidence", id, (const struct saml1__EvidenceType *)ptr, "");
	case SOAP_TYPE__saml1__Action:
		return soap_out__saml1__Action(soap, "saml1:Action", id, (const struct saml1__ActionType *)ptr, "");
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		return soap_out__saml1__AuthorizationDecisionStatement(soap, "saml1:AuthorizationDecisionStatement", id, (const struct saml1__AuthorizationDecisionStatementType *)ptr, "");
	case SOAP_TYPE__saml1__AuthorityBinding:
		return soap_out__saml1__AuthorityBinding(soap, "saml1:AuthorityBinding", id, (const struct saml1__AuthorityBindingType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectLocality:
		return soap_out__saml1__SubjectLocality(soap, "saml1:SubjectLocality", id, (const struct saml1__SubjectLocalityType *)ptr, "");
	case SOAP_TYPE__saml1__AuthenticationStatement:
		return soap_out__saml1__AuthenticationStatement(soap, "saml1:AuthenticationStatement", id, (const struct saml1__AuthenticationStatementType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectConfirmation:
		return soap_out__saml1__SubjectConfirmation(soap, "saml1:SubjectConfirmation", id, (const struct saml1__SubjectConfirmationType *)ptr, "");
	case SOAP_TYPE__saml1__NameIdentifier:
		return soap_out__saml1__NameIdentifier(soap, "saml1:NameIdentifier", id, (const struct saml1__NameIdentifierType *)ptr, "");
	case SOAP_TYPE__saml1__Subject:
		return soap_out__saml1__Subject(soap, "saml1:Subject", id, (const struct saml1__SubjectType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectStatement:
		return soap_out__saml1__SubjectStatement(soap, "saml1:SubjectStatement", id, (const struct saml1__SubjectStatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Statement:
		return soap_out__saml1__Statement(soap, "saml1:Statement", id, (const struct saml1__StatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Advice:
		return soap_out__saml1__Advice(soap, "saml1:Advice", id, (const struct saml1__AdviceType *)ptr, "");
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		return soap_out__saml1__DoNotCacheCondition(soap, "saml1:DoNotCacheCondition", id, (const struct saml1__DoNotCacheConditionType *)ptr, "");
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		return soap_out__saml1__AudienceRestrictionCondition(soap, "saml1:AudienceRestrictionCondition", id, (const struct saml1__AudienceRestrictionConditionType *)ptr, "");
	case SOAP_TYPE__saml1__Condition:
		return soap_out__saml1__Condition(soap, "saml1:Condition", id, (const struct saml1__ConditionAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Conditions:
		return soap_out__saml1__Conditions(soap, "saml1:Conditions", id, (const struct saml1__ConditionsType *)ptr, "");
	case SOAP_TYPE__saml1__Assertion:
		return soap_out__saml1__Assertion(soap, "saml1:Assertion", id, (const struct saml1__AssertionType *)ptr, "");
	case SOAP_TYPE_saml1__AttributeType:
		return soap_out_saml1__AttributeType(soap, tag, id, (const struct saml1__AttributeType *)ptr, "saml1:AttributeType");
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return soap_out_saml1__AttributeDesignatorType(soap, tag, id, (const struct saml1__AttributeDesignatorType *)ptr, "saml1:AttributeDesignatorType");
	case SOAP_TYPE_saml1__AttributeStatementType:
		return soap_out_saml1__AttributeStatementType(soap, tag, id, (const struct saml1__AttributeStatementType *)ptr, "saml1:AttributeStatementType");
	case SOAP_TYPE_saml1__EvidenceType:
		return soap_out_saml1__EvidenceType(soap, tag, id, (const struct saml1__EvidenceType *)ptr, "saml1:EvidenceType");
	case SOAP_TYPE_saml1__ActionType:
		return soap_out_saml1__ActionType(soap, tag, id, (const struct saml1__ActionType *)ptr, "saml1:ActionType");
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return soap_out_saml1__AuthorizationDecisionStatementType(soap, tag, id, (const struct saml1__AuthorizationDecisionStatementType *)ptr, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return soap_out_saml1__AuthorityBindingType(soap, tag, id, (const struct saml1__AuthorityBindingType *)ptr, "saml1:AuthorityBindingType");
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return soap_out_saml1__SubjectLocalityType(soap, tag, id, (const struct saml1__SubjectLocalityType *)ptr, "saml1:SubjectLocalityType");
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return soap_out_saml1__AuthenticationStatementType(soap, tag, id, (const struct saml1__AuthenticationStatementType *)ptr, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return soap_out_saml1__SubjectConfirmationType(soap, tag, id, (const struct saml1__SubjectConfirmationType *)ptr, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_saml1__NameIdentifierType:
		return soap_out_saml1__NameIdentifierType(soap, tag, id, (const struct saml1__NameIdentifierType *)ptr, "saml1:NameIdentifierType");
	case SOAP_TYPE_saml1__SubjectType:
		return soap_out_saml1__SubjectType(soap, tag, id, (const struct saml1__SubjectType *)ptr, "saml1:SubjectType");
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return soap_out_saml1__SubjectStatementAbstractType(soap, tag, id, (const struct saml1__SubjectStatementAbstractType *)ptr, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_saml1__StatementAbstractType:
		return soap_out_saml1__StatementAbstractType(soap, tag, id, (const struct saml1__StatementAbstractType *)ptr, "saml1:StatementAbstractType");
	case SOAP_TYPE_saml1__AdviceType:
		return soap_out_saml1__AdviceType(soap, tag, id, (const struct saml1__AdviceType *)ptr, "saml1:AdviceType");
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return soap_out_saml1__DoNotCacheConditionType(soap, tag, id, (const struct saml1__DoNotCacheConditionType *)ptr, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return soap_out_saml1__AudienceRestrictionConditionType(soap, tag, id, (const struct saml1__AudienceRestrictionConditionType *)ptr, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return soap_out_saml1__ConditionAbstractType(soap, tag, id, (const struct saml1__ConditionAbstractType *)ptr, "saml1:ConditionAbstractType");
	case SOAP_TYPE_saml1__ConditionsType:
		return soap_out_saml1__ConditionsType(soap, tag, id, (const struct saml1__ConditionsType *)ptr, "saml1:ConditionsType");
	case SOAP_TYPE_saml1__AssertionType:
		return soap_out_saml1__AssertionType(soap, tag, id, (const struct saml1__AssertionType *)ptr, "saml1:AssertionType");
	case SOAP_TYPE_xsd__dateTime:
		return soap_out_xsd__dateTime(soap, tag, id, (const struct timeval *)ptr, "xsd:dateTime");
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_out_wsc__PropertiesType(soap, tag, id, (const struct wsc__PropertiesType *)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_out_wsc__DerivedKeyTokenType(soap, tag, id, (const struct wsc__DerivedKeyTokenType *)ptr, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_out_wsc__SecurityContextTokenType(soap, tag, id, (const struct wsc__SecurityContextTokenType *)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE__xenc__ReferenceList:
		return soap_out__xenc__ReferenceList(soap, "xenc:ReferenceList", id, (const struct _xenc__ReferenceList *)ptr, "");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_out_xenc__EncryptionPropertyType(soap, tag, id, (const struct xenc__EncryptionPropertyType *)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, (const struct xenc__EncryptionPropertiesType *)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_out_xenc__ReferenceType(soap, tag, id, (const struct xenc__ReferenceType *)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_out_xenc__AgreementMethodType(soap, tag, id, (const struct xenc__AgreementMethodType *)ptr, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_out_xenc__EncryptedDataType(soap, tag, id, (const struct xenc__EncryptedDataType *)ptr, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_out_xenc__TransformsType(soap, tag, id, (const struct xenc__TransformsType *)ptr, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_out_xenc__CipherReferenceType(soap, tag, id, (const struct xenc__CipherReferenceType *)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_out_xenc__CipherDataType(soap, tag, id, (const struct xenc__CipherDataType *)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_out_xenc__EncryptionMethodType(soap, tag, id, (const struct xenc__EncryptionMethodType *)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_out_xenc__EncryptedType(soap, tag, id, (const struct xenc__EncryptedType *)ptr, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE__ds__KeyInfo:
		return soap_out__ds__KeyInfo(soap, "ds:KeyInfo", id, (const struct ds__KeyInfoType *)ptr, "");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE__ds__Transform:
		return soap_out__ds__Transform(soap, "ds:Transform", id, (const struct ds__TransformType *)ptr, "");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, "");
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE__ds__Signature:
		return soap_out__ds__Signature(soap, "ds:Signature", id, (const struct ds__SignatureType *)ptr, "");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_out_xenc__EncryptedKeyType(soap, tag, id, (const struct xenc__EncryptedKeyType *)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, "");
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, "");
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, "");
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, "");
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, "");
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, "");
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, "");
	case SOAP_TYPE_wsse__EncodedString:
		return soap_out_wsse__EncodedString(soap, tag, id, (const struct wsse__EncodedString *)ptr, "wsse:EncodedString");
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, "");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_out_PointerTowsc__SecurityContextTokenType(soap, tag, id, (struct wsc__SecurityContextTokenType *const*)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE__saml2__AuthenticatingAuthority:
		return soap_out_string(soap, "saml2:AuthenticatingAuthority", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AuthnContextDeclRef:
		return soap_out_string(soap, "saml2:AuthnContextDeclRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AuthnContextClassRef:
		return soap_out_string(soap, "saml2:AuthnContextClassRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__Audience:
		return soap_out_string(soap, "saml2:Audience", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AssertionURIRef:
		return soap_out_string(soap, "saml2:AssertionURIRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AssertionIDRef:
		return soap_out_string(soap, "saml2:AssertionIDRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		return soap_out_PointerToPointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType **const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		return soap_out_PointerTosaml2__AttributeType(soap, tag, id, (struct saml2__AttributeType *const*)ptr, "saml2:AttributeType");
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		return soap_out_PointerTosaml2__EvidenceType(soap, tag, id, (struct saml2__EvidenceType *const*)ptr, "saml2:EvidenceType");
	case SOAP_TYPE_PointerTosaml2__ActionType:
		return soap_out_PointerTosaml2__ActionType(soap, tag, id, (struct saml2__ActionType *const*)ptr, "saml2:ActionType");
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		return soap_out_PointerTosaml2__AuthnContextType(soap, tag, id, (struct saml2__AuthnContextType *const*)ptr, "saml2:AuthnContextType");
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		return soap_out_PointerTosaml2__SubjectLocalityType(soap, tag, id, (struct saml2__SubjectLocalityType *const*)ptr, "saml2:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		return soap_out_PointerTosaml2__AssertionType(soap, tag, id, (struct saml2__AssertionType *const*)ptr, "saml2:AssertionType");
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		return soap_out_PointerTosaml2__ProxyRestrictionType(soap, tag, id, (struct saml2__ProxyRestrictionType *const*)ptr, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		return soap_out_PointerTosaml2__OneTimeUseType(soap, tag, id, (struct saml2__OneTimeUseType *const*)ptr, "saml2:OneTimeUseType");
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		return soap_out_PointerTosaml2__AudienceRestrictionType(soap, tag, id, (struct saml2__AudienceRestrictionType *const*)ptr, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		return soap_out_PointerTosaml2__ConditionAbstractType(soap, tag, id, (struct saml2__ConditionAbstractType *const*)ptr, "saml2:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		return soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, tag, id, (struct saml2__SubjectConfirmationDataType *const*)ptr, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		return soap_out_PointerTosaml2__SubjectConfirmationType(soap, tag, id, (struct saml2__SubjectConfirmationType *const*)ptr, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		return soap_out_PointerTosaml2__EncryptedElementType(soap, tag, id, (struct saml2__EncryptedElementType *const*)ptr, "saml2:EncryptedElementType");
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		return soap_out_PointerTosaml2__BaseIDAbstractType(soap, tag, id, (struct saml2__BaseIDAbstractType *const*)ptr, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		return soap_out_PointerTosaml2__AttributeStatementType(soap, tag, id, (struct saml2__AttributeStatementType *const*)ptr, "saml2:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		return soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, tag, id, (struct saml2__AuthzDecisionStatementType *const*)ptr, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		return soap_out_PointerTosaml2__AuthnStatementType(soap, tag, id, (struct saml2__AuthnStatementType *const*)ptr, "saml2:AuthnStatementType");
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		return soap_out_PointerTosaml2__StatementAbstractType(soap, tag, id, (struct saml2__StatementAbstractType *const*)ptr, "saml2:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		return soap_out_PointerTosaml2__AdviceType(soap, tag, id, (struct saml2__AdviceType *const*)ptr, "saml2:AdviceType");
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		return soap_out_PointerTosaml2__ConditionsType(soap, tag, id, (struct saml2__ConditionsType *const*)ptr, "saml2:ConditionsType");
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		return soap_out_PointerTosaml2__SubjectType(soap, tag, id, (struct saml2__SubjectType *const*)ptr, "saml2:SubjectType");
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		return soap_out_PointerTosaml2__NameIDType(soap, tag, id, (struct saml2__NameIDType *const*)ptr, "saml2:NameIDType");
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		return soap_out_PointerToPointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType **const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE__saml1__ConfirmationMethod:
		return soap_out_string(soap, "saml1:ConfirmationMethod", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml1__Audience:
		return soap_out_string(soap, "saml1:Audience", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml1__AssertionIDReference:
		return soap_out_string(soap, "saml1:AssertionIDReference", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		return soap_out_PointerTosaml1__AttributeType(soap, tag, id, (struct saml1__AttributeType *const*)ptr, "saml1:AttributeType");
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		return soap_out_PointerTosaml1__EvidenceType(soap, tag, id, (struct saml1__EvidenceType *const*)ptr, "saml1:EvidenceType");
	case SOAP_TYPE_PointerTosaml1__ActionType:
		return soap_out_PointerTosaml1__ActionType(soap, tag, id, (struct saml1__ActionType *const*)ptr, "saml1:ActionType");
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		return soap_out_PointerTosaml1__AuthorityBindingType(soap, tag, id, (struct saml1__AuthorityBindingType *const*)ptr, "saml1:AuthorityBindingType");
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		return soap_out_PointerTosaml1__SubjectLocalityType(soap, tag, id, (struct saml1__SubjectLocalityType *const*)ptr, "saml1:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		return soap_out_PointerTosaml1__SubjectType(soap, tag, id, (struct saml1__SubjectType *const*)ptr, "saml1:SubjectType");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		return soap_out_PointerTosaml1__SubjectConfirmationType(soap, tag, id, (struct saml1__SubjectConfirmationType *const*)ptr, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		return soap_out_PointerTosaml1__NameIdentifierType(soap, tag, id, (struct saml1__NameIdentifierType *const*)ptr, "saml1:NameIdentifierType");
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		return soap_out_PointerTosaml1__AssertionType(soap, tag, id, (struct saml1__AssertionType *const*)ptr, "saml1:AssertionType");
	case SOAP_TYPE_PointerToxsd__dateTime:
		return soap_out_PointerToxsd__dateTime(soap, tag, id, (struct timeval *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		return soap_out_PointerTosaml1__ConditionAbstractType(soap, tag, id, (struct saml1__ConditionAbstractType *const*)ptr, "saml1:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		return soap_out_PointerTosaml1__DoNotCacheConditionType(soap, tag, id, (struct saml1__DoNotCacheConditionType *const*)ptr, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		return soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, id, (struct saml1__AudienceRestrictionConditionType *const*)ptr, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_PointerTo_ds__Signature:
		return soap_out_PointerTo_ds__Signature(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:Signature");
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		return soap_out_PointerTosaml1__AttributeStatementType(soap, tag, id, (struct saml1__AttributeStatementType *const*)ptr, "saml1:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		return soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, id, (struct saml1__AuthorizationDecisionStatementType *const*)ptr, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		return soap_out_PointerTosaml1__AuthenticationStatementType(soap, tag, id, (struct saml1__AuthenticationStatementType *const*)ptr, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		return soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, tag, id, (struct saml1__SubjectStatementAbstractType *const*)ptr, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		return soap_out_PointerTosaml1__StatementAbstractType(soap, tag, id, (struct saml1__StatementAbstractType *const*)ptr, "saml1:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		return soap_out_PointerTosaml1__AdviceType(soap, tag, id, (struct saml1__AdviceType *const*)ptr, "saml1:AdviceType");
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		return soap_out_PointerTosaml1__ConditionsType(soap, tag, id, (struct saml1__ConditionsType *const*)ptr, "saml1:ConditionsType");
	case SOAP_TYPE_PointerToULONG64:
		return soap_out_PointerToULONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_out_PointerTowsc__PropertiesType(soap, tag, id, (struct wsc__PropertiesType *const*)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsc:FaultCodeOpenEnumType");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_out_PointerTo_xenc__ReferenceList(soap, tag, id, (struct _xenc__ReferenceList *const*)ptr, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_out_PointerToxenc__ReferenceType(soap, tag, id, (struct xenc__ReferenceType *const*)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_out_PointerToxenc__EncryptionPropertyType(soap, tag, id, (struct xenc__EncryptionPropertyType *const*)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_out_PointerToxenc__TransformsType(soap, tag, id, (struct xenc__TransformsType *const*)ptr, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_out_PointerToxenc__CipherReferenceType(soap, tag, id, (struct xenc__CipherReferenceType *const*)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag, id, (struct xenc__EncryptionPropertiesType *const*)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_out_PointerToxenc__CipherDataType(soap, tag, id, (struct xenc__CipherDataType *const*)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_out_PointerToxenc__EncryptionMethodType(soap, tag, id, (struct xenc__EncryptionMethodType *const*)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE__ds__SignatureValue:
		return soap_out_string(soap, "ds:SignatureValue", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_out_PointerTowsse__EncodedString(soap, tag, id, (struct wsse__EncodedString *const*)ptr, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE_PointerTo_ns3__GetCertificateWithPin:
		return soap_out_PointerTo_ns3__GetCertificateWithPin(soap, tag, id, (_ns3__GetCertificateWithPin *const*)ptr, "ns3:GetCertificateWithPin");
	case SOAP_TYPE_PointerTo_ns3__ForceSMS:
		return soap_out_PointerTo_ns3__ForceSMS(soap, tag, id, (_ns3__ForceSMS *const*)ptr, "ns3:ForceSMS");
	case SOAP_TYPE_PointerTo_ns3__CCMovelMultipleSign:
		return soap_out_PointerTo_ns3__CCMovelMultipleSign(soap, tag, id, (_ns3__CCMovelMultipleSign *const*)ptr, "ns3:CCMovelMultipleSign");
	case SOAP_TYPE_PointerTo_ns3__ValidateOtp:
		return soap_out_PointerTo_ns3__ValidateOtp(soap, tag, id, (_ns3__ValidateOtp *const*)ptr, "ns3:ValidateOtp");
	case SOAP_TYPE_PointerTo_ns3__GetCertificate:
		return soap_out_PointerTo_ns3__GetCertificate(soap, tag, id, (_ns3__GetCertificate *const*)ptr, "ns3:GetCertificate");
	case SOAP_TYPE_PointerTo_ns3__CCMovelSign:
		return soap_out_PointerTo_ns3__CCMovelSign(soap, tag, id, (_ns3__CCMovelSign *const*)ptr, "ns3:CCMovelSign");
	case SOAP_TYPE_PointerTons5__HashStructure:
		return soap_out_PointerTons5__HashStructure(soap, tag, id, (ns5__HashStructure *const*)ptr, "ns5:HashStructure");
	case SOAP_TYPE_PointerTons5__ArrayOfHashStructure:
		return soap_out_PointerTons5__ArrayOfHashStructure(soap, tag, id, (ns5__ArrayOfHashStructure *const*)ptr, "ns5:ArrayOfHashStructure");
	case SOAP_TYPE_PointerTons5__MultipleSignRequest:
		return soap_out_PointerTons5__MultipleSignRequest(soap, tag, id, (ns5__MultipleSignRequest *const*)ptr, "ns5:MultipleSignRequest");
	case SOAP_TYPE_PointerTons5__SignResponse:
		return soap_out_PointerTons5__SignResponse(soap, tag, id, (ns5__SignResponse *const*)ptr, "ns5:SignResponse");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons5__SignStatus:
		return soap_out_PointerTons5__SignStatus(soap, tag, id, (ns5__SignStatus *const*)ptr, "ns5:SignStatus");
	case SOAP_TYPE_PointerTons5__SignRequest:
		return soap_out_PointerTons5__SignRequest(soap, tag, id, (ns5__SignRequest *const*)ptr, "ns5:SignRequest");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns4__guid__:
		((ns4__guid__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__guid:
		soap_serialize_ns4__guid(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__duration__:
		((ns4__duration__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__duration:
		soap_serialize_ns4__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__char__:
		((ns4__char__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__MultipleSignRequest:
		((ns5__MultipleSignRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__HashStructure:
		((ns5__HashStructure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ArrayOfHashStructure:
		((ns5__ArrayOfHashStructure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SignResponse:
		((ns5__SignResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SignStatus:
		((ns5__SignStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SignRequest:
		((ns5__SignRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCertificateWithPinResponse:
		((_ns3__GetCertificateWithPinResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCertificateWithPin:
		((_ns3__GetCertificateWithPin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__ForceSMSResponse:
		((_ns3__ForceSMSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__ForceSMS:
		((_ns3__ForceSMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CCMovelMultipleSignResponse:
		((_ns3__CCMovelMultipleSignResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CCMovelMultipleSign:
		((_ns3__CCMovelMultipleSign *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__ValidateOtpResponse:
		((_ns3__ValidateOtpResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__ValidateOtp:
		((_ns3__ValidateOtp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCertificateResponse:
		((_ns3__GetCertificateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCertificate:
		((_ns3__GetCertificate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CCMovelSignResponse:
		((_ns3__CCMovelSignResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CCMovelSign:
		((_ns3__CCMovelSign *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedShort_:
		((xsd__unsignedShort_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedLong_:
		((xsd__unsignedLong_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedInt_:
		((xsd__unsignedInt_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedByte__:
		((xsd__unsignedByte__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string_:
		((xsd__string_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__short_:
		((xsd__short_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long_:
		((xsd__long_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int_:
		((xsd__int_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__float_:
		((xsd__float_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration__:
		((xsd__duration__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_xsd__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__double_:
		((xsd__double_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal__:
		((xsd__decimal__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime_:
		((xsd__dateTime_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__byte__:
		((xsd__byte__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean_:
		((xsd__boolean_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary__:
		((xsd__base64Binary__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI__:
		((xsd__anyURI__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName__:
		((xsd__QName__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__IDREF__:
		((xsd__IDREF__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__IDREF:
		soap_serialize_xsd__IDREF(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__ID__:
		((xsd__ID__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedAttribute:
		soap_serialize__saml2__EncryptedAttribute(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Attribute:
		soap_serialize__saml2__Attribute(soap, (const struct saml2__AttributeType *)ptr);
		break;
	case SOAP_TYPE__saml2__AttributeStatement:
		soap_serialize__saml2__AttributeStatement(soap, (const struct saml2__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Evidence:
		soap_serialize__saml2__Evidence(soap, (const struct saml2__EvidenceType *)ptr);
		break;
	case SOAP_TYPE__saml2__Action:
		soap_serialize__saml2__Action(soap, (const struct saml2__ActionType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		soap_serialize__saml2__AuthzDecisionStatement(soap, (const struct saml2__AuthzDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContext:
		soap_serialize__saml2__AuthnContext(soap, (const struct saml2__AuthnContextType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectLocality:
		soap_serialize__saml2__SubjectLocality(soap, (const struct saml2__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthnStatement:
		soap_serialize__saml2__AuthnStatement(soap, (const struct saml2__AuthnStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Statement:
		soap_serialize__saml2__Statement(soap, (const struct saml2__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedAssertion:
		soap_serialize__saml2__EncryptedAssertion(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Advice:
		soap_serialize__saml2__Advice(soap, (const struct saml2__AdviceType *)ptr);
		break;
	case SOAP_TYPE__saml2__ProxyRestriction:
		soap_serialize__saml2__ProxyRestriction(soap, (const struct saml2__ProxyRestrictionType *)ptr);
		break;
	case SOAP_TYPE__saml2__OneTimeUse:
		soap_serialize__saml2__OneTimeUse(soap, (const struct saml2__OneTimeUseType *)ptr);
		break;
	case SOAP_TYPE__saml2__AudienceRestriction:
		soap_serialize__saml2__AudienceRestriction(soap, (const struct saml2__AudienceRestrictionType *)ptr);
		break;
	case SOAP_TYPE__saml2__Condition:
		soap_serialize__saml2__Condition(soap, (const struct saml2__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml2__Conditions:
		soap_serialize__saml2__Conditions(soap, (const struct saml2__ConditionsType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		soap_serialize__saml2__SubjectConfirmationData(soap, (const struct saml2__SubjectConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmation:
		soap_serialize__saml2__SubjectConfirmation(soap, (const struct saml2__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE__saml2__Subject:
		soap_serialize__saml2__Subject(soap, (const struct saml2__SubjectType *)ptr);
		break;
	case SOAP_TYPE__saml2__Assertion:
		soap_serialize__saml2__Assertion(soap, (const struct saml2__AssertionType *)ptr);
		break;
	case SOAP_TYPE__saml2__Issuer:
		soap_serialize__saml2__Issuer(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedID:
		soap_serialize__saml2__EncryptedID(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__NameID:
		soap_serialize__saml2__NameID(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE__saml2__BaseID:
		soap_serialize__saml2__BaseID(soap, (const struct saml2__BaseIDAbstractType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		soap_serialize___saml2__union_AttributeStatementType(soap, (const struct __saml2__union_AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_EvidenceType:
		soap_serialize___saml2__union_EvidenceType(soap, (const struct __saml2__union_EvidenceType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AdviceType:
		soap_serialize___saml2__union_AdviceType(soap, (const struct __saml2__union_AdviceType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_ConditionsType:
		soap_serialize___saml2__union_ConditionsType(soap, (const struct __saml2__union_ConditionsType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AssertionType:
		soap_serialize___saml2__union_AssertionType(soap, (const struct __saml2__union_AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml2__AttributeType:
		soap_serialize_saml2__AttributeType(soap, (const struct saml2__AttributeType *)ptr);
		break;
	case SOAP_TYPE_saml2__AttributeStatementType:
		soap_serialize_saml2__AttributeStatementType(soap, (const struct saml2__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__EvidenceType:
		soap_serialize_saml2__EvidenceType(soap, (const struct saml2__EvidenceType *)ptr);
		break;
	case SOAP_TYPE_saml2__ActionType:
		soap_serialize_saml2__ActionType(soap, (const struct saml2__ActionType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		soap_serialize_saml2__AuthzDecisionStatementType(soap, (const struct saml2__AuthzDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthnContextType:
		soap_serialize_saml2__AuthnContextType(soap, (const struct saml2__AuthnContextType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectLocalityType:
		soap_serialize_saml2__SubjectLocalityType(soap, (const struct saml2__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthnStatementType:
		soap_serialize_saml2__AuthnStatementType(soap, (const struct saml2__AuthnStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__StatementAbstractType:
		soap_serialize_saml2__StatementAbstractType(soap, (const struct saml2__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml2__AdviceType:
		soap_serialize_saml2__AdviceType(soap, (const struct saml2__AdviceType *)ptr);
		break;
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		soap_serialize_saml2__ProxyRestrictionType(soap, (const struct saml2__ProxyRestrictionType *)ptr);
		break;
	case SOAP_TYPE_saml2__OneTimeUseType:
		soap_serialize_saml2__OneTimeUseType(soap, (const struct saml2__OneTimeUseType *)ptr);
		break;
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		soap_serialize_saml2__AudienceRestrictionType(soap, (const struct saml2__AudienceRestrictionType *)ptr);
		break;
	case SOAP_TYPE_saml2__ConditionAbstractType:
		soap_serialize_saml2__ConditionAbstractType(soap, (const struct saml2__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml2__ConditionsType:
		soap_serialize_saml2__ConditionsType(soap, (const struct saml2__ConditionsType *)ptr);
		break;
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		soap_serialize_saml2__KeyInfoConfirmationDataType(soap, (const struct saml2__KeyInfoConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		soap_serialize_saml2__SubjectConfirmationDataType(soap, (const struct saml2__SubjectConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		soap_serialize_saml2__SubjectConfirmationType(soap, (const struct saml2__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectType:
		soap_serialize_saml2__SubjectType(soap, (const struct saml2__SubjectType *)ptr);
		break;
	case SOAP_TYPE_saml2__AssertionType:
		soap_serialize_saml2__AssertionType(soap, (const struct saml2__AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml2__EncryptedElementType:
		soap_serialize_saml2__EncryptedElementType(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE_saml2__NameIDType:
		soap_serialize_saml2__NameIDType(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		soap_serialize_saml2__BaseIDAbstractType(soap, (const struct saml2__BaseIDAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Attribute:
		soap_serialize__saml1__Attribute(soap, (const struct saml1__AttributeType *)ptr);
		break;
	case SOAP_TYPE__saml1__AttributeDesignator:
		soap_serialize__saml1__AttributeDesignator(soap, (const struct saml1__AttributeDesignatorType *)ptr);
		break;
	case SOAP_TYPE__saml1__AttributeStatement:
		soap_serialize__saml1__AttributeStatement(soap, (const struct saml1__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__Evidence:
		soap_serialize__saml1__Evidence(soap, (const struct saml1__EvidenceType *)ptr);
		break;
	case SOAP_TYPE__saml1__Action:
		soap_serialize__saml1__Action(soap, (const struct saml1__ActionType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		soap_serialize__saml1__AuthorizationDecisionStatement(soap, (const struct saml1__AuthorizationDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthorityBinding:
		soap_serialize__saml1__AuthorityBinding(soap, (const struct saml1__AuthorityBindingType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectLocality:
		soap_serialize__saml1__SubjectLocality(soap, (const struct saml1__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthenticationStatement:
		soap_serialize__saml1__AuthenticationStatement(soap, (const struct saml1__AuthenticationStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectConfirmation:
		soap_serialize__saml1__SubjectConfirmation(soap, (const struct saml1__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE__saml1__NameIdentifier:
		soap_serialize__saml1__NameIdentifier(soap, (const struct saml1__NameIdentifierType *)ptr);
		break;
	case SOAP_TYPE__saml1__Subject:
		soap_serialize__saml1__Subject(soap, (const struct saml1__SubjectType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectStatement:
		soap_serialize__saml1__SubjectStatement(soap, (const struct saml1__SubjectStatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Statement:
		soap_serialize__saml1__Statement(soap, (const struct saml1__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Advice:
		soap_serialize__saml1__Advice(soap, (const struct saml1__AdviceType *)ptr);
		break;
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		soap_serialize__saml1__DoNotCacheCondition(soap, (const struct saml1__DoNotCacheConditionType *)ptr);
		break;
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		soap_serialize__saml1__AudienceRestrictionCondition(soap, (const struct saml1__AudienceRestrictionConditionType *)ptr);
		break;
	case SOAP_TYPE__saml1__Condition:
		soap_serialize__saml1__Condition(soap, (const struct saml1__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Conditions:
		soap_serialize__saml1__Conditions(soap, (const struct saml1__ConditionsType *)ptr);
		break;
	case SOAP_TYPE__saml1__Assertion:
		soap_serialize__saml1__Assertion(soap, (const struct saml1__AssertionType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_EvidenceType:
		soap_serialize___saml1__union_EvidenceType(soap, (const struct __saml1__union_EvidenceType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_AdviceType:
		soap_serialize___saml1__union_AdviceType(soap, (const struct __saml1__union_AdviceType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_ConditionsType:
		soap_serialize___saml1__union_ConditionsType(soap, (const struct __saml1__union_ConditionsType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_AssertionType:
		soap_serialize___saml1__union_AssertionType(soap, (const struct __saml1__union_AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeType:
		soap_serialize_saml1__AttributeType(soap, (const struct saml1__AttributeType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		soap_serialize_saml1__AttributeDesignatorType(soap, (const struct saml1__AttributeDesignatorType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeStatementType:
		soap_serialize_saml1__AttributeStatementType(soap, (const struct saml1__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__EvidenceType:
		soap_serialize_saml1__EvidenceType(soap, (const struct saml1__EvidenceType *)ptr);
		break;
	case SOAP_TYPE_saml1__ActionType:
		soap_serialize_saml1__ActionType(soap, (const struct saml1__ActionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		soap_serialize_saml1__AuthorizationDecisionStatementType(soap, (const struct saml1__AuthorizationDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthorityBindingType:
		soap_serialize_saml1__AuthorityBindingType(soap, (const struct saml1__AuthorityBindingType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectLocalityType:
		soap_serialize_saml1__SubjectLocalityType(soap, (const struct saml1__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		soap_serialize_saml1__AuthenticationStatementType(soap, (const struct saml1__AuthenticationStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		soap_serialize_saml1__SubjectConfirmationType(soap, (const struct saml1__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE_saml1__NameIdentifierType:
		soap_serialize_saml1__NameIdentifierType(soap, (const struct saml1__NameIdentifierType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectType:
		soap_serialize_saml1__SubjectType(soap, (const struct saml1__SubjectType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		soap_serialize_saml1__SubjectStatementAbstractType(soap, (const struct saml1__SubjectStatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__StatementAbstractType:
		soap_serialize_saml1__StatementAbstractType(soap, (const struct saml1__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__AdviceType:
		soap_serialize_saml1__AdviceType(soap, (const struct saml1__AdviceType *)ptr);
		break;
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		soap_serialize_saml1__DoNotCacheConditionType(soap, (const struct saml1__DoNotCacheConditionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		soap_serialize_saml1__AudienceRestrictionConditionType(soap, (const struct saml1__AudienceRestrictionConditionType *)ptr);
		break;
	case SOAP_TYPE_saml1__ConditionAbstractType:
		soap_serialize_saml1__ConditionAbstractType(soap, (const struct saml1__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__ConditionsType:
		soap_serialize_saml1__ConditionsType(soap, (const struct saml1__ConditionsType *)ptr);
		break;
	case SOAP_TYPE_saml1__AssertionType:
		soap_serialize_saml1__AssertionType(soap, (const struct saml1__AssertionType *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		soap_serialize_xsd__dateTime(soap, (const struct timeval *)ptr);
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, (const struct __wsc__DerivedKeyTokenType_sequence *)ptr);
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		soap_serialize_wsc__PropertiesType(soap, (const struct wsc__PropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		soap_serialize_wsc__DerivedKeyTokenType(soap, (const struct wsc__DerivedKeyTokenType *)ptr);
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		soap_serialize_wsc__SecurityContextTokenType(soap, (const struct wsc__SecurityContextTokenType *)ptr);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		soap_serialize___xenc__union_ReferenceList(soap, (const struct __xenc__union_ReferenceList *)ptr);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		soap_serialize__xenc__ReferenceList(soap, (const struct _xenc__ReferenceList *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		soap_serialize_xenc__EncryptionPropertyType(soap, (const struct xenc__EncryptionPropertyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		soap_serialize_xenc__EncryptionPropertiesType(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		soap_serialize_xenc__ReferenceType(soap, (const struct xenc__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		soap_serialize_xenc__AgreementMethodType(soap, (const struct xenc__AgreementMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		soap_serialize_xenc__EncryptedDataType(soap, (const struct xenc__EncryptedDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		soap_serialize_xenc__TransformsType(soap, (const struct xenc__TransformsType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		soap_serialize_xenc__CipherReferenceType(soap, (const struct xenc__CipherReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		soap_serialize_xenc__CipherDataType(soap, (const struct xenc__CipherDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		soap_serialize_xenc__EncryptionMethodType(soap, (const struct xenc__EncryptionMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		soap_serialize_xenc__EncryptedType(soap, (const struct xenc__EncryptedType *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		soap_serialize__ds__KeyInfo(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Transform:
		soap_serialize__ds__Transform(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Signature:
		soap_serialize__ds__Signature(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		soap_serialize_xenc__EncryptedKeyType(soap, (const struct xenc__EncryptedKeyType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE_wsse__EncodedString:
		soap_serialize_wsse__EncodedString(soap, (const struct wsse__EncodedString *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCertificateWithPin:
		soap_serialize___ns1__GetCertificateWithPin(soap, (const struct __ns1__GetCertificateWithPin *)ptr);
		break;
	case SOAP_TYPE___ns1__ForceSMS:
		soap_serialize___ns1__ForceSMS(soap, (const struct __ns1__ForceSMS *)ptr);
		break;
	case SOAP_TYPE___ns1__CCMovelMultipleSign:
		soap_serialize___ns1__CCMovelMultipleSign(soap, (const struct __ns1__CCMovelMultipleSign *)ptr);
		break;
	case SOAP_TYPE___ns1__ValidateOtp:
		soap_serialize___ns1__ValidateOtp(soap, (const struct __ns1__ValidateOtp *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCertificate:
		soap_serialize___ns1__GetCertificate(soap, (const struct __ns1__GetCertificate *)ptr);
		break;
	case SOAP_TYPE___ns1__CCMovelSign:
		soap_serialize___ns1__CCMovelSign(soap, (const struct __ns1__CCMovelSign *)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		soap_serialize_PointerTowsc__SecurityContextTokenType(soap, (struct wsc__SecurityContextTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE__saml2__AuthenticatingAuthority:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContextDeclRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContextClassRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__Audience:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AssertionURIRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AssertionIDRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		soap_serialize_PointerToPointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType:
		soap_serialize_PointerTo__saml2__union_AttributeStatementType(soap, (struct __saml2__union_AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		soap_serialize_PointerTosaml2__AttributeType(soap, (struct saml2__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		soap_serialize_PointerTosaml2__EvidenceType(soap, (struct saml2__EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ActionType:
		soap_serialize_PointerTosaml2__ActionType(soap, (struct saml2__ActionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		soap_serialize_PointerTosaml2__AuthnContextType(soap, (struct saml2__AuthnContextType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		soap_serialize_PointerTosaml2__SubjectLocalityType(soap, (struct saml2__SubjectLocalityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_EvidenceType:
		soap_serialize_PointerTo__saml2__union_EvidenceType(soap, (struct __saml2__union_EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AdviceType:
		soap_serialize_PointerTo__saml2__union_AdviceType(soap, (struct __saml2__union_AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		soap_serialize_PointerTosaml2__AssertionType(soap, (struct saml2__AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_ConditionsType:
		soap_serialize_PointerTo__saml2__union_ConditionsType(soap, (struct __saml2__union_ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		soap_serialize_PointerTosaml2__ProxyRestrictionType(soap, (struct saml2__ProxyRestrictionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		soap_serialize_PointerTosaml2__OneTimeUseType(soap, (struct saml2__OneTimeUseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		soap_serialize_PointerTosaml2__AudienceRestrictionType(soap, (struct saml2__AudienceRestrictionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		soap_serialize_PointerTosaml2__ConditionAbstractType(soap, (struct saml2__ConditionAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		soap_serialize_PointerTosaml2__SubjectConfirmationDataType(soap, (struct saml2__SubjectConfirmationDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		soap_serialize_PointerTosaml2__SubjectConfirmationType(soap, (struct saml2__SubjectConfirmationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		soap_serialize_PointerTosaml2__EncryptedElementType(soap, (struct saml2__EncryptedElementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, (struct saml2__BaseIDAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AssertionType:
		soap_serialize_PointerTo__saml2__union_AssertionType(soap, (struct __saml2__union_AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		soap_serialize_PointerTosaml2__AttributeStatementType(soap, (struct saml2__AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		soap_serialize_PointerTosaml2__AuthzDecisionStatementType(soap, (struct saml2__AuthzDecisionStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		soap_serialize_PointerTosaml2__AuthnStatementType(soap, (struct saml2__AuthnStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		soap_serialize_PointerTosaml2__StatementAbstractType(soap, (struct saml2__StatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		soap_serialize_PointerTosaml2__AdviceType(soap, (struct saml2__AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		soap_serialize_PointerTosaml2__ConditionsType(soap, (struct saml2__ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		soap_serialize_PointerTosaml2__SubjectType(soap, (struct saml2__SubjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		soap_serialize_PointerTosaml2__NameIDType(soap, (struct saml2__NameIDType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToPointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType **const*)ptr);
		break;
	case SOAP_TYPE__saml1__ConfirmationMethod:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml1__Audience:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml1__AssertionIDReference:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		soap_serialize_PointerTosaml1__AttributeType(soap, (struct saml1__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		soap_serialize_PointerTosaml1__EvidenceType(soap, (struct saml1__EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ActionType:
		soap_serialize_PointerTosaml1__ActionType(soap, (struct saml1__ActionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		soap_serialize_PointerTosaml1__AuthorityBindingType(soap, (struct saml1__AuthorityBindingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		soap_serialize_PointerTosaml1__SubjectLocalityType(soap, (struct saml1__SubjectLocalityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		soap_serialize_PointerTosaml1__SubjectType(soap, (struct saml1__SubjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_EvidenceType:
		soap_serialize_PointerTo__saml1__union_EvidenceType(soap, (struct __saml1__union_EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, (struct saml1__SubjectConfirmationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		soap_serialize_PointerTosaml1__NameIdentifierType(soap, (struct saml1__NameIdentifierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_AdviceType:
		soap_serialize_PointerTo__saml1__union_AdviceType(soap, (struct __saml1__union_AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		soap_serialize_PointerTosaml1__AssertionType(soap, (struct saml1__AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__dateTime:
		soap_serialize_PointerToxsd__dateTime(soap, (struct timeval *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_ConditionsType:
		soap_serialize_PointerTo__saml1__union_ConditionsType(soap, (struct __saml1__union_ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		soap_serialize_PointerTosaml1__ConditionAbstractType(soap, (struct saml1__ConditionAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		soap_serialize_PointerTosaml1__DoNotCacheConditionType(soap, (struct saml1__DoNotCacheConditionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(soap, (struct saml1__AudienceRestrictionConditionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__Signature:
		soap_serialize_PointerTo_ds__Signature(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_AssertionType:
		soap_serialize_PointerTo__saml1__union_AssertionType(soap, (struct __saml1__union_AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		soap_serialize_PointerTosaml1__AttributeStatementType(soap, (struct saml1__AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(soap, (struct saml1__AuthorizationDecisionStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		soap_serialize_PointerTosaml1__AuthenticationStatementType(soap, (struct saml1__AuthenticationStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		soap_serialize_PointerTosaml1__SubjectStatementAbstractType(soap, (struct saml1__SubjectStatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		soap_serialize_PointerTosaml1__StatementAbstractType(soap, (struct saml1__StatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		soap_serialize_PointerTosaml1__AdviceType(soap, (struct saml1__AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		soap_serialize_PointerTosaml1__ConditionsType(soap, (struct saml1__ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence:
		soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, (struct __wsc__DerivedKeyTokenType_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerToULONG64:
		soap_serialize_PointerToULONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		soap_serialize_PointerTowsc__PropertiesType(soap, (struct wsc__PropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		soap_serialize_PointerTo_xenc__ReferenceList(soap, (struct _xenc__ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__xenc__union_ReferenceList:
		soap_serialize_PointerTo__xenc__union_ReferenceList(soap, (struct __xenc__union_ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		soap_serialize_PointerToxenc__ReferenceType(soap, (struct xenc__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		soap_serialize_PointerToxenc__EncryptionPropertyType(soap, (struct xenc__EncryptionPropertyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__TransformsType:
		soap_serialize_PointerToxenc__TransformsType(soap, (struct xenc__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		soap_serialize_PointerToxenc__CipherReferenceType(soap, (struct xenc__CipherReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, (struct xenc__EncryptionPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		soap_serialize_PointerToxenc__CipherDataType(soap, (struct xenc__CipherDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		soap_serialize_PointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		soap_serialize_PointerToxenc__EncryptionMethodType(soap, (struct xenc__EncryptionMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE__ds__SignatureValue:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsse__EncodedString:
		soap_serialize_PointerTowsse__EncodedString(soap, (struct wsse__EncodedString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetCertificateWithPin:
		soap_serialize_PointerTo_ns3__GetCertificateWithPin(soap, (_ns3__GetCertificateWithPin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__ForceSMS:
		soap_serialize_PointerTo_ns3__ForceSMS(soap, (_ns3__ForceSMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CCMovelMultipleSign:
		soap_serialize_PointerTo_ns3__CCMovelMultipleSign(soap, (_ns3__CCMovelMultipleSign *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__ValidateOtp:
		soap_serialize_PointerTo_ns3__ValidateOtp(soap, (_ns3__ValidateOtp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetCertificate:
		soap_serialize_PointerTo_ns3__GetCertificate(soap, (_ns3__GetCertificate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CCMovelSign:
		soap_serialize_PointerTo_ns3__CCMovelSign(soap, (_ns3__CCMovelSign *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__HashStructure:
		soap_serialize_PointerTons5__HashStructure(soap, (ns5__HashStructure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ArrayOfHashStructure:
		soap_serialize_PointerTons5__ArrayOfHashStructure(soap, (ns5__ArrayOfHashStructure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__MultipleSignRequest:
		soap_serialize_PointerTons5__MultipleSignRequest(soap, (ns5__MultipleSignRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SignResponse:
		soap_serialize_PointerTons5__SignResponse(soap, (ns5__SignResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SignStatus:
		soap_serialize_PointerTons5__SignStatus(soap, (ns5__SignStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SignRequest:
		soap_serialize_PointerTons5__SignRequest(soap, (ns5__SignRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ID__:
		return (void*)soap_instantiate_xsd__ID__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__IDREF__:
		return (void*)soap_instantiate_xsd__IDREF__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName__:
		return (void*)soap_instantiate_xsd__QName__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI__:
		return (void*)soap_instantiate_xsd__anyURI__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary__:
		return (void*)soap_instantiate_xsd__base64Binary__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean_:
		return (void*)soap_instantiate_xsd__boolean_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__byte__:
		return (void*)soap_instantiate_xsd__byte__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime_:
		return (void*)soap_instantiate_xsd__dateTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal__:
		return (void*)soap_instantiate_xsd__decimal__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double_:
		return (void*)soap_instantiate_xsd__double_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration__:
		return (void*)soap_instantiate_xsd__duration__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float_:
		return (void*)soap_instantiate_xsd__float_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int_:
		return (void*)soap_instantiate_xsd__int_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long_:
		return (void*)soap_instantiate_xsd__long_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__short_:
		return (void*)soap_instantiate_xsd__short_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string_:
		return (void*)soap_instantiate_xsd__string_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedByte__:
		return (void*)soap_instantiate_xsd__unsignedByte__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedInt_:
		return (void*)soap_instantiate_xsd__unsignedInt_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedLong_:
		return (void*)soap_instantiate_xsd__unsignedLong_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedShort_:
		return (void*)soap_instantiate_xsd__unsignedShort_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__char__:
		return (void*)soap_instantiate_ns4__char__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__duration__:
		return (void*)soap_instantiate_ns4__duration__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__guid__:
		return (void*)soap_instantiate_ns4__guid__(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CCMovelSign:
		return (void*)soap_instantiate__ns3__CCMovelSign(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CCMovelSignResponse:
		return (void*)soap_instantiate__ns3__CCMovelSignResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCertificate:
		return (void*)soap_instantiate__ns3__GetCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCertificateResponse:
		return (void*)soap_instantiate__ns3__GetCertificateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__ValidateOtp:
		return (void*)soap_instantiate__ns3__ValidateOtp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__ValidateOtpResponse:
		return (void*)soap_instantiate__ns3__ValidateOtpResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CCMovelMultipleSign:
		return (void*)soap_instantiate__ns3__CCMovelMultipleSign(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CCMovelMultipleSignResponse:
		return (void*)soap_instantiate__ns3__CCMovelMultipleSignResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__ForceSMS:
		return (void*)soap_instantiate__ns3__ForceSMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__ForceSMSResponse:
		return (void*)soap_instantiate__ns3__ForceSMSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCertificateWithPin:
		return (void*)soap_instantiate__ns3__GetCertificateWithPin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCertificateWithPinResponse:
		return (void*)soap_instantiate__ns3__GetCertificateWithPinResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SignRequest:
		return (void*)soap_instantiate_ns5__SignRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SignStatus:
		return (void*)soap_instantiate_ns5__SignStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SignResponse:
		return (void*)soap_instantiate_ns5__SignResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ArrayOfHashStructure:
		return (void*)soap_instantiate_ns5__ArrayOfHashStructure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__HashStructure:
		return (void*)soap_instantiate_ns5__HashStructure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__MultipleSignRequest:
		return (void*)soap_instantiate_ns5__MultipleSignRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CCMovelSign:
		return (void*)soap_instantiate___ns1__CCMovelSign(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCertificate:
		return (void*)soap_instantiate___ns1__GetCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ValidateOtp:
		return (void*)soap_instantiate___ns1__ValidateOtp(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CCMovelMultipleSign:
		return (void*)soap_instantiate___ns1__CCMovelMultipleSign(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ForceSMS:
		return (void*)soap_instantiate___ns1__ForceSMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCertificateWithPin:
		return (void*)soap_instantiate___ns1__GetCertificateWithPin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsu__Timestamp:
		return (void*)soap_instantiate__wsu__Timestamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsse__EncodedString:
		return (void*)soap_instantiate_wsse__EncodedString(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__UsernameToken:
		return (void*)soap_instantiate__wsse__UsernameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return (void*)soap_instantiate__wsse__BinarySecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Reference:
		return (void*)soap_instantiate__wsse__Reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Embedded:
		return (void*)soap_instantiate__wsse__Embedded(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return (void*)soap_instantiate__wsse__KeyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return (void*)soap_instantiate__wsse__SecurityTokenReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyInfoType:
		return (void*)soap_instantiate_ds__KeyInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureType:
		return (void*)soap_instantiate_ds__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return (void*)soap_instantiate__c14n__InclusiveNamespaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformType:
		return (void*)soap_instantiate_ds__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignedInfoType:
		return (void*)soap_instantiate_ds__SignedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return (void*)soap_instantiate_ds__CanonicalizationMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureMethodType:
		return (void*)soap_instantiate_ds__SignatureMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__ReferenceType:
		return (void*)soap_instantiate_ds__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformsType:
		return (void*)soap_instantiate_ds__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DigestMethodType:
		return (void*)soap_instantiate_ds__DigestMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyValueType:
		return (void*)soap_instantiate_ds__KeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RetrievalMethodType:
		return (void*)soap_instantiate_ds__RetrievalMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509DataType:
		return (void*)soap_instantiate_ds__X509DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return (void*)soap_instantiate_ds__X509IssuerSerialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DSAKeyValueType:
		return (void*)soap_instantiate_ds__DSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return (void*)soap_instantiate_ds__RSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return (void*)soap_instantiate_xenc__EncryptionPropertyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedType:
		return (void*)soap_instantiate_xenc__EncryptedType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return (void*)soap_instantiate_xenc__EncryptionMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__CipherDataType:
		return (void*)soap_instantiate_xenc__CipherDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__CipherReferenceType:
		return (void*)soap_instantiate_xenc__CipherReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__TransformsType:
		return (void*)soap_instantiate_xenc__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__AgreementMethodType:
		return (void*)soap_instantiate_xenc__AgreementMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__ReferenceType:
		return (void*)soap_instantiate_xenc__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return (void*)soap_instantiate_xenc__EncryptionPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___xenc__union_ReferenceList:
		return (void*)soap_instantiate___xenc__union_ReferenceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xenc__ReferenceList:
		return (void*)soap_instantiate__xenc__ReferenceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedDataType:
		return (void*)soap_instantiate_xenc__EncryptedDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return (void*)soap_instantiate_xenc__EncryptedKeyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return (void*)soap_instantiate_wsc__SecurityContextTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		return (void*)soap_instantiate___wsc__DerivedKeyTokenType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return (void*)soap_instantiate_wsc__DerivedKeyTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__PropertiesType:
		return (void*)soap_instantiate_wsc__PropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_AssertionType:
		return (void*)soap_instantiate___saml1__union_AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AssertionType:
		return (void*)soap_instantiate_saml1__AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_ConditionsType:
		return (void*)soap_instantiate___saml1__union_ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__ConditionsType:
		return (void*)soap_instantiate_saml1__ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return (void*)soap_instantiate_saml1__ConditionAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_AdviceType:
		return (void*)soap_instantiate___saml1__union_AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AdviceType:
		return (void*)soap_instantiate_saml1__AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__StatementAbstractType:
		return (void*)soap_instantiate_saml1__StatementAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectType:
		return (void*)soap_instantiate_saml1__SubjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return (void*)soap_instantiate_saml1__SubjectConfirmationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return (void*)soap_instantiate_saml1__SubjectLocalityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return (void*)soap_instantiate_saml1__AuthorityBindingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml1__union_EvidenceType:
		return (void*)soap_instantiate___saml1__union_EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__EvidenceType:
		return (void*)soap_instantiate_saml1__EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return (void*)soap_instantiate_saml1__AttributeDesignatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return (void*)soap_instantiate_saml1__AudienceRestrictionConditionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return (void*)soap_instantiate_saml1__DoNotCacheConditionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return (void*)soap_instantiate_saml1__SubjectStatementAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__NameIdentifierType:
		return (void*)soap_instantiate_saml1__NameIdentifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__ActionType:
		return (void*)soap_instantiate_saml1__ActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AttributeType:
		return (void*)soap_instantiate_saml1__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return (void*)soap_instantiate_saml1__AuthenticationStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return (void*)soap_instantiate_saml1__AuthorizationDecisionStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml1__AttributeStatementType:
		return (void*)soap_instantiate_saml1__AttributeStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return (void*)soap_instantiate_saml2__BaseIDAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__EncryptedElementType:
		return (void*)soap_instantiate_saml2__EncryptedElementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_AssertionType:
		return (void*)soap_instantiate___saml2__union_AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AssertionType:
		return (void*)soap_instantiate_saml2__AssertionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectType:
		return (void*)soap_instantiate_saml2__SubjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return (void*)soap_instantiate_saml2__SubjectConfirmationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_ConditionsType:
		return (void*)soap_instantiate___saml2__union_ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ConditionsType:
		return (void*)soap_instantiate_saml2__ConditionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return (void*)soap_instantiate_saml2__ConditionAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_AdviceType:
		return (void*)soap_instantiate___saml2__union_AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AdviceType:
		return (void*)soap_instantiate_saml2__AdviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__StatementAbstractType:
		return (void*)soap_instantiate_saml2__StatementAbstractType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return (void*)soap_instantiate_saml2__SubjectLocalityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AuthnContextType:
		return (void*)soap_instantiate_saml2__AuthnContextType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_EvidenceType:
		return (void*)soap_instantiate___saml2__union_EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__EvidenceType:
		return (void*)soap_instantiate_saml2__EvidenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AttributeType:
		return (void*)soap_instantiate_saml2__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__NameIDType:
		return (void*)soap_instantiate_saml2__NameIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return (void*)soap_instantiate_saml2__SubjectConfirmationDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return (void*)soap_instantiate_saml2__AudienceRestrictionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__OneTimeUseType:
		return (void*)soap_instantiate_saml2__OneTimeUseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return (void*)soap_instantiate_saml2__ProxyRestrictionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AuthnStatementType:
		return (void*)soap_instantiate_saml2__AuthnStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return (void*)soap_instantiate_saml2__AuthzDecisionStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__ActionType:
		return (void*)soap_instantiate_saml2__ActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		return (void*)soap_instantiate___saml2__union_AttributeStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__AttributeStatementType:
		return (void*)soap_instantiate_saml2__AttributeStatementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return (void*)soap_instantiate_saml2__KeyInfoConfirmationDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Security:
		return (void*)soap_instantiate__wsse__Security(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Password:
		return (void*)soap_instantiate__wsse__Password(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__IDREF:
		return (void*)soap_instantiate_xsd__IDREF(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration:
		return (void*)soap_instantiate_xsd__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__duration:
		return (void*)soap_instantiate_ns4__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__guid:
		return (void*)soap_instantiate_ns4__guid(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__Signature:
		return (void*)soap_instantiate__ds__Signature(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__Transform:
		return (void*)soap_instantiate__ds__Transform(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__KeyInfo:
		return (void*)soap_instantiate__ds__KeyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Assertion:
		return (void*)soap_instantiate__saml1__Assertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Conditions:
		return (void*)soap_instantiate__saml1__Conditions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Condition:
		return (void*)soap_instantiate__saml1__Condition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		return (void*)soap_instantiate__saml1__AudienceRestrictionCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		return (void*)soap_instantiate__saml1__DoNotCacheCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Advice:
		return (void*)soap_instantiate__saml1__Advice(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Statement:
		return (void*)soap_instantiate__saml1__Statement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__SubjectStatement:
		return (void*)soap_instantiate__saml1__SubjectStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Subject:
		return (void*)soap_instantiate__saml1__Subject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__NameIdentifier:
		return (void*)soap_instantiate__saml1__NameIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__SubjectConfirmation:
		return (void*)soap_instantiate__saml1__SubjectConfirmation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AuthenticationStatement:
		return (void*)soap_instantiate__saml1__AuthenticationStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__SubjectLocality:
		return (void*)soap_instantiate__saml1__SubjectLocality(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AuthorityBinding:
		return (void*)soap_instantiate__saml1__AuthorityBinding(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		return (void*)soap_instantiate__saml1__AuthorizationDecisionStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Action:
		return (void*)soap_instantiate__saml1__Action(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Evidence:
		return (void*)soap_instantiate__saml1__Evidence(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AttributeStatement:
		return (void*)soap_instantiate__saml1__AttributeStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__AttributeDesignator:
		return (void*)soap_instantiate__saml1__AttributeDesignator(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml1__Attribute:
		return (void*)soap_instantiate__saml1__Attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__BaseID:
		return (void*)soap_instantiate__saml2__BaseID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__NameID:
		return (void*)soap_instantiate__saml2__NameID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__EncryptedID:
		return (void*)soap_instantiate__saml2__EncryptedID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Issuer:
		return (void*)soap_instantiate__saml2__Issuer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Assertion:
		return (void*)soap_instantiate__saml2__Assertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Subject:
		return (void*)soap_instantiate__saml2__Subject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__SubjectConfirmation:
		return (void*)soap_instantiate__saml2__SubjectConfirmation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		return (void*)soap_instantiate__saml2__SubjectConfirmationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Conditions:
		return (void*)soap_instantiate__saml2__Conditions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Condition:
		return (void*)soap_instantiate__saml2__Condition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AudienceRestriction:
		return (void*)soap_instantiate__saml2__AudienceRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__OneTimeUse:
		return (void*)soap_instantiate__saml2__OneTimeUse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__ProxyRestriction:
		return (void*)soap_instantiate__saml2__ProxyRestriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Advice:
		return (void*)soap_instantiate__saml2__Advice(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__EncryptedAssertion:
		return (void*)soap_instantiate__saml2__EncryptedAssertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Statement:
		return (void*)soap_instantiate__saml2__Statement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AuthnStatement:
		return (void*)soap_instantiate__saml2__AuthnStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__SubjectLocality:
		return (void*)soap_instantiate__saml2__SubjectLocality(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AuthnContext:
		return (void*)soap_instantiate__saml2__AuthnContext(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		return (void*)soap_instantiate__saml2__AuthzDecisionStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Action:
		return (void*)soap_instantiate__saml2__Action(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Evidence:
		return (void*)soap_instantiate__saml2__Evidence(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__AttributeStatement:
		return (void*)soap_instantiate__saml2__AttributeStatement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__Attribute:
		return (void*)soap_instantiate__saml2__Attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__saml2__EncryptedAttribute:
		return (void*)soap_instantiate__saml2__EncryptedAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__HashStructure:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__HashStructure(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_xsd__ID__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__ID__*>(p->ptr), xsd__ID__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__ID__*>(p->ptr), xsd__ID__);
		break;
	case SOAP_TYPE_xsd__IDREF__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__IDREF__*>(p->ptr), xsd__IDREF__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__IDREF__*>(p->ptr), xsd__IDREF__);
		break;
	case SOAP_TYPE_xsd__QName__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__QName__*>(p->ptr), xsd__QName__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__QName__*>(p->ptr), xsd__QName__);
		break;
	case SOAP_TYPE_xsd__anyURI__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anyURI__*>(p->ptr), xsd__anyURI__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anyURI__*>(p->ptr), xsd__anyURI__);
		break;
	case SOAP_TYPE_xsd__base64Binary__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary__*>(p->ptr), xsd__base64Binary__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary__*>(p->ptr), xsd__base64Binary__);
		break;
	case SOAP_TYPE_xsd__boolean_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__boolean_*>(p->ptr), xsd__boolean_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__boolean_*>(p->ptr), xsd__boolean_);
		break;
	case SOAP_TYPE_xsd__byte__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__byte__*>(p->ptr), xsd__byte__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__byte__*>(p->ptr), xsd__byte__);
		break;
	case SOAP_TYPE_xsd__dateTime_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__dateTime_*>(p->ptr), xsd__dateTime_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__dateTime_*>(p->ptr), xsd__dateTime_);
		break;
	case SOAP_TYPE_xsd__decimal__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__decimal__*>(p->ptr), xsd__decimal__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__decimal__*>(p->ptr), xsd__decimal__);
		break;
	case SOAP_TYPE_xsd__double_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__double_*>(p->ptr), xsd__double_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__double_*>(p->ptr), xsd__double_);
		break;
	case SOAP_TYPE_xsd__duration__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__duration__*>(p->ptr), xsd__duration__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__duration__*>(p->ptr), xsd__duration__);
		break;
	case SOAP_TYPE_xsd__float_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__float_*>(p->ptr), xsd__float_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__float_*>(p->ptr), xsd__float_);
		break;
	case SOAP_TYPE_xsd__int_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__int_*>(p->ptr), xsd__int_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__int_*>(p->ptr), xsd__int_);
		break;
	case SOAP_TYPE_xsd__long_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__long_*>(p->ptr), xsd__long_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__long_*>(p->ptr), xsd__long_);
		break;
	case SOAP_TYPE_xsd__short_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__short_*>(p->ptr), xsd__short_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__short_*>(p->ptr), xsd__short_);
		break;
	case SOAP_TYPE_xsd__string_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__string_*>(p->ptr), xsd__string_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__string_*>(p->ptr), xsd__string_);
		break;
	case SOAP_TYPE_xsd__unsignedByte__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__unsignedByte__*>(p->ptr), xsd__unsignedByte__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__unsignedByte__*>(p->ptr), xsd__unsignedByte__);
		break;
	case SOAP_TYPE_xsd__unsignedInt_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__unsignedInt_*>(p->ptr), xsd__unsignedInt_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__unsignedInt_*>(p->ptr), xsd__unsignedInt_);
		break;
	case SOAP_TYPE_xsd__unsignedLong_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__unsignedLong_*>(p->ptr), xsd__unsignedLong_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__unsignedLong_*>(p->ptr), xsd__unsignedLong_);
		break;
	case SOAP_TYPE_xsd__unsignedShort_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__unsignedShort_*>(p->ptr), xsd__unsignedShort_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__unsignedShort_*>(p->ptr), xsd__unsignedShort_);
		break;
	case SOAP_TYPE_ns4__char__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__char__*>(p->ptr), ns4__char__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__char__*>(p->ptr), ns4__char__);
		break;
	case SOAP_TYPE_ns4__duration__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__duration__*>(p->ptr), ns4__duration__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__duration__*>(p->ptr), ns4__duration__);
		break;
	case SOAP_TYPE_ns4__guid__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__guid__*>(p->ptr), ns4__guid__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__guid__*>(p->ptr), ns4__guid__);
		break;
	case SOAP_TYPE__ns3__CCMovelSign:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__CCMovelSign*>(p->ptr), _ns3__CCMovelSign);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__CCMovelSign*>(p->ptr), _ns3__CCMovelSign);
		break;
	case SOAP_TYPE__ns3__CCMovelSignResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__CCMovelSignResponse*>(p->ptr), _ns3__CCMovelSignResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__CCMovelSignResponse*>(p->ptr), _ns3__CCMovelSignResponse);
		break;
	case SOAP_TYPE__ns3__GetCertificate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__GetCertificate*>(p->ptr), _ns3__GetCertificate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__GetCertificate*>(p->ptr), _ns3__GetCertificate);
		break;
	case SOAP_TYPE__ns3__GetCertificateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__GetCertificateResponse*>(p->ptr), _ns3__GetCertificateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__GetCertificateResponse*>(p->ptr), _ns3__GetCertificateResponse);
		break;
	case SOAP_TYPE__ns3__ValidateOtp:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__ValidateOtp*>(p->ptr), _ns3__ValidateOtp);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__ValidateOtp*>(p->ptr), _ns3__ValidateOtp);
		break;
	case SOAP_TYPE__ns3__ValidateOtpResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__ValidateOtpResponse*>(p->ptr), _ns3__ValidateOtpResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__ValidateOtpResponse*>(p->ptr), _ns3__ValidateOtpResponse);
		break;
	case SOAP_TYPE__ns3__CCMovelMultipleSign:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__CCMovelMultipleSign*>(p->ptr), _ns3__CCMovelMultipleSign);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__CCMovelMultipleSign*>(p->ptr), _ns3__CCMovelMultipleSign);
		break;
	case SOAP_TYPE__ns3__CCMovelMultipleSignResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__CCMovelMultipleSignResponse*>(p->ptr), _ns3__CCMovelMultipleSignResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__CCMovelMultipleSignResponse*>(p->ptr), _ns3__CCMovelMultipleSignResponse);
		break;
	case SOAP_TYPE__ns3__ForceSMS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__ForceSMS*>(p->ptr), _ns3__ForceSMS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__ForceSMS*>(p->ptr), _ns3__ForceSMS);
		break;
	case SOAP_TYPE__ns3__ForceSMSResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__ForceSMSResponse*>(p->ptr), _ns3__ForceSMSResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__ForceSMSResponse*>(p->ptr), _ns3__ForceSMSResponse);
		break;
	case SOAP_TYPE__ns3__GetCertificateWithPin:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__GetCertificateWithPin*>(p->ptr), _ns3__GetCertificateWithPin);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__GetCertificateWithPin*>(p->ptr), _ns3__GetCertificateWithPin);
		break;
	case SOAP_TYPE__ns3__GetCertificateWithPinResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__GetCertificateWithPinResponse*>(p->ptr), _ns3__GetCertificateWithPinResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__GetCertificateWithPinResponse*>(p->ptr), _ns3__GetCertificateWithPinResponse);
		break;
	case SOAP_TYPE_ns5__SignRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns5__SignRequest*>(p->ptr), ns5__SignRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns5__SignRequest*>(p->ptr), ns5__SignRequest);
		break;
	case SOAP_TYPE_ns5__SignStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns5__SignStatus*>(p->ptr), ns5__SignStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns5__SignStatus*>(p->ptr), ns5__SignStatus);
		break;
	case SOAP_TYPE_ns5__SignResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns5__SignResponse*>(p->ptr), ns5__SignResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns5__SignResponse*>(p->ptr), ns5__SignResponse);
		break;
	case SOAP_TYPE_ns5__ArrayOfHashStructure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns5__ArrayOfHashStructure*>(p->ptr), ns5__ArrayOfHashStructure);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns5__ArrayOfHashStructure*>(p->ptr), ns5__ArrayOfHashStructure);
		break;
	case SOAP_TYPE_ns5__HashStructure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns5__HashStructure*>(p->ptr), ns5__HashStructure);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns5__HashStructure*>(p->ptr), ns5__HashStructure);
		break;
	case SOAP_TYPE_ns5__MultipleSignRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns5__MultipleSignRequest*>(p->ptr), ns5__MultipleSignRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns5__MultipleSignRequest*>(p->ptr), ns5__MultipleSignRequest);
		break;
	case SOAP_TYPE___ns1__CCMovelSign:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CCMovelSign*>(p->ptr), struct __ns1__CCMovelSign);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CCMovelSign*>(p->ptr), struct __ns1__CCMovelSign);
		break;
	case SOAP_TYPE___ns1__GetCertificate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetCertificate*>(p->ptr), struct __ns1__GetCertificate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetCertificate*>(p->ptr), struct __ns1__GetCertificate);
		break;
	case SOAP_TYPE___ns1__ValidateOtp:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ValidateOtp*>(p->ptr), struct __ns1__ValidateOtp);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ValidateOtp*>(p->ptr), struct __ns1__ValidateOtp);
		break;
	case SOAP_TYPE___ns1__CCMovelMultipleSign:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CCMovelMultipleSign*>(p->ptr), struct __ns1__CCMovelMultipleSign);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CCMovelMultipleSign*>(p->ptr), struct __ns1__CCMovelMultipleSign);
		break;
	case SOAP_TYPE___ns1__ForceSMS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ForceSMS*>(p->ptr), struct __ns1__ForceSMS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ForceSMS*>(p->ptr), struct __ns1__ForceSMS);
		break;
	case SOAP_TYPE___ns1__GetCertificateWithPin:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetCertificateWithPin*>(p->ptr), struct __ns1__GetCertificateWithPin);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetCertificateWithPin*>(p->ptr), struct __ns1__GetCertificateWithPin);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsu__Timestamp*>(p->ptr), struct _wsu__Timestamp);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsu__Timestamp*>(p->ptr), struct _wsu__Timestamp);
		break;
	case SOAP_TYPE_wsse__EncodedString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsse__EncodedString*>(p->ptr), struct wsse__EncodedString);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsse__EncodedString*>(p->ptr), struct wsse__EncodedString);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__UsernameToken*>(p->ptr), struct _wsse__UsernameToken);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__UsernameToken*>(p->ptr), struct _wsse__UsernameToken);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__BinarySecurityToken*>(p->ptr), struct _wsse__BinarySecurityToken);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__BinarySecurityToken*>(p->ptr), struct _wsse__BinarySecurityToken);
		break;
	case SOAP_TYPE__wsse__Reference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Reference*>(p->ptr), struct _wsse__Reference);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Reference*>(p->ptr), struct _wsse__Reference);
		break;
	case SOAP_TYPE__wsse__Embedded:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Embedded*>(p->ptr), struct _wsse__Embedded);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Embedded*>(p->ptr), struct _wsse__Embedded);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__KeyIdentifier*>(p->ptr), struct _wsse__KeyIdentifier);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__KeyIdentifier*>(p->ptr), struct _wsse__KeyIdentifier);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__SecurityTokenReference*>(p->ptr), struct _wsse__SecurityTokenReference);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__SecurityTokenReference*>(p->ptr), struct _wsse__SecurityTokenReference);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		break;
	case SOAP_TYPE_ds__SignatureType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _c14n__InclusiveNamespaces*>(p->ptr), struct _c14n__InclusiveNamespaces);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _c14n__InclusiveNamespaces*>(p->ptr), struct _c14n__InclusiveNamespaces);
		break;
	case SOAP_TYPE_ds__TransformType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignedInfoType*>(p->ptr), struct ds__SignedInfoType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignedInfoType*>(p->ptr), struct ds__SignedInfoType);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__CanonicalizationMethodType*>(p->ptr), struct ds__CanonicalizationMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__CanonicalizationMethodType*>(p->ptr), struct ds__CanonicalizationMethodType);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignatureMethodType*>(p->ptr), struct ds__SignatureMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignatureMethodType*>(p->ptr), struct ds__SignatureMethodType);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__ReferenceType*>(p->ptr), struct ds__ReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__ReferenceType*>(p->ptr), struct ds__ReferenceType);
		break;
	case SOAP_TYPE_ds__TransformsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__TransformsType*>(p->ptr), struct ds__TransformsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__TransformsType*>(p->ptr), struct ds__TransformsType);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__DigestMethodType*>(p->ptr), struct ds__DigestMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__DigestMethodType*>(p->ptr), struct ds__DigestMethodType);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__KeyValueType*>(p->ptr), struct ds__KeyValueType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__KeyValueType*>(p->ptr), struct ds__KeyValueType);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__RetrievalMethodType*>(p->ptr), struct ds__RetrievalMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__RetrievalMethodType*>(p->ptr), struct ds__RetrievalMethodType);
		break;
	case SOAP_TYPE_ds__X509DataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__X509DataType*>(p->ptr), struct ds__X509DataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__X509DataType*>(p->ptr), struct ds__X509DataType);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__X509IssuerSerialType*>(p->ptr), struct ds__X509IssuerSerialType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__X509IssuerSerialType*>(p->ptr), struct ds__X509IssuerSerialType);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__DSAKeyValueType*>(p->ptr), struct ds__DSAKeyValueType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__DSAKeyValueType*>(p->ptr), struct ds__DSAKeyValueType);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__RSAKeyValueType*>(p->ptr), struct ds__RSAKeyValueType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__RSAKeyValueType*>(p->ptr), struct ds__RSAKeyValueType);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptionPropertyType*>(p->ptr), struct xenc__EncryptionPropertyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptionPropertyType*>(p->ptr), struct xenc__EncryptionPropertyType);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptedType*>(p->ptr), struct xenc__EncryptedType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptedType*>(p->ptr), struct xenc__EncryptedType);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptionMethodType*>(p->ptr), struct xenc__EncryptionMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptionMethodType*>(p->ptr), struct xenc__EncryptionMethodType);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__CipherDataType*>(p->ptr), struct xenc__CipherDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__CipherDataType*>(p->ptr), struct xenc__CipherDataType);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__CipherReferenceType*>(p->ptr), struct xenc__CipherReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__CipherReferenceType*>(p->ptr), struct xenc__CipherReferenceType);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__TransformsType*>(p->ptr), struct xenc__TransformsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__TransformsType*>(p->ptr), struct xenc__TransformsType);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__AgreementMethodType*>(p->ptr), struct xenc__AgreementMethodType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__AgreementMethodType*>(p->ptr), struct xenc__AgreementMethodType);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__ReferenceType*>(p->ptr), struct xenc__ReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__ReferenceType*>(p->ptr), struct xenc__ReferenceType);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptionPropertiesType*>(p->ptr), struct xenc__EncryptionPropertiesType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptionPropertiesType*>(p->ptr), struct xenc__EncryptionPropertiesType);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __xenc__union_ReferenceList*>(p->ptr), struct __xenc__union_ReferenceList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __xenc__union_ReferenceList*>(p->ptr), struct __xenc__union_ReferenceList);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _xenc__ReferenceList*>(p->ptr), struct _xenc__ReferenceList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _xenc__ReferenceList*>(p->ptr), struct _xenc__ReferenceList);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptedDataType*>(p->ptr), struct xenc__EncryptedDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptedDataType*>(p->ptr), struct xenc__EncryptedDataType);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct xenc__EncryptedKeyType*>(p->ptr), struct xenc__EncryptedKeyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct xenc__EncryptedKeyType*>(p->ptr), struct xenc__EncryptedKeyType);
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsc__SecurityContextTokenType*>(p->ptr), struct wsc__SecurityContextTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsc__SecurityContextTokenType*>(p->ptr), struct wsc__SecurityContextTokenType);
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __wsc__DerivedKeyTokenType_sequence*>(p->ptr), struct __wsc__DerivedKeyTokenType_sequence);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __wsc__DerivedKeyTokenType_sequence*>(p->ptr), struct __wsc__DerivedKeyTokenType_sequence);
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsc__DerivedKeyTokenType*>(p->ptr), struct wsc__DerivedKeyTokenType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsc__DerivedKeyTokenType*>(p->ptr), struct wsc__DerivedKeyTokenType);
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsc__PropertiesType*>(p->ptr), struct wsc__PropertiesType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsc__PropertiesType*>(p->ptr), struct wsc__PropertiesType);
		break;
	case SOAP_TYPE___saml1__union_AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_AssertionType*>(p->ptr), struct __saml1__union_AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_AssertionType*>(p->ptr), struct __saml1__union_AssertionType);
		break;
	case SOAP_TYPE_saml1__AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		break;
	case SOAP_TYPE___saml1__union_ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_ConditionsType*>(p->ptr), struct __saml1__union_ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_ConditionsType*>(p->ptr), struct __saml1__union_ConditionsType);
		break;
	case SOAP_TYPE_saml1__ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		break;
	case SOAP_TYPE_saml1__ConditionAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		break;
	case SOAP_TYPE___saml1__union_AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_AdviceType*>(p->ptr), struct __saml1__union_AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_AdviceType*>(p->ptr), struct __saml1__union_AdviceType);
		break;
	case SOAP_TYPE_saml1__AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		break;
	case SOAP_TYPE_saml1__StatementAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		break;
	case SOAP_TYPE_saml1__SubjectType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		break;
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		break;
	case SOAP_TYPE_saml1__SubjectLocalityType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		break;
	case SOAP_TYPE_saml1__AuthorityBindingType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		break;
	case SOAP_TYPE___saml1__union_EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml1__union_EvidenceType*>(p->ptr), struct __saml1__union_EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml1__union_EvidenceType*>(p->ptr), struct __saml1__union_EvidenceType);
		break;
	case SOAP_TYPE_saml1__EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		break;
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		break;
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		break;
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		break;
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		break;
	case SOAP_TYPE_saml1__NameIdentifierType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		break;
	case SOAP_TYPE_saml1__ActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		break;
	case SOAP_TYPE_saml1__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		break;
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		break;
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		break;
	case SOAP_TYPE_saml1__AttributeStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		break;
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		break;
	case SOAP_TYPE_saml2__EncryptedElementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE___saml2__union_AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_AssertionType*>(p->ptr), struct __saml2__union_AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_AssertionType*>(p->ptr), struct __saml2__union_AssertionType);
		break;
	case SOAP_TYPE_saml2__AssertionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		break;
	case SOAP_TYPE_saml2__SubjectType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		break;
	case SOAP_TYPE___saml2__union_ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_ConditionsType*>(p->ptr), struct __saml2__union_ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_ConditionsType*>(p->ptr), struct __saml2__union_ConditionsType);
		break;
	case SOAP_TYPE_saml2__ConditionsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		break;
	case SOAP_TYPE_saml2__ConditionAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		break;
	case SOAP_TYPE___saml2__union_AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_AdviceType*>(p->ptr), struct __saml2__union_AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_AdviceType*>(p->ptr), struct __saml2__union_AdviceType);
		break;
	case SOAP_TYPE_saml2__AdviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		break;
	case SOAP_TYPE_saml2__StatementAbstractType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		break;
	case SOAP_TYPE_saml2__SubjectLocalityType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		break;
	case SOAP_TYPE_saml2__AuthnContextType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		break;
	case SOAP_TYPE___saml2__union_EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_EvidenceType*>(p->ptr), struct __saml2__union_EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_EvidenceType*>(p->ptr), struct __saml2__union_EvidenceType);
		break;
	case SOAP_TYPE_saml2__EvidenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		break;
	case SOAP_TYPE_saml2__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		break;
	case SOAP_TYPE_saml2__NameIDType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		break;
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		break;
	case SOAP_TYPE_saml2__OneTimeUseType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		break;
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		break;
	case SOAP_TYPE_saml2__AuthnStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		break;
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		break;
	case SOAP_TYPE_saml2__ActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		break;
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __saml2__union_AttributeStatementType*>(p->ptr), struct __saml2__union_AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __saml2__union_AttributeStatementType*>(p->ptr), struct __saml2__union_AttributeStatementType);
		break;
	case SOAP_TYPE_saml2__AttributeStatementType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		break;
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__KeyInfoConfirmationDataType*>(p->ptr), struct saml2__KeyInfoConfirmationDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__KeyInfoConfirmationDataType*>(p->ptr), struct saml2__KeyInfoConfirmationDataType);
		break;
	case SOAP_TYPE__wsse__Security:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Security*>(p->ptr), struct _wsse__Security);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Security*>(p->ptr), struct _wsse__Security);
		break;
	case SOAP_TYPE__wsse__Password:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _wsse__Password*>(p->ptr), struct _wsse__Password);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _wsse__Password*>(p->ptr), struct _wsse__Password);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__ID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__IDREF:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__duration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns4__duration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns4__guid:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__ds__Signature:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__SignatureType*>(p->ptr), struct ds__SignatureType);
		break;
	case SOAP_TYPE__ds__Transform:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__TransformType*>(p->ptr), struct ds__TransformType);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ds__KeyInfoType*>(p->ptr), struct ds__KeyInfoType);
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct timeval*>(p->ptr), struct timeval);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct timeval*>(p->ptr), struct timeval);
		break;
	case SOAP_TYPE__saml1__Assertion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AssertionType*>(p->ptr), struct saml1__AssertionType);
		break;
	case SOAP_TYPE__saml1__Conditions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionsType*>(p->ptr), struct saml1__ConditionsType);
		break;
	case SOAP_TYPE__saml1__Condition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ConditionAbstractType*>(p->ptr), struct saml1__ConditionAbstractType);
		break;
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AudienceRestrictionConditionType*>(p->ptr), struct saml1__AudienceRestrictionConditionType);
		break;
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__DoNotCacheConditionType*>(p->ptr), struct saml1__DoNotCacheConditionType);
		break;
	case SOAP_TYPE__saml1__Advice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AdviceType*>(p->ptr), struct saml1__AdviceType);
		break;
	case SOAP_TYPE__saml1__Statement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__StatementAbstractType*>(p->ptr), struct saml1__StatementAbstractType);
		break;
	case SOAP_TYPE__saml1__SubjectStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectStatementAbstractType*>(p->ptr), struct saml1__SubjectStatementAbstractType);
		break;
	case SOAP_TYPE__saml1__Subject:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectType*>(p->ptr), struct saml1__SubjectType);
		break;
	case SOAP_TYPE__saml1__NameIdentifier:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__NameIdentifierType*>(p->ptr), struct saml1__NameIdentifierType);
		break;
	case SOAP_TYPE__saml1__SubjectConfirmation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectConfirmationType*>(p->ptr), struct saml1__SubjectConfirmationType);
		break;
	case SOAP_TYPE__saml1__AuthenticationStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthenticationStatementType*>(p->ptr), struct saml1__AuthenticationStatementType);
		break;
	case SOAP_TYPE__saml1__SubjectLocality:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__SubjectLocalityType*>(p->ptr), struct saml1__SubjectLocalityType);
		break;
	case SOAP_TYPE__saml1__AuthorityBinding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorityBindingType*>(p->ptr), struct saml1__AuthorityBindingType);
		break;
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AuthorizationDecisionStatementType*>(p->ptr), struct saml1__AuthorizationDecisionStatementType);
		break;
	case SOAP_TYPE__saml1__Action:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__ActionType*>(p->ptr), struct saml1__ActionType);
		break;
	case SOAP_TYPE__saml1__Evidence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__EvidenceType*>(p->ptr), struct saml1__EvidenceType);
		break;
	case SOAP_TYPE__saml1__AttributeStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeStatementType*>(p->ptr), struct saml1__AttributeStatementType);
		break;
	case SOAP_TYPE__saml1__AttributeDesignator:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeDesignatorType*>(p->ptr), struct saml1__AttributeDesignatorType);
		break;
	case SOAP_TYPE__saml1__Attribute:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml1__AttributeType*>(p->ptr), struct saml1__AttributeType);
		break;
	case SOAP_TYPE__saml2__BaseID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__BaseIDAbstractType*>(p->ptr), struct saml2__BaseIDAbstractType);
		break;
	case SOAP_TYPE__saml2__NameID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		break;
	case SOAP_TYPE__saml2__EncryptedID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE__saml2__Issuer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__NameIDType*>(p->ptr), struct saml2__NameIDType);
		break;
	case SOAP_TYPE__saml2__Assertion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AssertionType*>(p->ptr), struct saml2__AssertionType);
		break;
	case SOAP_TYPE__saml2__Subject:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectType*>(p->ptr), struct saml2__SubjectType);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationType*>(p->ptr), struct saml2__SubjectConfirmationType);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectConfirmationDataType*>(p->ptr), struct saml2__SubjectConfirmationDataType);
		break;
	case SOAP_TYPE__saml2__Conditions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionsType*>(p->ptr), struct saml2__ConditionsType);
		break;
	case SOAP_TYPE__saml2__Condition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ConditionAbstractType*>(p->ptr), struct saml2__ConditionAbstractType);
		break;
	case SOAP_TYPE__saml2__AudienceRestriction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AudienceRestrictionType*>(p->ptr), struct saml2__AudienceRestrictionType);
		break;
	case SOAP_TYPE__saml2__OneTimeUse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__OneTimeUseType*>(p->ptr), struct saml2__OneTimeUseType);
		break;
	case SOAP_TYPE__saml2__ProxyRestriction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ProxyRestrictionType*>(p->ptr), struct saml2__ProxyRestrictionType);
		break;
	case SOAP_TYPE__saml2__Advice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AdviceType*>(p->ptr), struct saml2__AdviceType);
		break;
	case SOAP_TYPE__saml2__EncryptedAssertion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE__saml2__Statement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__StatementAbstractType*>(p->ptr), struct saml2__StatementAbstractType);
		break;
	case SOAP_TYPE__saml2__AuthnStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnStatementType*>(p->ptr), struct saml2__AuthnStatementType);
		break;
	case SOAP_TYPE__saml2__SubjectLocality:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__SubjectLocalityType*>(p->ptr), struct saml2__SubjectLocalityType);
		break;
	case SOAP_TYPE__saml2__AuthnContext:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthnContextType*>(p->ptr), struct saml2__AuthnContextType);
		break;
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AuthzDecisionStatementType*>(p->ptr), struct saml2__AuthzDecisionStatementType);
		break;
	case SOAP_TYPE__saml2__Action:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__ActionType*>(p->ptr), struct saml2__ActionType);
		break;
	case SOAP_TYPE__saml2__Evidence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EvidenceType*>(p->ptr), struct saml2__EvidenceType);
		break;
	case SOAP_TYPE__saml2__AttributeStatement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeStatementType*>(p->ptr), struct saml2__AttributeStatementType);
		break;
	case SOAP_TYPE__saml2__Attribute:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__AttributeType*>(p->ptr), struct saml2__AttributeType);
		break;
	case SOAP_TYPE__saml2__EncryptedAttribute:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct saml2__EncryptedElementType*>(p->ptr), struct saml2__EncryptedElementType);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__HashStructure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns5__HashStructure *> *>(p->ptr), std::vector<ns5__HashStructure *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns5__HashStructure *> *>(p->ptr), std::vector<ns5__HashStructure *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_xsd__ID__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__IDREF__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__QName__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__anyURI__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__base64Binary__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__boolean_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__byte__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__dateTime_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__decimal__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__double_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__duration__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__float_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__int_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__long_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__short_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__string_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__unsignedByte__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__unsignedInt_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__unsignedLong_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_xsd__unsignedShort_: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns4__char__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns4__duration__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns4__guid__: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns5__SignRequest: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns5__SignStatus: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns5__SignResponse: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns5__ArrayOfHashStructure: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns5__HashStructure: t = SOAP_TYPE_xsd__anyType; break;
		case SOAP_TYPE_ns5__MultipleSignRequest: t = SOAP_TYPE_xsd__anyType; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__HashStructure:
		if (t == SOAP_TYPE_ns5__HashStructure || soap_fbase(t, SOAP_TYPE_ns5__HashStructure))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__HashStructure *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__HashStructure *> *)p)[index] = *(ns5__HashStructure **)q;
		}
		break;
	case SOAP_TYPE_xsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyType type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyType*)p = *(xsd__anyType*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_xsd__ID__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__ID__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__ID__*)p = *(xsd__ID__*)q;
		break;
	case SOAP_TYPE_xsd__IDREF__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__IDREF__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__IDREF__*)p = *(xsd__IDREF__*)q;
		break;
	case SOAP_TYPE_xsd__QName__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__QName__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__QName__*)p = *(xsd__QName__*)q;
		break;
	case SOAP_TYPE_xsd__anyURI__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyURI__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyURI__*)p = *(xsd__anyURI__*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary__*)p = *(xsd__base64Binary__*)q;
		break;
	case SOAP_TYPE_xsd__boolean_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__boolean_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__boolean_*)p = *(xsd__boolean_*)q;
		break;
	case SOAP_TYPE_xsd__byte__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__byte__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__byte__*)p = *(xsd__byte__*)q;
		break;
	case SOAP_TYPE_xsd__dateTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__dateTime_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__dateTime_*)p = *(xsd__dateTime_*)q;
		break;
	case SOAP_TYPE_xsd__decimal__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__decimal__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__decimal__*)p = *(xsd__decimal__*)q;
		break;
	case SOAP_TYPE_xsd__double_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__double_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__double_*)p = *(xsd__double_*)q;
		break;
	case SOAP_TYPE_xsd__duration__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__duration__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__duration__*)p = *(xsd__duration__*)q;
		break;
	case SOAP_TYPE_xsd__float_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__float_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__float_*)p = *(xsd__float_*)q;
		break;
	case SOAP_TYPE_xsd__int_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__int_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__int_*)p = *(xsd__int_*)q;
		break;
	case SOAP_TYPE_xsd__long_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__long_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__long_*)p = *(xsd__long_*)q;
		break;
	case SOAP_TYPE_xsd__short_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__short_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__short_*)p = *(xsd__short_*)q;
		break;
	case SOAP_TYPE_xsd__string_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__string_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__string_*)p = *(xsd__string_*)q;
		break;
	case SOAP_TYPE_xsd__unsignedByte__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__unsignedByte__ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__unsignedByte__*)p = *(xsd__unsignedByte__*)q;
		break;
	case SOAP_TYPE_xsd__unsignedInt_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__unsignedInt_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__unsignedInt_*)p = *(xsd__unsignedInt_*)q;
		break;
	case SOAP_TYPE_xsd__unsignedLong_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__unsignedLong_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__unsignedLong_*)p = *(xsd__unsignedLong_*)q;
		break;
	case SOAP_TYPE_xsd__unsignedShort_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__unsignedShort_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__unsignedShort_*)p = *(xsd__unsignedShort_*)q;
		break;
	case SOAP_TYPE_ns4__char__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__char__ type=%d location=%p object=%p\n", t, p, q));
		*(ns4__char__*)p = *(ns4__char__*)q;
		break;
	case SOAP_TYPE_ns4__duration__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__duration__ type=%d location=%p object=%p\n", t, p, q));
		*(ns4__duration__*)p = *(ns4__duration__*)q;
		break;
	case SOAP_TYPE_ns4__guid__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__guid__ type=%d location=%p object=%p\n", t, p, q));
		*(ns4__guid__*)p = *(ns4__guid__*)q;
		break;
	case SOAP_TYPE__ns3__CCMovelSign:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__CCMovelSign type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__CCMovelSign*)p = *(_ns3__CCMovelSign*)q;
		break;
	case SOAP_TYPE__ns3__CCMovelSignResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__CCMovelSignResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__CCMovelSignResponse*)p = *(_ns3__CCMovelSignResponse*)q;
		break;
	case SOAP_TYPE__ns3__GetCertificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetCertificate type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetCertificate*)p = *(_ns3__GetCertificate*)q;
		break;
	case SOAP_TYPE__ns3__GetCertificateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetCertificateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetCertificateResponse*)p = *(_ns3__GetCertificateResponse*)q;
		break;
	case SOAP_TYPE__ns3__ValidateOtp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__ValidateOtp type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__ValidateOtp*)p = *(_ns3__ValidateOtp*)q;
		break;
	case SOAP_TYPE__ns3__ValidateOtpResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__ValidateOtpResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__ValidateOtpResponse*)p = *(_ns3__ValidateOtpResponse*)q;
		break;
	case SOAP_TYPE__ns3__CCMovelMultipleSign:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__CCMovelMultipleSign type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__CCMovelMultipleSign*)p = *(_ns3__CCMovelMultipleSign*)q;
		break;
	case SOAP_TYPE__ns3__CCMovelMultipleSignResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__CCMovelMultipleSignResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__CCMovelMultipleSignResponse*)p = *(_ns3__CCMovelMultipleSignResponse*)q;
		break;
	case SOAP_TYPE__ns3__ForceSMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__ForceSMS type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__ForceSMS*)p = *(_ns3__ForceSMS*)q;
		break;
	case SOAP_TYPE__ns3__ForceSMSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__ForceSMSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__ForceSMSResponse*)p = *(_ns3__ForceSMSResponse*)q;
		break;
	case SOAP_TYPE__ns3__GetCertificateWithPin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetCertificateWithPin type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetCertificateWithPin*)p = *(_ns3__GetCertificateWithPin*)q;
		break;
	case SOAP_TYPE__ns3__GetCertificateWithPinResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetCertificateWithPinResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetCertificateWithPinResponse*)p = *(_ns3__GetCertificateWithPinResponse*)q;
		break;
	case SOAP_TYPE_ns5__SignRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignRequest*)p = *(ns5__SignRequest*)q;
		break;
	case SOAP_TYPE_ns5__SignStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignStatus type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignStatus*)p = *(ns5__SignStatus*)q;
		break;
	case SOAP_TYPE_ns5__SignResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignResponse*)p = *(ns5__SignResponse*)q;
		break;
	case SOAP_TYPE_ns5__ArrayOfHashStructure:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ArrayOfHashStructure type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ArrayOfHashStructure*)p = *(ns5__ArrayOfHashStructure*)q;
		break;
	case SOAP_TYPE_ns5__HashStructure:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__HashStructure type=%d location=%p object=%p\n", t, p, q));
		*(ns5__HashStructure*)p = *(ns5__HashStructure*)q;
		break;
	case SOAP_TYPE_ns5__MultipleSignRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__MultipleSignRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns5__MultipleSignRequest*)p = *(ns5__MultipleSignRequest*)q;
		break;
	case SOAP_TYPE___ns1__CCMovelSign:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CCMovelSign type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CCMovelSign*)p = *(struct __ns1__CCMovelSign*)q;
		break;
	case SOAP_TYPE___ns1__GetCertificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetCertificate type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetCertificate*)p = *(struct __ns1__GetCertificate*)q;
		break;
	case SOAP_TYPE___ns1__ValidateOtp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ValidateOtp type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ValidateOtp*)p = *(struct __ns1__ValidateOtp*)q;
		break;
	case SOAP_TYPE___ns1__CCMovelMultipleSign:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CCMovelMultipleSign type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CCMovelMultipleSign*)p = *(struct __ns1__CCMovelMultipleSign*)q;
		break;
	case SOAP_TYPE___ns1__ForceSMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ForceSMS type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ForceSMS*)p = *(struct __ns1__ForceSMS*)q;
		break;
	case SOAP_TYPE___ns1__GetCertificateWithPin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetCertificateWithPin type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetCertificateWithPin*)p = *(struct __ns1__GetCertificateWithPin*)q;
		break;
	case SOAP_TYPE__wsu__Timestamp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsu__Timestamp type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsu__Timestamp*)p = *(struct _wsu__Timestamp*)q;
		break;
	case SOAP_TYPE_wsse__EncodedString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsse__EncodedString type=%d location=%p object=%p\n", t, p, q));
		*(struct wsse__EncodedString*)p = *(struct wsse__EncodedString*)q;
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__UsernameToken type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__UsernameToken*)p = *(struct _wsse__UsernameToken*)q;
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__BinarySecurityToken type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__BinarySecurityToken*)p = *(struct _wsse__BinarySecurityToken*)q;
		break;
	case SOAP_TYPE__wsse__Reference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Reference type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Reference*)p = *(struct _wsse__Reference*)q;
		break;
	case SOAP_TYPE__wsse__Embedded:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Embedded type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Embedded*)p = *(struct _wsse__Embedded*)q;
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__KeyIdentifier type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__KeyIdentifier*)p = *(struct _wsse__KeyIdentifier*)q;
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__SecurityTokenReference type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__SecurityTokenReference*)p = *(struct _wsse__SecurityTokenReference*)q;
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
		break;
	case SOAP_TYPE_ds__SignatureType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _c14n__InclusiveNamespaces type=%d location=%p object=%p\n", t, p, q));
		*(struct _c14n__InclusiveNamespaces*)p = *(struct _c14n__InclusiveNamespaces*)q;
		break;
	case SOAP_TYPE_ds__TransformType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignedInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignedInfoType*)p = *(struct ds__SignedInfoType*)q;
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__CanonicalizationMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__CanonicalizationMethodType*)p = *(struct ds__CanonicalizationMethodType*)q;
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureMethodType*)p = *(struct ds__SignatureMethodType*)q;
		break;
	case SOAP_TYPE_ds__ReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__ReferenceType*)p = *(struct ds__ReferenceType*)q;
		break;
	case SOAP_TYPE_ds__TransformsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformsType*)p = *(struct ds__TransformsType*)q;
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__DigestMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__DigestMethodType*)p = *(struct ds__DigestMethodType*)q;
		break;
	case SOAP_TYPE_ds__KeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyValueType*)p = *(struct ds__KeyValueType*)q;
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__RetrievalMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__RetrievalMethodType*)p = *(struct ds__RetrievalMethodType*)q;
		break;
	case SOAP_TYPE_ds__X509DataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__X509DataType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__X509DataType*)p = *(struct ds__X509DataType*)q;
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__X509IssuerSerialType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__X509IssuerSerialType*)p = *(struct ds__X509IssuerSerialType*)q;
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__DSAKeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__DSAKeyValueType*)p = *(struct ds__DSAKeyValueType*)q;
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__RSAKeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__RSAKeyValueType*)p = *(struct ds__RSAKeyValueType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionPropertyType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionPropertyType*)p = *(struct xenc__EncryptionPropertyType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedType*)p = *(struct xenc__EncryptedType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionMethodType*)p = *(struct xenc__EncryptionMethodType*)q;
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__CipherDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__CipherDataType*)p = *(struct xenc__CipherDataType*)q;
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__CipherReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__CipherReferenceType*)p = *(struct xenc__CipherReferenceType*)q;
		break;
	case SOAP_TYPE_xenc__TransformsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__TransformsType*)p = *(struct xenc__TransformsType*)q;
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__AgreementMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__AgreementMethodType*)p = *(struct xenc__AgreementMethodType*)q;
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__ReferenceType*)p = *(struct xenc__ReferenceType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionPropertiesType*)p = *(struct xenc__EncryptionPropertiesType*)q;
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __xenc__union_ReferenceList type=%d location=%p object=%p\n", t, p, q));
		*(struct __xenc__union_ReferenceList*)p = *(struct __xenc__union_ReferenceList*)q;
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _xenc__ReferenceList type=%d location=%p object=%p\n", t, p, q));
		*(struct _xenc__ReferenceList*)p = *(struct _xenc__ReferenceList*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedDataType*)p = *(struct xenc__EncryptedDataType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedKeyType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedKeyType*)p = *(struct xenc__EncryptedKeyType*)q;
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__SecurityContextTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__SecurityContextTokenType*)p = *(struct wsc__SecurityContextTokenType*)q;
		break;
	case SOAP_TYPE__wsc__union_DerivedKeyTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _wsc__union_DerivedKeyTokenType type=%d location=%p object=%p\n", t, p, q));
		*(union _wsc__union_DerivedKeyTokenType*)p = *(union _wsc__union_DerivedKeyTokenType*)q;
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsc__DerivedKeyTokenType_sequence type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsc__DerivedKeyTokenType_sequence*)p = *(struct __wsc__DerivedKeyTokenType_sequence*)q;
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__DerivedKeyTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__DerivedKeyTokenType*)p = *(struct wsc__DerivedKeyTokenType*)q;
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__PropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__PropertiesType*)p = *(struct wsc__PropertiesType*)q;
		break;
	case SOAP_TYPE___saml1__union_AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_AssertionType*)p = *(struct __saml1__union_AssertionType*)q;
		break;
	case SOAP_TYPE_saml1__AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AssertionType*)p = *(struct saml1__AssertionType*)q;
		break;
	case SOAP_TYPE___saml1__union_ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_ConditionsType*)p = *(struct __saml1__union_ConditionsType*)q;
		break;
	case SOAP_TYPE_saml1__ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionsType*)p = *(struct saml1__ConditionsType*)q;
		break;
	case SOAP_TYPE_saml1__ConditionAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionAbstractType*)p = *(struct saml1__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE___saml1__union_AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_AdviceType*)p = *(struct __saml1__union_AdviceType*)q;
		break;
	case SOAP_TYPE_saml1__AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AdviceType*)p = *(struct saml1__AdviceType*)q;
		break;
	case SOAP_TYPE_saml1__StatementAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__StatementAbstractType*)p = *(struct saml1__StatementAbstractType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectType*)p = *(struct saml1__SubjectType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectConfirmationType*)p = *(struct saml1__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectLocalityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectLocalityType*)p = *(struct saml1__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE_saml1__AuthorityBindingType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorityBindingType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorityBindingType*)p = *(struct saml1__AuthorityBindingType*)q;
		break;
	case SOAP_TYPE___saml1__union_EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml1__union_EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml1__union_EvidenceType*)p = *(struct __saml1__union_EvidenceType*)q;
		break;
	case SOAP_TYPE_saml1__EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__EvidenceType*)p = *(struct saml1__EvidenceType*)q;
		break;
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeDesignatorType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeDesignatorType*)p = *(struct saml1__AttributeDesignatorType*)q;
		break;
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AudienceRestrictionConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AudienceRestrictionConditionType*)p = *(struct saml1__AudienceRestrictionConditionType*)q;
		break;
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__DoNotCacheConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__DoNotCacheConditionType*)p = *(struct saml1__DoNotCacheConditionType*)q;
		break;
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectStatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectStatementAbstractType*)p = *(struct saml1__SubjectStatementAbstractType*)q;
		break;
	case SOAP_TYPE_saml1__NameIdentifierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__NameIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__NameIdentifierType*)p = *(struct saml1__NameIdentifierType*)q;
		break;
	case SOAP_TYPE_saml1__ActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ActionType*)p = *(struct saml1__ActionType*)q;
		break;
	case SOAP_TYPE_saml1__AttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeType*)p = *(struct saml1__AttributeType*)q;
		break;
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthenticationStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthenticationStatementType*)p = *(struct saml1__AuthenticationStatementType*)q;
		break;
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorizationDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorizationDecisionStatementType*)p = *(struct saml1__AuthorizationDecisionStatementType*)q;
		break;
	case SOAP_TYPE_saml1__AttributeStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeStatementType*)p = *(struct saml1__AttributeStatementType*)q;
		break;
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__BaseIDAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__BaseIDAbstractType*)p = *(struct saml2__BaseIDAbstractType*)q;
		break;
	case SOAP_TYPE_saml2__EncryptedElementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	case SOAP_TYPE___saml2__union_AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_AssertionType*)p = *(struct __saml2__union_AssertionType*)q;
		break;
	case SOAP_TYPE_saml2__AssertionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AssertionType*)p = *(struct saml2__AssertionType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectType*)p = *(struct saml2__SubjectType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationType*)p = *(struct saml2__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE___saml2__union_ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_ConditionsType*)p = *(struct __saml2__union_ConditionsType*)q;
		break;
	case SOAP_TYPE_saml2__ConditionsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionsType*)p = *(struct saml2__ConditionsType*)q;
		break;
	case SOAP_TYPE_saml2__ConditionAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionAbstractType*)p = *(struct saml2__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE___saml2__union_AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_AdviceType*)p = *(struct __saml2__union_AdviceType*)q;
		break;
	case SOAP_TYPE_saml2__AdviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AdviceType*)p = *(struct saml2__AdviceType*)q;
		break;
	case SOAP_TYPE_saml2__StatementAbstractType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__StatementAbstractType*)p = *(struct saml2__StatementAbstractType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectLocalityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectLocalityType*)p = *(struct saml2__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE_saml2__AuthnContextType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnContextType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnContextType*)p = *(struct saml2__AuthnContextType*)q;
		break;
	case SOAP_TYPE___saml2__union_EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_EvidenceType*)p = *(struct __saml2__union_EvidenceType*)q;
		break;
	case SOAP_TYPE_saml2__EvidenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EvidenceType*)p = *(struct saml2__EvidenceType*)q;
		break;
	case SOAP_TYPE_saml2__AttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeType*)p = *(struct saml2__AttributeType*)q;
		break;
	case SOAP_TYPE_saml2__NameIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__NameIDType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__NameIDType*)p = *(struct saml2__NameIDType*)q;
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationDataType*)p = *(struct saml2__SubjectConfirmationDataType*)q;
		break;
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AudienceRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AudienceRestrictionType*)p = *(struct saml2__AudienceRestrictionType*)q;
		break;
	case SOAP_TYPE_saml2__OneTimeUseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__OneTimeUseType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__OneTimeUseType*)p = *(struct saml2__OneTimeUseType*)q;
		break;
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ProxyRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ProxyRestrictionType*)p = *(struct saml2__ProxyRestrictionType*)q;
		break;
	case SOAP_TYPE_saml2__AuthnStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnStatementType*)p = *(struct saml2__AuthnStatementType*)q;
		break;
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthzDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthzDecisionStatementType*)p = *(struct saml2__AuthzDecisionStatementType*)q;
		break;
	case SOAP_TYPE_saml2__ActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ActionType*)p = *(struct saml2__ActionType*)q;
		break;
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __saml2__union_AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct __saml2__union_AttributeStatementType*)p = *(struct __saml2__union_AttributeStatementType*)q;
		break;
	case SOAP_TYPE_saml2__AttributeStatementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeStatementType*)p = *(struct saml2__AttributeStatementType*)q;
		break;
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__KeyInfoConfirmationDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__KeyInfoConfirmationDataType*)p = *(struct saml2__KeyInfoConfirmationDataType*)q;
		break;
	case SOAP_TYPE__wsse__Security:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Security type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Security*)p = *(struct _wsse__Security*)q;
		break;
	case SOAP_TYPE__wsse__Password:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Password type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Password*)p = *(struct _wsse__Password*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__ID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__IDREF:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__duration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__duration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__guid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__ds__Signature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
		break;
	case SOAP_TYPE__ds__Transform:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
		break;
	case SOAP_TYPE__ds__KeyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
		break;
	case SOAP_TYPE_xsd__dateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct timeval type=%d location=%p object=%p\n", t, p, q));
		*(struct timeval*)p = *(struct timeval*)q;
		break;
	case SOAP_TYPE__saml1__Assertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AssertionType*)p = *(struct saml1__AssertionType*)q;
		break;
	case SOAP_TYPE__saml1__Conditions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionsType*)p = *(struct saml1__ConditionsType*)q;
		break;
	case SOAP_TYPE__saml1__Condition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ConditionAbstractType*)p = *(struct saml1__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AudienceRestrictionConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AudienceRestrictionConditionType*)p = *(struct saml1__AudienceRestrictionConditionType*)q;
		break;
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__DoNotCacheConditionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__DoNotCacheConditionType*)p = *(struct saml1__DoNotCacheConditionType*)q;
		break;
	case SOAP_TYPE__saml1__Advice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AdviceType*)p = *(struct saml1__AdviceType*)q;
		break;
	case SOAP_TYPE__saml1__Statement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__StatementAbstractType*)p = *(struct saml1__StatementAbstractType*)q;
		break;
	case SOAP_TYPE__saml1__SubjectStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectStatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectStatementAbstractType*)p = *(struct saml1__SubjectStatementAbstractType*)q;
		break;
	case SOAP_TYPE__saml1__Subject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectType*)p = *(struct saml1__SubjectType*)q;
		break;
	case SOAP_TYPE__saml1__NameIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__NameIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__NameIdentifierType*)p = *(struct saml1__NameIdentifierType*)q;
		break;
	case SOAP_TYPE__saml1__SubjectConfirmation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectConfirmationType*)p = *(struct saml1__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE__saml1__AuthenticationStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthenticationStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthenticationStatementType*)p = *(struct saml1__AuthenticationStatementType*)q;
		break;
	case SOAP_TYPE__saml1__SubjectLocality:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__SubjectLocalityType*)p = *(struct saml1__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE__saml1__AuthorityBinding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorityBindingType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorityBindingType*)p = *(struct saml1__AuthorityBindingType*)q;
		break;
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AuthorizationDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AuthorizationDecisionStatementType*)p = *(struct saml1__AuthorizationDecisionStatementType*)q;
		break;
	case SOAP_TYPE__saml1__Action:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__ActionType*)p = *(struct saml1__ActionType*)q;
		break;
	case SOAP_TYPE__saml1__Evidence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__EvidenceType*)p = *(struct saml1__EvidenceType*)q;
		break;
	case SOAP_TYPE__saml1__AttributeStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeStatementType*)p = *(struct saml1__AttributeStatementType*)q;
		break;
	case SOAP_TYPE__saml1__AttributeDesignator:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeDesignatorType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeDesignatorType*)p = *(struct saml1__AttributeDesignatorType*)q;
		break;
	case SOAP_TYPE__saml1__Attribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml1__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml1__AttributeType*)p = *(struct saml1__AttributeType*)q;
		break;
	case SOAP_TYPE__saml2__BaseID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__BaseIDAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__BaseIDAbstractType*)p = *(struct saml2__BaseIDAbstractType*)q;
		break;
	case SOAP_TYPE__saml2__NameID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__NameIDType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__NameIDType*)p = *(struct saml2__NameIDType*)q;
		break;
	case SOAP_TYPE__saml2__EncryptedID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	case SOAP_TYPE__saml2__Issuer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__NameIDType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__NameIDType*)p = *(struct saml2__NameIDType*)q;
		break;
	case SOAP_TYPE__saml2__Assertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AssertionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AssertionType*)p = *(struct saml2__AssertionType*)q;
		break;
	case SOAP_TYPE__saml2__Subject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectType*)p = *(struct saml2__SubjectType*)q;
		break;
	case SOAP_TYPE__saml2__SubjectConfirmation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationType*)p = *(struct saml2__SubjectConfirmationType*)q;
		break;
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectConfirmationDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectConfirmationDataType*)p = *(struct saml2__SubjectConfirmationDataType*)q;
		break;
	case SOAP_TYPE__saml2__Conditions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionsType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionsType*)p = *(struct saml2__ConditionsType*)q;
		break;
	case SOAP_TYPE__saml2__Condition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ConditionAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ConditionAbstractType*)p = *(struct saml2__ConditionAbstractType*)q;
		break;
	case SOAP_TYPE__saml2__AudienceRestriction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AudienceRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AudienceRestrictionType*)p = *(struct saml2__AudienceRestrictionType*)q;
		break;
	case SOAP_TYPE__saml2__OneTimeUse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__OneTimeUseType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__OneTimeUseType*)p = *(struct saml2__OneTimeUseType*)q;
		break;
	case SOAP_TYPE__saml2__ProxyRestriction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ProxyRestrictionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ProxyRestrictionType*)p = *(struct saml2__ProxyRestrictionType*)q;
		break;
	case SOAP_TYPE__saml2__Advice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AdviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AdviceType*)p = *(struct saml2__AdviceType*)q;
		break;
	case SOAP_TYPE__saml2__EncryptedAssertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	case SOAP_TYPE__saml2__Statement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__StatementAbstractType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__StatementAbstractType*)p = *(struct saml2__StatementAbstractType*)q;
		break;
	case SOAP_TYPE__saml2__AuthnStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnStatementType*)p = *(struct saml2__AuthnStatementType*)q;
		break;
	case SOAP_TYPE__saml2__SubjectLocality:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__SubjectLocalityType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__SubjectLocalityType*)p = *(struct saml2__SubjectLocalityType*)q;
		break;
	case SOAP_TYPE__saml2__AuthnContext:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthnContextType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthnContextType*)p = *(struct saml2__AuthnContextType*)q;
		break;
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AuthzDecisionStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AuthzDecisionStatementType*)p = *(struct saml2__AuthzDecisionStatementType*)q;
		break;
	case SOAP_TYPE__saml2__Action:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__ActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__ActionType*)p = *(struct saml2__ActionType*)q;
		break;
	case SOAP_TYPE__saml2__Evidence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EvidenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EvidenceType*)p = *(struct saml2__EvidenceType*)q;
		break;
	case SOAP_TYPE__saml2__AttributeStatement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeStatementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeStatementType*)p = *(struct saml2__AttributeStatementType*)q;
		break;
	case SOAP_TYPE__saml2__Attribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__AttributeType*)p = *(struct saml2__AttributeType*)q;
		break;
	case SOAP_TYPE__saml2__EncryptedAttribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct saml2__EncryptedElementType type=%d location=%p object=%p\n", t, p, q));
		*(struct saml2__EncryptedElementType*)p = *(struct saml2__EncryptedElementType*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_xsd__byte(soap, tag ? tag : "xsd:byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	a = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return a;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_new_short(struct soap *soap, int n)
{
	short *a = static_cast<short *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(short)));
	for (short *p = a; p && n--; ++p)
		soap_default_short(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	if (soap_out_short(soap, tag ? tag : "short", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__char(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns4__char);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns4__char(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_ns4__char);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__char(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_ns4__char(soap, tag ? tag : "ns4:char", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns4__char(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__char(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_xsd__unsignedByte(soap, tag ? tag : "xsd:unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{
	a = soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
	return a;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_new_unsignedShort(struct soap *soap, int n)
{
	unsigned short *a = static_cast<unsigned short *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned short)));
	for (unsigned short *p = a; p && n--; ++p)
		soap_default_unsignedShort(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	if (soap_out_unsignedShort(soap, tag ? tag : "unsignedShort", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml2__DecisionType[] =
{	{ (LONG64)saml2__DecisionType__Permit, "Permit" },
	{ (LONG64)saml2__DecisionType__Deny, "Deny" },
	{ (LONG64)saml2__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml2__DecisionType2s(struct soap *soap, enum saml2__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml2__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__DecisionType(struct soap *soap, const char *tag, int id, const enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__DecisionType), type) || soap_send(soap, soap_saml2__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml2__DecisionType(struct soap *soap, const char *s, enum saml2__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml2__DecisionType, s);
	if (map)
		*a = (enum saml2__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml2__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_in_saml2__DecisionType(struct soap *soap, const char *tag, enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml2__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml2__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml2__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__DecisionType, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_new_saml2__DecisionType(struct soap *soap, int n)
{
	enum saml2__DecisionType *a = static_cast<enum saml2__DecisionType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum saml2__DecisionType)));
	for (enum saml2__DecisionType *p = a; p && n--; ++p)
		soap_default_saml2__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__DecisionType(struct soap *soap, const enum saml2__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__DecisionType(soap, tag ? tag : "saml2:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_get_saml2__DecisionType(struct soap *soap, enum saml2__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml1__DecisionType[] =
{	{ (LONG64)saml1__DecisionType__Permit, "Permit" },
	{ (LONG64)saml1__DecisionType__Deny, "Deny" },
	{ (LONG64)saml1__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml1__DecisionType2s(struct soap *soap, enum saml1__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml1__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DecisionType(struct soap *soap, const char *tag, int id, const enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DecisionType), type) || soap_send(soap, soap_saml1__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml1__DecisionType(struct soap *soap, const char *s, enum saml1__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml1__DecisionType, s);
	if (map)
		*a = (enum saml1__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml1__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_in_saml1__DecisionType(struct soap *soap, const char *tag, enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml1__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml1__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml1__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DecisionType, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_new_saml1__DecisionType(struct soap *soap, int n)
{
	enum saml1__DecisionType *a = static_cast<enum saml1__DecisionType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum saml1__DecisionType)));
	for (enum saml1__DecisionType *p = a; p && n--; ++p)
		soap_default_saml1__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DecisionType(struct soap *soap, const enum saml1__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DecisionType(soap, tag ? tag : "saml1:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_get_saml1__DecisionType(struct soap *soap, enum saml1__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsc__FaultCodeType[] =
{	{ (LONG64)wsc__BadContextToken, "wsc:BadContextToken" },
	{ (LONG64)wsc__UnsupportedContextToken, "wsc:UnsupportedContextToken" },
	{ (LONG64)wsc__UnknownDerivationSource, "wsc:UnknownDerivationSource" },
	{ (LONG64)wsc__RenewNeeded, "wsc:RenewNeeded" },
	{ (LONG64)wsc__UnableToRenew, "wsc:UnableToRenew" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsc__FaultCodeType2s(struct soap *soap, enum wsc__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsc__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__FaultCodeType), type) || soap_send(soap, soap_wsc__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsc__FaultCodeType(struct soap *soap, const char *s, enum wsc__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsc__FaultCodeType, t);
	if (map)
		*a = (enum wsc__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsc__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_in_wsc__FaultCodeType(struct soap *soap, const char *tag, enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsc__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsc__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsc__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__FaultCodeType, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_new_wsc__FaultCodeType(struct soap *soap, int n)
{
	enum wsc__FaultCodeType *a = static_cast<enum wsc__FaultCodeType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsc__FaultCodeType)));
	for (enum wsc__FaultCodeType *p = a; p && n--; ++p)
		soap_default_wsc__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeType(struct soap *soap, const enum wsc__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeType(soap, tag ? tag : "wsc:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_get_wsc__FaultCodeType(struct soap *soap, enum wsc__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (LONG64)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (LONG64)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (LONG64)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (LONG64)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (LONG64)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (LONG64)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (LONG64)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{
	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_new_wsse__FaultcodeEnum(struct soap *soap, int n)
{
	enum wsse__FaultcodeEnum *a = static_cast<enum wsse__FaultcodeEnum *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsse__FaultcodeEnum)));
	for (enum wsse__FaultcodeEnum *p = a; p && n--; ++p)
		soap_default_wsse__FaultcodeEnum(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	if (soap_out_wsse__FaultcodeEnum(soap, tag ? tag : "wsse:FaultcodeEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (LONG64)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{
	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsu__tTimestampFault(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_new_wsu__tTimestampFault(struct soap *soap, int n)
{
	enum wsu__tTimestampFault *a = static_cast<enum wsu__tTimestampFault *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsu__tTimestampFault)));
	for (enum wsu__tTimestampFault *p = a; p && n--; ++p)
		soap_default_wsu__tTimestampFault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	if (soap_out_wsu__tTimestampFault(soap, tag ? tag : "wsu:tTimestampFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__guid__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns4__guid(soap, &this->ns4__guid__::__item);
}

void ns4__guid__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__guid(soap, &this->ns4__guid__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns4__guid__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__guid__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__guid__(struct soap *soap, const char *tag, int id, const ns4__guid__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns4__guid(soap, tag, id, &a->ns4__guid__::__item, "ns4:guid");
}

void *ns4__guid__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__guid__(soap, tag, this, type);
}

SOAP_FMAC3 ns4__guid__ * SOAP_FMAC4 soap_in_ns4__guid__(struct soap *soap, const char *tag, ns4__guid__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__guid__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__guid__, sizeof(ns4__guid__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__guid__)
		return (ns4__guid__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns4__guid(soap, tag, &a->ns4__guid__::__item, "ns4:guid"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns4__guid__ * SOAP_FMAC2 soap_instantiate_ns4__guid__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__guid__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__guid__ *p;
	size_t k = sizeof(ns4__guid__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__guid__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__guid__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__guid__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__guid__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__guid__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__guid__(soap, tag ? tag : "ns4:guid", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__guid__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__guid__(soap, this, tag, type);
}

SOAP_FMAC3 ns4__guid__ * SOAP_FMAC4 soap_get_ns4__guid__(struct soap *soap, ns4__guid__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__guid__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__guid(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__guid(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__guid), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__guid(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__guid, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[\\da-fA-F]{8}-[\\da-fA-F]{4}-[\\da-fA-F]{4}-[\\da-fA-F]{4}-[\\da-fA-F]{12}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__guid, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns4__guid, SOAP_TYPE_ns4__guid, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__guid(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__guid(soap, tag ? tag : "ns4:guid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__guid(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__duration__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns4__duration(soap, &this->ns4__duration__::__item);
}

void ns4__duration__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__duration(soap, &this->ns4__duration__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns4__duration__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__duration__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__duration__(struct soap *soap, const char *tag, int id, const ns4__duration__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns4__duration(soap, tag, id, &a->ns4__duration__::__item, "ns4:duration");
}

void *ns4__duration__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__duration__(soap, tag, this, type);
}

SOAP_FMAC3 ns4__duration__ * SOAP_FMAC4 soap_in_ns4__duration__(struct soap *soap, const char *tag, ns4__duration__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__duration__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__duration__, sizeof(ns4__duration__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__duration__)
		return (ns4__duration__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns4__duration(soap, tag, &a->ns4__duration__::__item, "ns4:duration"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns4__duration__ * SOAP_FMAC2 soap_instantiate_ns4__duration__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__duration__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__duration__ *p;
	size_t k = sizeof(ns4__duration__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__duration__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__duration__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__duration__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__duration__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__duration__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__duration__(soap, tag ? tag : "ns4:duration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__duration__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__duration__(soap, this, tag, type);
}

SOAP_FMAC3 ns4__duration__ * SOAP_FMAC4 soap_get_ns4__duration__(struct soap *soap, ns4__duration__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__duration__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\-?P(\\d*D)?(T(\\d*H)?(\\d*M)?(\\d*(\\.\\d*)?S)?)?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns4__duration, SOAP_TYPE_ns4__duration, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__duration(soap, tag ? tag : "ns4:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__char__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns4__char(soap, &this->ns4__char__::__item);
}

void ns4__char__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns4__char__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__char__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__char__(struct soap *soap, const char *tag, int id, const ns4__char__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns4__char(soap, tag, id, &a->ns4__char__::__item, "ns4:char");
}

void *ns4__char__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__char__(soap, tag, this, type);
}

SOAP_FMAC3 ns4__char__ * SOAP_FMAC4 soap_in_ns4__char__(struct soap *soap, const char *tag, ns4__char__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__char__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__char__, sizeof(ns4__char__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__char__)
		return (ns4__char__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns4__char(soap, tag, &a->ns4__char__::__item, "ns4:char"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns4__char__ * SOAP_FMAC2 soap_instantiate_ns4__char__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__char__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__char__ *p;
	size_t k = sizeof(ns4__char__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__char__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__char__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__char__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__char__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__char__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__char__(soap, tag ? tag : "ns4:char", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__char__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__char__(soap, this, tag, type);
}

SOAP_FMAC3 ns4__char__ * SOAP_FMAC4 soap_get_ns4__char__(struct soap *soap, ns4__char__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__char__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__MultipleSignRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__MultipleSignRequest::ApplicationId = NULL;
	this->ns5__MultipleSignRequest::Pin = NULL;
	this->ns5__MultipleSignRequest::UserId = NULL;
}

void ns5__MultipleSignRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns5__MultipleSignRequest::ApplicationId);
	soap_serialize_PointerTostd__string(soap, &this->ns5__MultipleSignRequest::Pin);
	soap_serialize_PointerTostd__string(soap, &this->ns5__MultipleSignRequest::UserId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__MultipleSignRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MultipleSignRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__MultipleSignRequest(struct soap *soap, const char *tag, int id, const ns5__MultipleSignRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__MultipleSignRequest), type ? type : "ns5:MultipleSignRequest"))
		return soap->error;
	if (!a->ns5__MultipleSignRequest::ApplicationId)
	{	if (soap_element_nil(soap, "ns5:ApplicationId"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__base64Binary(soap, "ns5:ApplicationId", -1, &a->ns5__MultipleSignRequest::ApplicationId, ""))
		return soap->error;
	if (!a->ns5__MultipleSignRequest::Pin)
	{	if (soap_element_nil(soap, "ns5:Pin"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:Pin", -1, &a->ns5__MultipleSignRequest::Pin, ""))
		return soap->error;
	if (!a->ns5__MultipleSignRequest::UserId)
	{	if (soap_element_nil(soap, "ns5:UserId"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:UserId", -1, &a->ns5__MultipleSignRequest::UserId, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__MultipleSignRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__MultipleSignRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MultipleSignRequest * SOAP_FMAC4 soap_in_ns5__MultipleSignRequest(struct soap *soap, const char *tag, ns5__MultipleSignRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MultipleSignRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__MultipleSignRequest, sizeof(ns5__MultipleSignRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__MultipleSignRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__MultipleSignRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ApplicationId1 = 1;
	size_t soap_flag_Pin1 = 1;
	size_t soap_flag_UserId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ApplicationId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns5:ApplicationId", &a->ns5__MultipleSignRequest::ApplicationId, "xsd:base64Binary"))
				{	soap_flag_ApplicationId1--;
					continue;
				}
			}
			if (soap_flag_Pin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Pin", &a->ns5__MultipleSignRequest::Pin, "xsd:string"))
				{	soap_flag_Pin1--;
					continue;
				}
			}
			if (soap_flag_UserId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:UserId", &a->ns5__MultipleSignRequest::UserId, "xsd:string"))
				{	soap_flag_UserId1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ApplicationId1 > 0 || soap_flag_Pin1 > 0 || soap_flag_UserId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__MultipleSignRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__MultipleSignRequest, SOAP_TYPE_ns5__MultipleSignRequest, sizeof(ns5__MultipleSignRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__MultipleSignRequest * SOAP_FMAC2 soap_instantiate_ns5__MultipleSignRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MultipleSignRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__MultipleSignRequest *p;
	size_t k = sizeof(ns5__MultipleSignRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns5__MultipleSignRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns5__MultipleSignRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns5__MultipleSignRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__MultipleSignRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns5__MultipleSignRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__MultipleSignRequest(soap, tag ? tag : "ns5:MultipleSignRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__MultipleSignRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MultipleSignRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MultipleSignRequest * SOAP_FMAC4 soap_get_ns5__MultipleSignRequest(struct soap *soap, ns5__MultipleSignRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__MultipleSignRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__HashStructure::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__HashStructure::Hash = NULL;
	this->ns5__HashStructure::Name = NULL;
	this->ns5__HashStructure::id = NULL;
}

void ns5__HashStructure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns5__HashStructure::Hash);
	soap_serialize_PointerTostd__string(soap, &this->ns5__HashStructure::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns5__HashStructure::id);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__HashStructure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__HashStructure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__HashStructure(struct soap *soap, const char *tag, int id, const ns5__HashStructure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__HashStructure), type ? type : "ns5:HashStructure"))
		return soap->error;
	if (!a->ns5__HashStructure::Hash)
	{	if (soap_element_nil(soap, "ns5:Hash"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__base64Binary(soap, "ns5:Hash", -1, &a->ns5__HashStructure::Hash, ""))
		return soap->error;
	if (!a->ns5__HashStructure::Name)
	{	if (soap_element_nil(soap, "ns5:Name"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:Name", -1, &a->ns5__HashStructure::Name, ""))
		return soap->error;
	if (!a->ns5__HashStructure::id)
	{	if (soap_element_nil(soap, "ns5:id"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:id", -1, &a->ns5__HashStructure::id, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__HashStructure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__HashStructure(soap, tag, this, type);
}

SOAP_FMAC3 ns5__HashStructure * SOAP_FMAC4 soap_in_ns5__HashStructure(struct soap *soap, const char *tag, ns5__HashStructure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__HashStructure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__HashStructure, sizeof(ns5__HashStructure), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__HashStructure)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__HashStructure *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Hash1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hash1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns5:Hash", &a->ns5__HashStructure::Hash, "xsd:base64Binary"))
				{	soap_flag_Hash1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Name", &a->ns5__HashStructure::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:id", &a->ns5__HashStructure::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hash1 > 0 || soap_flag_Name1 > 0 || soap_flag_id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__HashStructure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__HashStructure, SOAP_TYPE_ns5__HashStructure, sizeof(ns5__HashStructure), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__HashStructure * SOAP_FMAC2 soap_instantiate_ns5__HashStructure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__HashStructure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__HashStructure *p;
	size_t k = sizeof(ns5__HashStructure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns5__HashStructure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns5__HashStructure);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns5__HashStructure, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__HashStructure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns5__HashStructure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__HashStructure(soap, tag ? tag : "ns5:HashStructure", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__HashStructure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__HashStructure(soap, this, tag, type);
}

SOAP_FMAC3 ns5__HashStructure * SOAP_FMAC4 soap_get_ns5__HashStructure(struct soap *soap, ns5__HashStructure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__HashStructure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ArrayOfHashStructure::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTons5__HashStructure(soap, &this->ns5__ArrayOfHashStructure::HashStructure);
}

void ns5__ArrayOfHashStructure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__HashStructure(soap, &this->ns5__ArrayOfHashStructure::HashStructure);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__ArrayOfHashStructure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ArrayOfHashStructure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ArrayOfHashStructure(struct soap *soap, const char *tag, int id, const ns5__ArrayOfHashStructure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ArrayOfHashStructure), type ? type : "ns5:ArrayOfHashStructure"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__HashStructure(soap, "ns5:HashStructure", -1, &a->ns5__ArrayOfHashStructure::HashStructure, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ArrayOfHashStructure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ArrayOfHashStructure(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ArrayOfHashStructure * SOAP_FMAC4 soap_in_ns5__ArrayOfHashStructure(struct soap *soap, const char *tag, ns5__ArrayOfHashStructure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ArrayOfHashStructure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ArrayOfHashStructure, sizeof(ns5__ArrayOfHashStructure), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ArrayOfHashStructure)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ArrayOfHashStructure *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__HashStructure(soap, "ns5:HashStructure", &a->ns5__ArrayOfHashStructure::HashStructure, "ns5:HashStructure"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ArrayOfHashStructure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ArrayOfHashStructure, SOAP_TYPE_ns5__ArrayOfHashStructure, sizeof(ns5__ArrayOfHashStructure), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ArrayOfHashStructure * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfHashStructure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ArrayOfHashStructure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ArrayOfHashStructure *p;
	size_t k = sizeof(ns5__ArrayOfHashStructure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns5__ArrayOfHashStructure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns5__ArrayOfHashStructure);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns5__ArrayOfHashStructure, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ArrayOfHashStructure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns5__ArrayOfHashStructure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ArrayOfHashStructure(soap, tag ? tag : "ns5:ArrayOfHashStructure", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ArrayOfHashStructure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ArrayOfHashStructure(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ArrayOfHashStructure * SOAP_FMAC4 soap_get_ns5__ArrayOfHashStructure(struct soap *soap, ns5__ArrayOfHashStructure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ArrayOfHashStructure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SignResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__SignResponse::ArrayOfHashStructure = NULL;
	this->ns5__SignResponse::Signature = NULL;
	this->ns5__SignResponse::Status = NULL;
	this->ns5__SignResponse::certificate = NULL;
}

void ns5__SignResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__ArrayOfHashStructure(soap, &this->ns5__SignResponse::ArrayOfHashStructure);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns5__SignResponse::Signature);
	soap_serialize_PointerTons5__SignStatus(soap, &this->ns5__SignResponse::Status);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignResponse::certificate);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__SignResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SignResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SignResponse(struct soap *soap, const char *tag, int id, const ns5__SignResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SignResponse), type ? type : "ns5:SignResponse"))
		return soap->error;
	if (!a->ns5__SignResponse::ArrayOfHashStructure)
	{	if (soap_element_nil(soap, "ns5:ArrayOfHashStructure"))
			return soap->error;
	}
	else if (soap_out_PointerTons5__ArrayOfHashStructure(soap, "ns5:ArrayOfHashStructure", -1, &a->ns5__SignResponse::ArrayOfHashStructure, ""))
		return soap->error;
	if (!a->ns5__SignResponse::Signature)
	{	if (soap_element_nil(soap, "ns5:Signature"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__base64Binary(soap, "ns5:Signature", -1, &a->ns5__SignResponse::Signature, ""))
		return soap->error;
	if (!a->ns5__SignResponse::Status)
	{	if (soap_element_nil(soap, "ns5:Status"))
			return soap->error;
	}
	else if (soap_out_PointerTons5__SignStatus(soap, "ns5:Status", -1, &a->ns5__SignResponse::Status, ""))
		return soap->error;
	if (!a->ns5__SignResponse::certificate)
	{	if (soap_element_nil(soap, "ns5:certificate"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:certificate", -1, &a->ns5__SignResponse::certificate, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SignResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__SignResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SignResponse * SOAP_FMAC4 soap_in_ns5__SignResponse(struct soap *soap, const char *tag, ns5__SignResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SignResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SignResponse, sizeof(ns5__SignResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SignResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SignResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ArrayOfHashStructure1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_certificate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ArrayOfHashStructure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ArrayOfHashStructure(soap, "ns5:ArrayOfHashStructure", &a->ns5__SignResponse::ArrayOfHashStructure, "ns5:ArrayOfHashStructure"))
				{	soap_flag_ArrayOfHashStructure1--;
					continue;
				}
			}
			if (soap_flag_Signature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns5:Signature", &a->ns5__SignResponse::Signature, "xsd:base64Binary"))
				{	soap_flag_Signature1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignStatus(soap, "ns5:Status", &a->ns5__SignResponse::Status, "ns5:SignStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_certificate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:certificate", &a->ns5__SignResponse::certificate, "xsd:string"))
				{	soap_flag_certificate1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ArrayOfHashStructure1 > 0 || soap_flag_Signature1 > 0 || soap_flag_Status1 > 0 || soap_flag_certificate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__SignResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SignResponse, SOAP_TYPE_ns5__SignResponse, sizeof(ns5__SignResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SignResponse * SOAP_FMAC2 soap_instantiate_ns5__SignResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SignResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SignResponse *p;
	size_t k = sizeof(ns5__SignResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns5__SignResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns5__SignResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns5__SignResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SignResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns5__SignResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SignResponse(soap, tag ? tag : "ns5:SignResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SignResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SignResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SignResponse * SOAP_FMAC4 soap_get_ns5__SignResponse(struct soap *soap, ns5__SignResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SignResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SignStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__SignStatus::Code = NULL;
	this->ns5__SignStatus::Field = NULL;
	this->ns5__SignStatus::FieldValue = NULL;
	this->ns5__SignStatus::Message = NULL;
	this->ns5__SignStatus::ProcessId = NULL;
}

void ns5__SignStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignStatus::Code);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignStatus::Field);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignStatus::FieldValue);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignStatus::Message);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignStatus::ProcessId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__SignStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SignStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SignStatus(struct soap *soap, const char *tag, int id, const ns5__SignStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SignStatus), type ? type : "ns5:SignStatus"))
		return soap->error;
	if (!a->ns5__SignStatus::Code)
	{	if (soap_element_nil(soap, "ns5:Code"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:Code", -1, &a->ns5__SignStatus::Code, ""))
		return soap->error;
	if (!a->ns5__SignStatus::Field)
	{	if (soap_element_nil(soap, "ns5:Field"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:Field", -1, &a->ns5__SignStatus::Field, ""))
		return soap->error;
	if (!a->ns5__SignStatus::FieldValue)
	{	if (soap_element_nil(soap, "ns5:FieldValue"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:FieldValue", -1, &a->ns5__SignStatus::FieldValue, ""))
		return soap->error;
	if (!a->ns5__SignStatus::Message)
	{	if (soap_element_nil(soap, "ns5:Message"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:Message", -1, &a->ns5__SignStatus::Message, ""))
		return soap->error;
	if (!a->ns5__SignStatus::ProcessId)
	{	if (soap_element_nil(soap, "ns5:ProcessId"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:ProcessId", -1, &a->ns5__SignStatus::ProcessId, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SignStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__SignStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SignStatus * SOAP_FMAC4 soap_in_ns5__SignStatus(struct soap *soap, const char *tag, ns5__SignStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SignStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SignStatus, sizeof(ns5__SignStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SignStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SignStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Field1 = 1;
	size_t soap_flag_FieldValue1 = 1;
	size_t soap_flag_Message1 = 1;
	size_t soap_flag_ProcessId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Code", &a->ns5__SignStatus::Code, "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Field", &a->ns5__SignStatus::Field, "xsd:string"))
				{	soap_flag_Field1--;
					continue;
				}
			}
			if (soap_flag_FieldValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:FieldValue", &a->ns5__SignStatus::FieldValue, "xsd:string"))
				{	soap_flag_FieldValue1--;
					continue;
				}
			}
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Message", &a->ns5__SignStatus::Message, "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			}
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:ProcessId", &a->ns5__SignStatus::ProcessId, "xsd:string"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0 || soap_flag_Field1 > 0 || soap_flag_FieldValue1 > 0 || soap_flag_Message1 > 0 || soap_flag_ProcessId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__SignStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SignStatus, SOAP_TYPE_ns5__SignStatus, sizeof(ns5__SignStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SignStatus * SOAP_FMAC2 soap_instantiate_ns5__SignStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SignStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SignStatus *p;
	size_t k = sizeof(ns5__SignStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns5__SignStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns5__SignStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns5__SignStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SignStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns5__SignStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SignStatus(soap, tag ? tag : "ns5:SignStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SignStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SignStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SignStatus * SOAP_FMAC4 soap_get_ns5__SignStatus(struct soap *soap, ns5__SignStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SignStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SignRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__SignRequest::ApplicationId = NULL;
	this->ns5__SignRequest::DocName = NULL;
	this->ns5__SignRequest::Hash = NULL;
	this->ns5__SignRequest::Pin = NULL;
	this->ns5__SignRequest::UserId = NULL;
}

void ns5__SignRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns5__SignRequest::ApplicationId);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignRequest::DocName);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns5__SignRequest::Hash);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignRequest::Pin);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SignRequest::UserId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__SignRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SignRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SignRequest(struct soap *soap, const char *tag, int id, const ns5__SignRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SignRequest), type ? type : "ns5:SignRequest"))
		return soap->error;
	if (!a->ns5__SignRequest::ApplicationId)
	{	if (soap_element_nil(soap, "ns5:ApplicationId"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__base64Binary(soap, "ns5:ApplicationId", -1, &a->ns5__SignRequest::ApplicationId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:DocName", -1, &a->ns5__SignRequest::DocName, ""))
		return soap->error;
	if (!a->ns5__SignRequest::Hash)
	{	if (soap_element_nil(soap, "ns5:Hash"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__base64Binary(soap, "ns5:Hash", -1, &a->ns5__SignRequest::Hash, ""))
		return soap->error;
	if (!a->ns5__SignRequest::Pin)
	{	if (soap_element_nil(soap, "ns5:Pin"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:Pin", -1, &a->ns5__SignRequest::Pin, ""))
		return soap->error;
	if (!a->ns5__SignRequest::UserId)
	{	if (soap_element_nil(soap, "ns5:UserId"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns5:UserId", -1, &a->ns5__SignRequest::UserId, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SignRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__SignRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SignRequest * SOAP_FMAC4 soap_in_ns5__SignRequest(struct soap *soap, const char *tag, ns5__SignRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SignRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SignRequest, sizeof(ns5__SignRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SignRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SignRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ApplicationId1 = 1;
	size_t soap_flag_DocName1 = 1;
	size_t soap_flag_Hash1 = 1;
	size_t soap_flag_Pin1 = 1;
	size_t soap_flag_UserId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ApplicationId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns5:ApplicationId", &a->ns5__SignRequest::ApplicationId, "xsd:base64Binary"))
				{	soap_flag_ApplicationId1--;
					continue;
				}
			}
			if (soap_flag_DocName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:DocName", &a->ns5__SignRequest::DocName, "xsd:string"))
				{	soap_flag_DocName1--;
					continue;
				}
			}
			if (soap_flag_Hash1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns5:Hash", &a->ns5__SignRequest::Hash, "xsd:base64Binary"))
				{	soap_flag_Hash1--;
					continue;
				}
			}
			if (soap_flag_Pin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Pin", &a->ns5__SignRequest::Pin, "xsd:string"))
				{	soap_flag_Pin1--;
					continue;
				}
			}
			if (soap_flag_UserId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:UserId", &a->ns5__SignRequest::UserId, "xsd:string"))
				{	soap_flag_UserId1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ApplicationId1 > 0 || soap_flag_Hash1 > 0 || soap_flag_Pin1 > 0 || soap_flag_UserId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__SignRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SignRequest, SOAP_TYPE_ns5__SignRequest, sizeof(ns5__SignRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SignRequest * SOAP_FMAC2 soap_instantiate_ns5__SignRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SignRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SignRequest *p;
	size_t k = sizeof(ns5__SignRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns5__SignRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns5__SignRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns5__SignRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SignRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns5__SignRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SignRequest(soap, tag ? tag : "ns5:SignRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SignRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SignRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SignRequest * SOAP_FMAC4 soap_get_ns5__SignRequest(struct soap *soap, ns5__SignRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SignRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetCertificateWithPinResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetCertificateWithPinResponse::GetCertificateWithPinResult = NULL;
}

void _ns3__GetCertificateWithPinResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignStatus(soap, &this->_ns3__GetCertificateWithPinResponse::GetCertificateWithPinResult);
#endif
}

int _ns3__GetCertificateWithPinResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCertificateWithPinResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCertificateWithPinResponse(struct soap *soap, const char *tag, int id, const _ns3__GetCertificateWithPinResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCertificateWithPinResponse), type))
		return soap->error;
	if (a->GetCertificateWithPinResult)
		soap_element_result(soap, "ns3:GetCertificateWithPinResult");
	if (soap_out_PointerTons5__SignStatus(soap, "ns3:GetCertificateWithPinResult", -1, &a->_ns3__GetCertificateWithPinResponse::GetCertificateWithPinResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCertificateWithPinResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__GetCertificateWithPinResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCertificateWithPinResponse * SOAP_FMAC4 soap_in__ns3__GetCertificateWithPinResponse(struct soap *soap, const char *tag, _ns3__GetCertificateWithPinResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCertificateWithPinResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCertificateWithPinResponse, sizeof(_ns3__GetCertificateWithPinResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetCertificateWithPinResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetCertificateWithPinResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetCertificateWithPinResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCertificateWithPinResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignStatus(soap, "ns3:GetCertificateWithPinResult", &a->_ns3__GetCertificateWithPinResponse::GetCertificateWithPinResult, "ns5:SignStatus"))
				{	soap_flag_GetCertificateWithPinResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:GetCertificateWithPinResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetCertificateWithPinResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCertificateWithPinResponse, SOAP_TYPE__ns3__GetCertificateWithPinResponse, sizeof(_ns3__GetCertificateWithPinResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetCertificateWithPinResponse * SOAP_FMAC2 soap_instantiate__ns3__GetCertificateWithPinResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCertificateWithPinResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetCertificateWithPinResponse *p;
	size_t k = sizeof(_ns3__GetCertificateWithPinResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__GetCertificateWithPinResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__GetCertificateWithPinResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__GetCertificateWithPinResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetCertificateWithPinResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__GetCertificateWithPinResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetCertificateWithPinResponse(soap, tag ? tag : "ns3:GetCertificateWithPinResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetCertificateWithPinResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCertificateWithPinResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCertificateWithPinResponse * SOAP_FMAC4 soap_get__ns3__GetCertificateWithPinResponse(struct soap *soap, _ns3__GetCertificateWithPinResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCertificateWithPinResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetCertificateWithPin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetCertificateWithPin::applicationId = NULL;
	this->_ns3__GetCertificateWithPin::userId = NULL;
	this->_ns3__GetCertificateWithPin::signaturePin = NULL;
}

void _ns3__GetCertificateWithPin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__GetCertificateWithPin::applicationId);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__GetCertificateWithPin::userId);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__GetCertificateWithPin::signaturePin);
#endif
}

int _ns3__GetCertificateWithPin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCertificateWithPin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCertificateWithPin(struct soap *soap, const char *tag, int id, const _ns3__GetCertificateWithPin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCertificateWithPin), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:applicationId", -1, &a->_ns3__GetCertificateWithPin::applicationId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:userId", -1, &a->_ns3__GetCertificateWithPin::userId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:signaturePin", -1, &a->_ns3__GetCertificateWithPin::signaturePin, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCertificateWithPin::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__GetCertificateWithPin(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCertificateWithPin * SOAP_FMAC4 soap_in__ns3__GetCertificateWithPin(struct soap *soap, const char *tag, _ns3__GetCertificateWithPin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCertificateWithPin*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCertificateWithPin, sizeof(_ns3__GetCertificateWithPin), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetCertificateWithPin)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetCertificateWithPin *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_applicationId1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_signaturePin1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_applicationId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns3:applicationId", &a->_ns3__GetCertificateWithPin::applicationId, "xsd:base64Binary"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:userId", &a->_ns3__GetCertificateWithPin::userId, "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			}
			if (soap_flag_signaturePin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:signaturePin", &a->_ns3__GetCertificateWithPin::signaturePin, "xsd:string"))
				{	soap_flag_signaturePin1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetCertificateWithPin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCertificateWithPin, SOAP_TYPE__ns3__GetCertificateWithPin, sizeof(_ns3__GetCertificateWithPin), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetCertificateWithPin * SOAP_FMAC2 soap_instantiate__ns3__GetCertificateWithPin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCertificateWithPin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetCertificateWithPin *p;
	size_t k = sizeof(_ns3__GetCertificateWithPin);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__GetCertificateWithPin, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__GetCertificateWithPin);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__GetCertificateWithPin, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetCertificateWithPin location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__GetCertificateWithPin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetCertificateWithPin(soap, tag ? tag : "ns3:GetCertificateWithPin", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetCertificateWithPin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCertificateWithPin(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCertificateWithPin * SOAP_FMAC4 soap_get__ns3__GetCertificateWithPin(struct soap *soap, _ns3__GetCertificateWithPin *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCertificateWithPin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__ForceSMSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__ForceSMSResponse::ForceSMSResult = NULL;
}

void _ns3__ForceSMSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignStatus(soap, &this->_ns3__ForceSMSResponse::ForceSMSResult);
#endif
}

int _ns3__ForceSMSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ForceSMSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ForceSMSResponse(struct soap *soap, const char *tag, int id, const _ns3__ForceSMSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ForceSMSResponse), type))
		return soap->error;
	if (a->ForceSMSResult)
		soap_element_result(soap, "ns3:ForceSMSResult");
	if (soap_out_PointerTons5__SignStatus(soap, "ns3:ForceSMSResult", -1, &a->_ns3__ForceSMSResponse::ForceSMSResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__ForceSMSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__ForceSMSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ForceSMSResponse * SOAP_FMAC4 soap_in__ns3__ForceSMSResponse(struct soap *soap, const char *tag, _ns3__ForceSMSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ForceSMSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ForceSMSResponse, sizeof(_ns3__ForceSMSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__ForceSMSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__ForceSMSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ForceSMSResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ForceSMSResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignStatus(soap, "ns3:ForceSMSResult", &a->_ns3__ForceSMSResponse::ForceSMSResult, "ns5:SignStatus"))
				{	soap_flag_ForceSMSResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:ForceSMSResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ForceSMSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ForceSMSResponse, SOAP_TYPE__ns3__ForceSMSResponse, sizeof(_ns3__ForceSMSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__ForceSMSResponse * SOAP_FMAC2 soap_instantiate__ns3__ForceSMSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ForceSMSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__ForceSMSResponse *p;
	size_t k = sizeof(_ns3__ForceSMSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__ForceSMSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__ForceSMSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__ForceSMSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__ForceSMSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__ForceSMSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__ForceSMSResponse(soap, tag ? tag : "ns3:ForceSMSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ForceSMSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ForceSMSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ForceSMSResponse * SOAP_FMAC4 soap_get__ns3__ForceSMSResponse(struct soap *soap, _ns3__ForceSMSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ForceSMSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__ForceSMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__ForceSMS::processId = NULL;
	this->_ns3__ForceSMS::citizenId = NULL;
	this->_ns3__ForceSMS::applicationId = NULL;
}

void _ns3__ForceSMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns3__ForceSMS::processId);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__ForceSMS::citizenId);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__ForceSMS::applicationId);
#endif
}

int _ns3__ForceSMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ForceSMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ForceSMS(struct soap *soap, const char *tag, int id, const _ns3__ForceSMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ForceSMS), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:processId", -1, &a->_ns3__ForceSMS::processId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:citizenId", -1, &a->_ns3__ForceSMS::citizenId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:applicationId", -1, &a->_ns3__ForceSMS::applicationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__ForceSMS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__ForceSMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ForceSMS * SOAP_FMAC4 soap_in__ns3__ForceSMS(struct soap *soap, const char *tag, _ns3__ForceSMS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ForceSMS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ForceSMS, sizeof(_ns3__ForceSMS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__ForceSMS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__ForceSMS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_citizenId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_processId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:processId", &a->_ns3__ForceSMS::processId, "xsd:string"))
				{	soap_flag_processId1--;
					continue;
				}
			}
			if (soap_flag_citizenId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:citizenId", &a->_ns3__ForceSMS::citizenId, "xsd:string"))
				{	soap_flag_citizenId1--;
					continue;
				}
			}
			if (soap_flag_applicationId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns3:applicationId", &a->_ns3__ForceSMS::applicationId, "xsd:base64Binary"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ForceSMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ForceSMS, SOAP_TYPE__ns3__ForceSMS, sizeof(_ns3__ForceSMS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__ForceSMS * SOAP_FMAC2 soap_instantiate__ns3__ForceSMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ForceSMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__ForceSMS *p;
	size_t k = sizeof(_ns3__ForceSMS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__ForceSMS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__ForceSMS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__ForceSMS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__ForceSMS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__ForceSMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__ForceSMS(soap, tag ? tag : "ns3:ForceSMS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ForceSMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ForceSMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ForceSMS * SOAP_FMAC4 soap_get__ns3__ForceSMS(struct soap *soap, _ns3__ForceSMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ForceSMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__CCMovelMultipleSignResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CCMovelMultipleSignResponse::CCMovelMultipleSignResult = NULL;
}

void _ns3__CCMovelMultipleSignResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignStatus(soap, &this->_ns3__CCMovelMultipleSignResponse::CCMovelMultipleSignResult);
#endif
}

int _ns3__CCMovelMultipleSignResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CCMovelMultipleSignResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CCMovelMultipleSignResponse(struct soap *soap, const char *tag, int id, const _ns3__CCMovelMultipleSignResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CCMovelMultipleSignResponse), type))
		return soap->error;
	if (a->CCMovelMultipleSignResult)
		soap_element_result(soap, "ns3:CCMovelMultipleSignResult");
	if (soap_out_PointerTons5__SignStatus(soap, "ns3:CCMovelMultipleSignResult", -1, &a->_ns3__CCMovelMultipleSignResponse::CCMovelMultipleSignResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__CCMovelMultipleSignResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__CCMovelMultipleSignResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CCMovelMultipleSignResponse * SOAP_FMAC4 soap_in__ns3__CCMovelMultipleSignResponse(struct soap *soap, const char *tag, _ns3__CCMovelMultipleSignResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CCMovelMultipleSignResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CCMovelMultipleSignResponse, sizeof(_ns3__CCMovelMultipleSignResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__CCMovelMultipleSignResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__CCMovelMultipleSignResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CCMovelMultipleSignResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CCMovelMultipleSignResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignStatus(soap, "ns3:CCMovelMultipleSignResult", &a->_ns3__CCMovelMultipleSignResponse::CCMovelMultipleSignResult, "ns5:SignStatus"))
				{	soap_flag_CCMovelMultipleSignResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:CCMovelMultipleSignResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CCMovelMultipleSignResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CCMovelMultipleSignResponse, SOAP_TYPE__ns3__CCMovelMultipleSignResponse, sizeof(_ns3__CCMovelMultipleSignResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__CCMovelMultipleSignResponse * SOAP_FMAC2 soap_instantiate__ns3__CCMovelMultipleSignResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CCMovelMultipleSignResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__CCMovelMultipleSignResponse *p;
	size_t k = sizeof(_ns3__CCMovelMultipleSignResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__CCMovelMultipleSignResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__CCMovelMultipleSignResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__CCMovelMultipleSignResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__CCMovelMultipleSignResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__CCMovelMultipleSignResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__CCMovelMultipleSignResponse(soap, tag ? tag : "ns3:CCMovelMultipleSignResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__CCMovelMultipleSignResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CCMovelMultipleSignResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CCMovelMultipleSignResponse * SOAP_FMAC4 soap_get__ns3__CCMovelMultipleSignResponse(struct soap *soap, _ns3__CCMovelMultipleSignResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CCMovelMultipleSignResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__CCMovelMultipleSign::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CCMovelMultipleSign::request = NULL;
	this->_ns3__CCMovelMultipleSign::documents = NULL;
}

void _ns3__CCMovelMultipleSign::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__MultipleSignRequest(soap, &this->_ns3__CCMovelMultipleSign::request);
	soap_serialize_PointerTons5__ArrayOfHashStructure(soap, &this->_ns3__CCMovelMultipleSign::documents);
#endif
}

int _ns3__CCMovelMultipleSign::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CCMovelMultipleSign(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CCMovelMultipleSign(struct soap *soap, const char *tag, int id, const _ns3__CCMovelMultipleSign *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CCMovelMultipleSign), type))
		return soap->error;
	if (soap_out_PointerTons5__MultipleSignRequest(soap, "ns3:request", -1, &a->_ns3__CCMovelMultipleSign::request, ""))
		return soap->error;
	if (soap_out_PointerTons5__ArrayOfHashStructure(soap, "ns3:documents", -1, &a->_ns3__CCMovelMultipleSign::documents, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__CCMovelMultipleSign::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__CCMovelMultipleSign(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CCMovelMultipleSign * SOAP_FMAC4 soap_in__ns3__CCMovelMultipleSign(struct soap *soap, const char *tag, _ns3__CCMovelMultipleSign *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CCMovelMultipleSign*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CCMovelMultipleSign, sizeof(_ns3__CCMovelMultipleSign), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__CCMovelMultipleSign)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__CCMovelMultipleSign *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_request1 = 1;
	size_t soap_flag_documents1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__MultipleSignRequest(soap, "ns3:request", &a->_ns3__CCMovelMultipleSign::request, "ns5:MultipleSignRequest"))
				{	soap_flag_request1--;
					continue;
				}
			}
			if (soap_flag_documents1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ArrayOfHashStructure(soap, "ns3:documents", &a->_ns3__CCMovelMultipleSign::documents, "ns5:ArrayOfHashStructure"))
				{	soap_flag_documents1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CCMovelMultipleSign *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CCMovelMultipleSign, SOAP_TYPE__ns3__CCMovelMultipleSign, sizeof(_ns3__CCMovelMultipleSign), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__CCMovelMultipleSign * SOAP_FMAC2 soap_instantiate__ns3__CCMovelMultipleSign(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CCMovelMultipleSign(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__CCMovelMultipleSign *p;
	size_t k = sizeof(_ns3__CCMovelMultipleSign);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__CCMovelMultipleSign, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__CCMovelMultipleSign);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__CCMovelMultipleSign, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__CCMovelMultipleSign location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__CCMovelMultipleSign::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__CCMovelMultipleSign(soap, tag ? tag : "ns3:CCMovelMultipleSign", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__CCMovelMultipleSign::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CCMovelMultipleSign(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CCMovelMultipleSign * SOAP_FMAC4 soap_get__ns3__CCMovelMultipleSign(struct soap *soap, _ns3__CCMovelMultipleSign *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CCMovelMultipleSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__ValidateOtpResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__ValidateOtpResponse::ValidateOtpResult = NULL;
}

void _ns3__ValidateOtpResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignResponse(soap, &this->_ns3__ValidateOtpResponse::ValidateOtpResult);
#endif
}

int _ns3__ValidateOtpResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ValidateOtpResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ValidateOtpResponse(struct soap *soap, const char *tag, int id, const _ns3__ValidateOtpResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ValidateOtpResponse), type))
		return soap->error;
	if (a->ValidateOtpResult)
		soap_element_result(soap, "ns3:ValidateOtpResult");
	if (soap_out_PointerTons5__SignResponse(soap, "ns3:ValidateOtpResult", -1, &a->_ns3__ValidateOtpResponse::ValidateOtpResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__ValidateOtpResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__ValidateOtpResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ValidateOtpResponse * SOAP_FMAC4 soap_in__ns3__ValidateOtpResponse(struct soap *soap, const char *tag, _ns3__ValidateOtpResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ValidateOtpResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ValidateOtpResponse, sizeof(_ns3__ValidateOtpResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__ValidateOtpResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__ValidateOtpResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ValidateOtpResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ValidateOtpResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignResponse(soap, "ns3:ValidateOtpResult", &a->_ns3__ValidateOtpResponse::ValidateOtpResult, "ns5:SignResponse"))
				{	soap_flag_ValidateOtpResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:ValidateOtpResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ValidateOtpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ValidateOtpResponse, SOAP_TYPE__ns3__ValidateOtpResponse, sizeof(_ns3__ValidateOtpResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__ValidateOtpResponse * SOAP_FMAC2 soap_instantiate__ns3__ValidateOtpResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ValidateOtpResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__ValidateOtpResponse *p;
	size_t k = sizeof(_ns3__ValidateOtpResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__ValidateOtpResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__ValidateOtpResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__ValidateOtpResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__ValidateOtpResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__ValidateOtpResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__ValidateOtpResponse(soap, tag ? tag : "ns3:ValidateOtpResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ValidateOtpResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ValidateOtpResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ValidateOtpResponse * SOAP_FMAC4 soap_get__ns3__ValidateOtpResponse(struct soap *soap, _ns3__ValidateOtpResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ValidateOtpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__ValidateOtp::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__ValidateOtp::code = NULL;
	this->_ns3__ValidateOtp::processId = NULL;
	this->_ns3__ValidateOtp::applicationId = NULL;
}

void _ns3__ValidateOtp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns3__ValidateOtp::code);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__ValidateOtp::processId);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__ValidateOtp::applicationId);
#endif
}

int _ns3__ValidateOtp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ValidateOtp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ValidateOtp(struct soap *soap, const char *tag, int id, const _ns3__ValidateOtp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ValidateOtp), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:code", -1, &a->_ns3__ValidateOtp::code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:processId", -1, &a->_ns3__ValidateOtp::processId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:applicationId", -1, &a->_ns3__ValidateOtp::applicationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__ValidateOtp::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__ValidateOtp(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ValidateOtp * SOAP_FMAC4 soap_in__ns3__ValidateOtp(struct soap *soap, const char *tag, _ns3__ValidateOtp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ValidateOtp*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ValidateOtp, sizeof(_ns3__ValidateOtp), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__ValidateOtp)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__ValidateOtp *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:code", &a->_ns3__ValidateOtp::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_processId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:processId", &a->_ns3__ValidateOtp::processId, "xsd:string"))
				{	soap_flag_processId1--;
					continue;
				}
			}
			if (soap_flag_applicationId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns3:applicationId", &a->_ns3__ValidateOtp::applicationId, "xsd:base64Binary"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ValidateOtp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ValidateOtp, SOAP_TYPE__ns3__ValidateOtp, sizeof(_ns3__ValidateOtp), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__ValidateOtp * SOAP_FMAC2 soap_instantiate__ns3__ValidateOtp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ValidateOtp(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__ValidateOtp *p;
	size_t k = sizeof(_ns3__ValidateOtp);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__ValidateOtp, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__ValidateOtp);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__ValidateOtp, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__ValidateOtp location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__ValidateOtp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__ValidateOtp(soap, tag ? tag : "ns3:ValidateOtp", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ValidateOtp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ValidateOtp(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ValidateOtp * SOAP_FMAC4 soap_get__ns3__ValidateOtp(struct soap *soap, _ns3__ValidateOtp *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ValidateOtp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetCertificateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetCertificateResponse::GetCertificateResult = NULL;
}

void _ns3__GetCertificateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns3__GetCertificateResponse::GetCertificateResult);
#endif
}

int _ns3__GetCertificateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCertificateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCertificateResponse(struct soap *soap, const char *tag, int id, const _ns3__GetCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCertificateResponse), type))
		return soap->error;
	if (a->GetCertificateResult)
		soap_element_result(soap, "ns3:GetCertificateResult");
	if (soap_out_PointerTostd__string(soap, "ns3:GetCertificateResult", -1, &a->_ns3__GetCertificateResponse::GetCertificateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCertificateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__GetCertificateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCertificateResponse * SOAP_FMAC4 soap_in__ns3__GetCertificateResponse(struct soap *soap, const char *tag, _ns3__GetCertificateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCertificateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCertificateResponse, sizeof(_ns3__GetCertificateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetCertificateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetCertificateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetCertificateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCertificateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:GetCertificateResult", &a->_ns3__GetCertificateResponse::GetCertificateResult, "xsd:string"))
				{	soap_flag_GetCertificateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:GetCertificateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCertificateResponse, SOAP_TYPE__ns3__GetCertificateResponse, sizeof(_ns3__GetCertificateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetCertificateResponse * SOAP_FMAC2 soap_instantiate__ns3__GetCertificateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCertificateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetCertificateResponse *p;
	size_t k = sizeof(_ns3__GetCertificateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__GetCertificateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__GetCertificateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__GetCertificateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetCertificateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__GetCertificateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetCertificateResponse(soap, tag ? tag : "ns3:GetCertificateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetCertificateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCertificateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCertificateResponse * SOAP_FMAC4 soap_get__ns3__GetCertificateResponse(struct soap *soap, _ns3__GetCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetCertificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetCertificate::applicationId = NULL;
	this->_ns3__GetCertificate::userId = NULL;
}

void _ns3__GetCertificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__GetCertificate::applicationId);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__GetCertificate::userId);
#endif
}

int _ns3__GetCertificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCertificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCertificate(struct soap *soap, const char *tag, int id, const _ns3__GetCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCertificate), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:applicationId", -1, &a->_ns3__GetCertificate::applicationId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:userId", -1, &a->_ns3__GetCertificate::userId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCertificate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__GetCertificate(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCertificate * SOAP_FMAC4 soap_in__ns3__GetCertificate(struct soap *soap, const char *tag, _ns3__GetCertificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCertificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCertificate, sizeof(_ns3__GetCertificate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetCertificate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetCertificate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_applicationId1 = 1;
	size_t soap_flag_userId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_applicationId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns3:applicationId", &a->_ns3__GetCertificate::applicationId, "xsd:base64Binary"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:userId", &a->_ns3__GetCertificate::userId, "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCertificate, SOAP_TYPE__ns3__GetCertificate, sizeof(_ns3__GetCertificate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetCertificate * SOAP_FMAC2 soap_instantiate__ns3__GetCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCertificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetCertificate *p;
	size_t k = sizeof(_ns3__GetCertificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__GetCertificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__GetCertificate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__GetCertificate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetCertificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__GetCertificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetCertificate(soap, tag ? tag : "ns3:GetCertificate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetCertificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCertificate(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCertificate * SOAP_FMAC4 soap_get__ns3__GetCertificate(struct soap *soap, _ns3__GetCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__CCMovelSignResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CCMovelSignResponse::CCMovelSignResult = NULL;
}

void _ns3__CCMovelSignResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignStatus(soap, &this->_ns3__CCMovelSignResponse::CCMovelSignResult);
#endif
}

int _ns3__CCMovelSignResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CCMovelSignResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CCMovelSignResponse(struct soap *soap, const char *tag, int id, const _ns3__CCMovelSignResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CCMovelSignResponse), type))
		return soap->error;
	if (a->CCMovelSignResult)
		soap_element_result(soap, "ns3:CCMovelSignResult");
	if (soap_out_PointerTons5__SignStatus(soap, "ns3:CCMovelSignResult", -1, &a->_ns3__CCMovelSignResponse::CCMovelSignResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__CCMovelSignResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__CCMovelSignResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CCMovelSignResponse * SOAP_FMAC4 soap_in__ns3__CCMovelSignResponse(struct soap *soap, const char *tag, _ns3__CCMovelSignResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CCMovelSignResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CCMovelSignResponse, sizeof(_ns3__CCMovelSignResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__CCMovelSignResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__CCMovelSignResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CCMovelSignResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CCMovelSignResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignStatus(soap, "ns3:CCMovelSignResult", &a->_ns3__CCMovelSignResponse::CCMovelSignResult, "ns5:SignStatus"))
				{	soap_flag_CCMovelSignResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:CCMovelSignResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CCMovelSignResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CCMovelSignResponse, SOAP_TYPE__ns3__CCMovelSignResponse, sizeof(_ns3__CCMovelSignResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__CCMovelSignResponse * SOAP_FMAC2 soap_instantiate__ns3__CCMovelSignResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CCMovelSignResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__CCMovelSignResponse *p;
	size_t k = sizeof(_ns3__CCMovelSignResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__CCMovelSignResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__CCMovelSignResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__CCMovelSignResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__CCMovelSignResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__CCMovelSignResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__CCMovelSignResponse(soap, tag ? tag : "ns3:CCMovelSignResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__CCMovelSignResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CCMovelSignResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CCMovelSignResponse * SOAP_FMAC4 soap_get__ns3__CCMovelSignResponse(struct soap *soap, _ns3__CCMovelSignResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CCMovelSignResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__CCMovelSign::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CCMovelSign::request = NULL;
}

void _ns3__CCMovelSign::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignRequest(soap, &this->_ns3__CCMovelSign::request);
#endif
}

int _ns3__CCMovelSign::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CCMovelSign(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CCMovelSign(struct soap *soap, const char *tag, int id, const _ns3__CCMovelSign *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CCMovelSign), type))
		return soap->error;
	if (soap_out_PointerTons5__SignRequest(soap, "ns3:request", -1, &a->_ns3__CCMovelSign::request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__CCMovelSign::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__CCMovelSign(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CCMovelSign * SOAP_FMAC4 soap_in__ns3__CCMovelSign(struct soap *soap, const char *tag, _ns3__CCMovelSign *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CCMovelSign*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CCMovelSign, sizeof(_ns3__CCMovelSign), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__CCMovelSign)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__CCMovelSign *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_request1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignRequest(soap, "ns3:request", &a->_ns3__CCMovelSign::request, "ns5:SignRequest"))
				{	soap_flag_request1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CCMovelSign *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CCMovelSign, SOAP_TYPE__ns3__CCMovelSign, sizeof(_ns3__CCMovelSign), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__CCMovelSign * SOAP_FMAC2 soap_instantiate__ns3__CCMovelSign(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CCMovelSign(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__CCMovelSign *p;
	size_t k = sizeof(_ns3__CCMovelSign);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__CCMovelSign, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__CCMovelSign);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__CCMovelSign, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__CCMovelSign location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__CCMovelSign::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__CCMovelSign(soap, tag ? tag : "ns3:CCMovelSign", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__CCMovelSign::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CCMovelSign(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CCMovelSign * SOAP_FMAC4 soap_get__ns3__CCMovelSign(struct soap *soap, _ns3__CCMovelSign *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CCMovelSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__unsignedShort_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_unsignedShort(soap, &this->xsd__unsignedShort_::__item);
}

void xsd__unsignedShort_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedShort_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedShort_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort_(struct soap *soap, const char *tag, int id, const xsd__unsignedShort_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_unsignedShort(soap, tag, id, &a->xsd__unsignedShort_::__item, "xsd:unsignedShort");
}

void *xsd__unsignedShort_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__unsignedShort_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedShort_ * SOAP_FMAC4 soap_in_xsd__unsignedShort_(struct soap *soap, const char *tag, xsd__unsignedShort_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedShort_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedShort_, sizeof(xsd__unsignedShort_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__unsignedShort_)
		return (xsd__unsignedShort_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_unsignedShort(soap, tag, &a->xsd__unsignedShort_::__item, "xsd:unsignedShort"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__unsignedShort_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedShort_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__unsignedShort_ *p;
	size_t k = sizeof(xsd__unsignedShort_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__unsignedShort_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__unsignedShort_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__unsignedShort_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__unsignedShort_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__unsignedShort_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__unsignedShort_(soap, tag ? tag : "xsd:unsignedShort", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedShort_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedShort_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedShort_ * SOAP_FMAC4 soap_get_xsd__unsignedShort_(struct soap *soap, xsd__unsignedShort_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__unsignedLong_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ULONG64(soap, &this->xsd__unsignedLong_::__item);
}

void xsd__unsignedLong_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__unsignedLong_::__item, SOAP_TYPE_ULONG64);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedLong_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong_(struct soap *soap, const char *tag, int id, const xsd__unsignedLong_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ULONG64(soap, tag, id, &a->xsd__unsignedLong_::__item, "xsd:unsignedLong");
}

void *xsd__unsignedLong_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__unsignedLong_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong_ * SOAP_FMAC4 soap_in_xsd__unsignedLong_(struct soap *soap, const char *tag, xsd__unsignedLong_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedLong_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedLong_, sizeof(xsd__unsignedLong_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__unsignedLong_)
		return (xsd__unsignedLong_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ULONG64(soap, tag, &a->xsd__unsignedLong_::__item, "xsd:unsignedLong"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__unsignedLong_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__unsignedLong_ *p;
	size_t k = sizeof(xsd__unsignedLong_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__unsignedLong_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__unsignedLong_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__unsignedLong_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__unsignedLong_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__unsignedLong_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__unsignedLong_(soap, tag ? tag : "xsd:unsignedLong", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedLong_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong_ * SOAP_FMAC4 soap_get_xsd__unsignedLong_(struct soap *soap, xsd__unsignedLong_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__unsignedInt_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_unsignedInt(soap, &this->xsd__unsignedInt_::__item);
}

void xsd__unsignedInt_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__unsignedInt_::__item, SOAP_TYPE_unsignedInt);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedInt_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedInt_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt_(struct soap *soap, const char *tag, int id, const xsd__unsignedInt_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_unsignedInt(soap, tag, id, &a->xsd__unsignedInt_::__item, "xsd:unsignedInt");
}

void *xsd__unsignedInt_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__unsignedInt_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt_ * SOAP_FMAC4 soap_in_xsd__unsignedInt_(struct soap *soap, const char *tag, xsd__unsignedInt_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedInt_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedInt_, sizeof(xsd__unsignedInt_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__unsignedInt_)
		return (xsd__unsignedInt_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_unsignedInt(soap, tag, &a->xsd__unsignedInt_::__item, "xsd:unsignedInt"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__unsignedInt_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__unsignedInt_ *p;
	size_t k = sizeof(xsd__unsignedInt_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__unsignedInt_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__unsignedInt_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__unsignedInt_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__unsignedInt_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__unsignedInt_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__unsignedInt_(soap, tag ? tag : "xsd:unsignedInt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedInt_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedInt_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt_ * SOAP_FMAC4 soap_get_xsd__unsignedInt_(struct soap *soap, xsd__unsignedInt_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__unsignedByte__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__unsignedByte(soap, &this->xsd__unsignedByte__::__item);
}

void xsd__unsignedByte__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedByte__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedByte__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte__(struct soap *soap, const char *tag, int id, const xsd__unsignedByte__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__unsignedByte(soap, tag, id, &a->xsd__unsignedByte__::__item, "xsd:unsignedByte");
}

void *xsd__unsignedByte__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__unsignedByte__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedByte__ * SOAP_FMAC4 soap_in_xsd__unsignedByte__(struct soap *soap, const char *tag, xsd__unsignedByte__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedByte__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedByte__, sizeof(xsd__unsignedByte__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__unsignedByte__)
		return (xsd__unsignedByte__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__unsignedByte(soap, tag, &a->xsd__unsignedByte__::__item, "xsd:unsignedByte"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__unsignedByte__ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedByte__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__unsignedByte__ *p;
	size_t k = sizeof(xsd__unsignedByte__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__unsignedByte__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__unsignedByte__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__unsignedByte__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__unsignedByte__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__unsignedByte__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__unsignedByte__(soap, tag ? tag : "xsd:unsignedByte", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedByte__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedByte__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedByte__ * SOAP_FMAC4 soap_get_xsd__unsignedByte__(struct soap *soap, xsd__unsignedByte__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__string_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->xsd__string_::__item);
}

void xsd__string_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__string_::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__string_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string_(struct soap *soap, const char *tag, int id, const xsd__string_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->xsd__string_::__item, "xsd:string");
}

void *xsd__string_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__string_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_in_xsd__string_(struct soap *soap, const char *tag, xsd__string_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string_, sizeof(xsd__string_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__string_)
		return (xsd__string_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_std__string(soap, tag, &a->xsd__string_::__item, "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 soap_instantiate_xsd__string_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__string_ *p;
	size_t k = sizeof(xsd__string_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__string_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__string_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__string_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__string_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__string_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__string_(soap, tag ? tag : "xsd:string", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_get_xsd__string_(struct soap *soap, xsd__string_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__short_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_short(soap, &this->xsd__short_::__item);
}

void xsd__short_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__short_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__short_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short_(struct soap *soap, const char *tag, int id, const xsd__short_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_short(soap, tag, id, &a->xsd__short_::__item, "xsd:short");
}

void *xsd__short_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__short_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__short_ * SOAP_FMAC4 soap_in_xsd__short_(struct soap *soap, const char *tag, xsd__short_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__short_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__short_, sizeof(xsd__short_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__short_)
		return (xsd__short_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_short(soap, tag, &a->xsd__short_::__item, "xsd:short"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__short_ * SOAP_FMAC2 soap_instantiate_xsd__short_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__short_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__short_ *p;
	size_t k = sizeof(xsd__short_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__short_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__short_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__short_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__short_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__short_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__short_(soap, tag ? tag : "xsd:short", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__short_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__short_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__short_ * SOAP_FMAC4 soap_get_xsd__short_(struct soap *soap, xsd__short_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__long_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_LONG64(soap, &this->xsd__long_::__item);
}

void xsd__long_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__long_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long_(struct soap *soap, const char *tag, int id, const xsd__long_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_LONG64(soap, tag, id, &a->xsd__long_::__item, "xsd:long");
}

void *xsd__long_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__long_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long_ * SOAP_FMAC4 soap_in_xsd__long_(struct soap *soap, const char *tag, xsd__long_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long_, sizeof(xsd__long_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__long_)
		return (xsd__long_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_LONG64(soap, tag, &a->xsd__long_::__item, "xsd:long"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__long_ * SOAP_FMAC2 soap_instantiate_xsd__long_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__long_ *p;
	size_t k = sizeof(xsd__long_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__long_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__long_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__long_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__long_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__long_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__long_(soap, tag ? tag : "xsd:long", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__long_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long_ * SOAP_FMAC4 soap_get_xsd__long_(struct soap *soap, xsd__long_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__int_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->xsd__int_::__item);
}

void xsd__int_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__int_::__item, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__int_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int_(struct soap *soap, const char *tag, int id, const xsd__int_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->xsd__int_::__item, "xsd:int");
}

void *xsd__int_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__int_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_in_xsd__int_(struct soap *soap, const char *tag, xsd__int_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int_, sizeof(xsd__int_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__int_)
		return (xsd__int_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_int(soap, tag, &a->xsd__int_::__item, "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 soap_instantiate_xsd__int_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__int_ *p;
	size_t k = sizeof(xsd__int_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__int_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__int_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__int_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__int_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__int_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__int_(soap, tag ? tag : "xsd:int", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_get_xsd__int_(struct soap *soap, xsd__int_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__float_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->xsd__float_::__item);
}

void xsd__float_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__float_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float_(struct soap *soap, const char *tag, int id, const xsd__float_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_float(soap, tag, id, &a->xsd__float_::__item, "xsd:float");
}

void *xsd__float_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__float_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_in_xsd__float_(struct soap *soap, const char *tag, xsd__float_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__float_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float_, sizeof(xsd__float_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__float_)
		return (xsd__float_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_float(soap, tag, &a->xsd__float_::__item, "xsd:float"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 soap_instantiate_xsd__float_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__float_ *p;
	size_t k = sizeof(xsd__float_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__float_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__float_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__float_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__float_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__float_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__float_(soap, tag ? tag : "xsd:float", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__float_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_get_xsd__float_(struct soap *soap, xsd__float_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__duration__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__duration(soap, &this->xsd__duration__::__item);
}

void xsd__duration__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__duration(soap, &this->xsd__duration__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__duration__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration__(struct soap *soap, const char *tag, int id, const xsd__duration__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__duration(soap, tag, id, &a->xsd__duration__::__item, "xsd:duration");
}

void *xsd__duration__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__duration__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_in_xsd__duration__(struct soap *soap, const char *tag, xsd__duration__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__duration__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration__, sizeof(xsd__duration__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__duration__)
		return (xsd__duration__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__duration(soap, tag, &a->xsd__duration__::__item, "xsd:duration"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 soap_instantiate_xsd__duration__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__duration__ *p;
	size_t k = sizeof(xsd__duration__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__duration__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__duration__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__duration__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__duration__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__duration__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__duration__(soap, tag ? tag : "xsd:duration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__duration__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_get_xsd__duration__(struct soap *soap, xsd__duration__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__duration, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__double_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_double(soap, &this->xsd__double_::__item);
}

void xsd__double_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__double_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double_(struct soap *soap, const char *tag, int id, const xsd__double_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_double(soap, tag, id, &a->xsd__double_::__item, "xsd:double");
}

void *xsd__double_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__double_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_in_xsd__double_(struct soap *soap, const char *tag, xsd__double_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double_, sizeof(xsd__double_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__double_)
		return (xsd__double_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_double(soap, tag, &a->xsd__double_::__item, "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 soap_instantiate_xsd__double_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__double_ *p;
	size_t k = sizeof(xsd__double_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__double_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__double_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__double_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__double_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__double_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__double_(soap, tag ? tag : "xsd:double", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__double_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_get_xsd__double_(struct soap *soap, xsd__double_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__decimal__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__decimal(soap, &this->xsd__decimal__::__item);
}

void xsd__decimal__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &this->xsd__decimal__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__decimal__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__decimal__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal__(struct soap *soap, const char *tag, int id, const xsd__decimal__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__decimal(soap, tag, id, &a->xsd__decimal__::__item, "xsd:decimal");
}

void *xsd__decimal__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__decimal__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal__ * SOAP_FMAC4 soap_in_xsd__decimal__(struct soap *soap, const char *tag, xsd__decimal__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__decimal__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__decimal__, sizeof(xsd__decimal__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__decimal__)
		return (xsd__decimal__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__decimal(soap, tag, &a->xsd__decimal__::__item, "xsd:decimal"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__decimal__ * SOAP_FMAC2 soap_instantiate_xsd__decimal__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__decimal__ *p;
	size_t k = sizeof(xsd__decimal__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__decimal__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__decimal__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__decimal__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__decimal__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__decimal__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__decimal__(soap, tag ? tag : "xsd:decimal", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__decimal__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__decimal__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal__ * SOAP_FMAC4 soap_get_xsd__decimal__(struct soap *soap, xsd__decimal__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__dateTime_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_dateTime(soap, &this->xsd__dateTime_::__item);
}

void xsd__dateTime_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__dateTime_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime_(struct soap *soap, const char *tag, int id, const xsd__dateTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_dateTime(soap, tag, id, &a->xsd__dateTime_::__item, "xsd:dateTime");
}

void *xsd__dateTime_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__dateTime_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_in_xsd__dateTime_(struct soap *soap, const char *tag, xsd__dateTime_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime_, sizeof(xsd__dateTime_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__dateTime_)
		return (xsd__dateTime_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_dateTime(soap, tag, &a->xsd__dateTime_::__item, "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 soap_instantiate_xsd__dateTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__dateTime_ *p;
	size_t k = sizeof(xsd__dateTime_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__dateTime_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__dateTime_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__dateTime_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__dateTime_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__dateTime_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__dateTime_(soap, tag ? tag : "xsd:dateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_get_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__byte__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__byte(soap, &this->xsd__byte__::__item);
}

void xsd__byte__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__byte__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__byte__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte__(struct soap *soap, const char *tag, int id, const xsd__byte__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__byte(soap, tag, id, &a->xsd__byte__::__item, "xsd:byte");
}

void *xsd__byte__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__byte__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__byte__ * SOAP_FMAC4 soap_in_xsd__byte__(struct soap *soap, const char *tag, xsd__byte__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__byte__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__byte__, sizeof(xsd__byte__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__byte__)
		return (xsd__byte__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__byte(soap, tag, &a->xsd__byte__::__item, "xsd:byte"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__byte__ * SOAP_FMAC2 soap_instantiate_xsd__byte__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__byte__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__byte__ *p;
	size_t k = sizeof(xsd__byte__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__byte__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__byte__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__byte__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__byte__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__byte__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__byte__(soap, tag ? tag : "xsd:byte", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__byte__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__byte__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__byte__ * SOAP_FMAC4 soap_get_xsd__byte__(struct soap *soap, xsd__byte__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__boolean_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->xsd__boolean_::__item);
}

void xsd__boolean_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__boolean_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const xsd__boolean_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_bool(soap, tag, id, &a->xsd__boolean_::__item, "xsd:boolean");
}

void *xsd__boolean_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__boolean_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, xsd__boolean_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(xsd__boolean_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__boolean_)
		return (xsd__boolean_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_bool(soap, tag, &a->xsd__boolean_::__item, "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 soap_instantiate_xsd__boolean_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__boolean_ *p;
	size_t k = sizeof(xsd__boolean_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__boolean_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__boolean_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__boolean_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__boolean_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__boolean_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__boolean_(soap, tag ? tag : "xsd:boolean", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, xsd__boolean_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__base64Binary__::__item.xsd__base64Binary::soap_default(soap);
}

void xsd__base64Binary__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__base64Binary__::__item, SOAP_TYPE_xsd__base64Binary);
	this->xsd__base64Binary__::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__base64Binary__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary__(struct soap *soap, const char *tag, int id, const xsd__base64Binary__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->xsd__base64Binary__::__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_in_xsd__base64Binary__(struct soap *soap, const char *tag, xsd__base64Binary__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary__, sizeof(xsd__base64Binary__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__base64Binary__)
		return (xsd__base64Binary__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!(a->xsd__base64Binary__::__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary__ *p;
	size_t k = sizeof(xsd__base64Binary__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary__(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_get_xsd__base64Binary__(struct soap *soap, xsd__base64Binary__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyURI__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI__::__item);
}

void xsd__anyURI__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__anyURI__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI__(struct soap *soap, const char *tag, int id, const xsd__anyURI__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->xsd__anyURI__::__item, "xsd:anyURI");
}

void *xsd__anyURI__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyURI__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_in_xsd__anyURI__(struct soap *soap, const char *tag, xsd__anyURI__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI__, sizeof(xsd__anyURI__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyURI__)
		return (xsd__anyURI__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__anyURI(soap, tag, &a->xsd__anyURI__::__item, "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 soap_instantiate_xsd__anyURI__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anyURI__ *p;
	size_t k = sizeof(xsd__anyURI__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyURI__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyURI__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyURI__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyURI__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyURI__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyURI__(soap, tag ? tag : "xsd:anyURI", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyURI__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_get_xsd__anyURI__(struct soap *soap, xsd__anyURI__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__QName__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__QName(soap, &this->xsd__QName__::__item);
}

void xsd__QName__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__QName(soap, &this->xsd__QName__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__QName__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName__(struct soap *soap, const char *tag, int id, const xsd__QName__ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "xsd:QName");
}

void *xsd__QName__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__QName__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_in_xsd__QName__(struct soap *soap, const char *tag, xsd__QName__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName__, sizeof(xsd__QName__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__QName__)
		return (xsd__QName__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__QName(soap, tag, &a->xsd__QName__::__item, "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 soap_instantiate_xsd__QName__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__QName__ *p;
	size_t k = sizeof(xsd__QName__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__QName__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__QName__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__QName__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__QName__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__QName__(soap, tag ? tag : "xsd:QName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__QName__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_get_xsd__QName__(struct soap *soap, xsd__QName__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__IDREF__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__IDREF(soap, &this->xsd__IDREF__::__item);
}

void xsd__IDREF__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__IDREF(soap, &this->xsd__IDREF__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__IDREF__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__IDREF__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF__(struct soap *soap, const char *tag, int id, const xsd__IDREF__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__IDREF(soap, tag, id, &a->xsd__IDREF__::__item, "xsd:IDREF");
}

void *xsd__IDREF__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__IDREF__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__IDREF__ * SOAP_FMAC4 soap_in_xsd__IDREF__(struct soap *soap, const char *tag, xsd__IDREF__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__IDREF__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__IDREF__, sizeof(xsd__IDREF__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__IDREF__)
		return (xsd__IDREF__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__IDREF(soap, tag, &a->xsd__IDREF__::__item, "xsd:IDREF"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__IDREF__ * SOAP_FMAC2 soap_instantiate_xsd__IDREF__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__IDREF__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__IDREF__ *p;
	size_t k = sizeof(xsd__IDREF__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__IDREF__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__IDREF__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__IDREF__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__IDREF__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__IDREF__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__IDREF__(soap, tag ? tag : "xsd:IDREF", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__IDREF__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__IDREF__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__IDREF__ * SOAP_FMAC4 soap_get_xsd__IDREF__(struct soap *soap, xsd__IDREF__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__IDREF(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__IDREF), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__IDREF(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__IDREF, SOAP_TYPE_xsd__IDREF, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__IDREF(soap, tag ? tag : "xsd:IDREF", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__ID__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__ID(soap, &this->xsd__ID__::__item);
}

void xsd__ID__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__ID(soap, &this->xsd__ID__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__ID__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__ID__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID__(struct soap *soap, const char *tag, int id, const xsd__ID__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__ID(soap, tag, id, &a->xsd__ID__::__item, "xsd:ID");
}

void *xsd__ID__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__ID__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__ID__ * SOAP_FMAC4 soap_in_xsd__ID__(struct soap *soap, const char *tag, xsd__ID__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__ID__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__ID__, sizeof(xsd__ID__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__ID__)
		return (xsd__ID__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__ID(soap, tag, &a->xsd__ID__::__item, "xsd:ID"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__ID__ * SOAP_FMAC2 soap_instantiate_xsd__ID__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ID__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__ID__ *p;
	size_t k = sizeof(xsd__ID__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__ID__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__ID__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__ID__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__ID__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__ID__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__ID__(soap, tag ? tag : "xsd:ID", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__ID__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__ID__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__ID__ * SOAP_FMAC4 soap_get_xsd__ID__(struct soap *soap, xsd__ID__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__ID, SOAP_TYPE_xsd__ID, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__ID(soap, tag ? tag : "xsd:ID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyType)
		return (xsd__anyType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "xsd:ID"))
		return soap_instantiate_xsd__ID__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:IDREF"))
		return soap_instantiate_xsd__IDREF__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:QName"))
		return soap_instantiate_xsd__QName__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:anyURI"))
		return soap_instantiate_xsd__anyURI__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:base64Binary"))
		return soap_instantiate_xsd__base64Binary__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:boolean"))
		return soap_instantiate_xsd__boolean_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:byte"))
		return soap_instantiate_xsd__byte__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:dateTime"))
		return soap_instantiate_xsd__dateTime_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:decimal"))
		return soap_instantiate_xsd__decimal__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:double"))
		return soap_instantiate_xsd__double_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:duration"))
		return soap_instantiate_xsd__duration__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:float"))
		return soap_instantiate_xsd__float_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:int"))
		return soap_instantiate_xsd__int_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:long"))
		return soap_instantiate_xsd__long_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:short"))
		return soap_instantiate_xsd__short_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:string"))
		return soap_instantiate_xsd__string_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
		return soap_instantiate_xsd__unsignedByte__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
		return soap_instantiate_xsd__unsignedInt_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
		return soap_instantiate_xsd__unsignedLong_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
		return soap_instantiate_xsd__unsignedShort_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns4:char"))
		return soap_instantiate_ns4__char__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns4:duration"))
		return soap_instantiate_ns4__duration__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns4:guid"))
		return soap_instantiate_ns4__guid__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns5:SignRequest"))
		return soap_instantiate_ns5__SignRequest(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns5:SignStatus"))
		return soap_instantiate_ns5__SignStatus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns5:SignResponse"))
		return soap_instantiate_ns5__SignResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns5:ArrayOfHashStructure"))
		return soap_instantiate_ns5__ArrayOfHashStructure(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns5:HashStructure"))
		return soap_instantiate_ns5__HashStructure(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns5:MultipleSignRequest"))
		return soap_instantiate_ns5__MultipleSignRequest(soap, n, NULL, NULL, size);
	xsd__anyType *p;
	size_t k = sizeof(xsd__anyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->wsc__SecurityContextToken = NULL;
	a->ds__Signature = NULL;
	a->saml1__Assertion = NULL;
	a->saml2__Assertion = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", soap_string2s(soap, a->SOAP_ENV__actor), 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", soap_string2s(soap, a->SOAP_ENV__role), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml1__Assertion = 1;
	size_t soap_flag_saml2__Assertion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Security*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 1, 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 1, 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Security(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Security *p;
	size_t k = sizeof(struct _wsse__Security);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Security, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Security);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Security, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Security location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Security(soap, tag ? tag : "wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedAttribute(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedAttribute(soap, tag ? tag : "saml2:EncryptedAttribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Attribute(struct soap *soap, const struct saml2__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Attribute(soap, tag ? tag : "saml2:Attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AttributeStatement(struct soap *soap, const struct saml2__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AttributeStatement(soap, tag ? tag : "saml2:AttributeStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Evidence(struct soap *soap, const struct saml2__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Evidence(soap, tag ? tag : "saml2:Evidence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Action(struct soap *soap, const struct saml2__ActionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Action(soap, tag ? tag : "saml2:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthzDecisionStatement(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthzDecisionStatement(soap, tag ? tag : "saml2:AuthzDecisionStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContext(struct soap *soap, const struct saml2__AuthnContextType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContext(soap, tag ? tag : "saml2:AuthnContext", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectLocality(struct soap *soap, const struct saml2__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectLocality(soap, tag ? tag : "saml2:SubjectLocality", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnStatement(struct soap *soap, const struct saml2__AuthnStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnStatement(soap, tag ? tag : "saml2:AuthnStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Statement(struct soap *soap, const struct saml2__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Statement(soap, tag ? tag : "saml2:Statement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedAssertion(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedAssertion(soap, tag ? tag : "saml2:EncryptedAssertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Advice(struct soap *soap, const struct saml2__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Advice(soap, tag ? tag : "saml2:Advice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__ProxyRestriction(struct soap *soap, const struct saml2__ProxyRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__ProxyRestriction(soap, tag ? tag : "saml2:ProxyRestriction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__OneTimeUse(struct soap *soap, const struct saml2__OneTimeUseType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__OneTimeUse(soap, tag ? tag : "saml2:OneTimeUse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AudienceRestriction(struct soap *soap, const struct saml2__AudienceRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AudienceRestriction(soap, tag ? tag : "saml2:AudienceRestriction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Condition(struct soap *soap, const struct saml2__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Condition(soap, tag ? tag : "saml2:Condition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Conditions(struct soap *soap, const struct saml2__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Conditions(soap, tag ? tag : "saml2:Conditions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectConfirmationData(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectConfirmationData(soap, tag ? tag : "saml2:SubjectConfirmationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectConfirmation(struct soap *soap, const struct saml2__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectConfirmation(soap, tag ? tag : "saml2:SubjectConfirmation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Subject(struct soap *soap, const struct saml2__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Subject(soap, tag ? tag : "saml2:Subject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Assertion(struct soap *soap, const struct saml2__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Assertion(soap, tag ? tag : "saml2:Assertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Issuer(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Issuer(soap, tag ? tag : "saml2:Issuer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedID(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedID(soap, tag ? tag : "saml2:EncryptedID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__NameID(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__NameID(soap, tag ? tag : "saml2:NameID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__BaseID(struct soap *soap, const struct saml2__BaseIDAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__BaseID(soap, tag ? tag : "saml2:BaseID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Attribute = NULL;
	a->saml2__EncryptedAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__AttributeType(soap, &a->saml2__Attribute);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAttribute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__AttributeType(soap, "saml2:Attribute", -1, &a->saml2__Attribute, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", -1, &a->saml2__EncryptedAttribute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_in___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, struct __saml2__union_AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml2__Attribute = 1;
	size_t soap_flag_saml2__EncryptedAttribute = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AttributeStatementType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AttributeStatementType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Attribute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AttributeType(soap, "saml2:Attribute", &a->saml2__Attribute, "saml2:AttributeType"))
				{	soap_flag_saml2__Attribute--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAttribute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", &a->saml2__EncryptedAttribute, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAttribute--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_AttributeStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_AttributeStatementType *p;
	size_t k = sizeof(struct __saml2__union_AttributeStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_AttributeStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_AttributeStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_AttributeStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_AttributeStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AttributeStatementType(soap, tag ? tag : "-saml2:union-AttributeStatementType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_get___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_in___saml2__union_EvidenceType(struct soap *soap, const char *tag, struct __saml2__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_EvidenceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_EvidenceType *p;
	size_t k = sizeof(struct __saml2__union_EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_EvidenceType(soap, tag ? tag : "-saml2:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_get___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_in___saml2__union_AdviceType(struct soap *soap, const char *tag, struct __saml2__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AdviceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_AdviceType *p;
	size_t k = sizeof(struct __saml2__union_AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AdviceType(soap, tag ? tag : "-saml2:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_get___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Condition = NULL;
	a->saml2__AudienceRestriction = NULL;
	a->saml2__OneTimeUse = NULL;
	a->saml2__ProxyRestriction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__ConditionAbstractType(soap, &a->saml2__Condition);
	soap_serialize_PointerTosaml2__AudienceRestrictionType(soap, &a->saml2__AudienceRestriction);
	soap_serialize_PointerTosaml2__OneTimeUseType(soap, &a->saml2__OneTimeUse);
	soap_serialize_PointerTosaml2__ProxyRestrictionType(soap, &a->saml2__ProxyRestriction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml2__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", -1, &a->saml2__Condition, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", -1, &a->saml2__AudienceRestriction, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", -1, &a->saml2__OneTimeUse, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", -1, &a->saml2__ProxyRestriction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_in___saml2__union_ConditionsType(struct soap *soap, const char *tag, struct __saml2__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml2__Condition = 1;
	size_t soap_flag_saml2__AudienceRestriction = 1;
	size_t soap_flag_saml2__OneTimeUse = 1;
	size_t soap_flag_saml2__ProxyRestriction = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_ConditionsType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Condition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", &a->saml2__Condition, "saml2:ConditionAbstractType"))
				{	soap_flag_saml2__Condition--;
					continue;
				}
			}
			if (soap_flag_saml2__AudienceRestriction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", &a->saml2__AudienceRestriction, "saml2:AudienceRestrictionType"))
				{	soap_flag_saml2__AudienceRestriction--;
					continue;
				}
			}
			if (soap_flag_saml2__OneTimeUse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", &a->saml2__OneTimeUse, "saml2:OneTimeUseType"))
				{	soap_flag_saml2__OneTimeUse--;
					continue;
				}
			}
			if (soap_flag_saml2__ProxyRestriction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", &a->saml2__ProxyRestriction, "saml2:ProxyRestrictionType"))
				{	soap_flag_saml2__ProxyRestriction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_ConditionsType *p;
	size_t k = sizeof(struct __saml2__union_ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_ConditionsType(soap, tag ? tag : "-saml2:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_get___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Statement = NULL;
	a->saml2__AuthnStatement = NULL;
	a->saml2__AuthzDecisionStatement = NULL;
	a->saml2__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__StatementAbstractType(soap, &a->saml2__Statement);
	soap_serialize_PointerTosaml2__AuthnStatementType(soap, &a->saml2__AuthnStatement);
	soap_serialize_PointerTosaml2__AuthzDecisionStatementType(soap, &a->saml2__AuthzDecisionStatement);
	soap_serialize_PointerTosaml2__AttributeStatementType(soap, &a->saml2__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", -1, &a->saml2__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", -1, &a->saml2__AuthnStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", -1, &a->saml2__AuthzDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", -1, &a->saml2__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_in___saml2__union_AssertionType(struct soap *soap, const char *tag, struct __saml2__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Statement = 1;
	size_t soap_flag_saml2__AuthnStatement = 1;
	size_t soap_flag_saml2__AuthzDecisionStatement = 1;
	size_t soap_flag_saml2__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AssertionType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Statement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", &a->saml2__Statement, "saml2:StatementAbstractType"))
				{	soap_flag_saml2__Statement--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", &a->saml2__AuthnStatement, "saml2:AuthnStatementType"))
				{	soap_flag_saml2__AuthnStatement--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthzDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", &a->saml2__AuthzDecisionStatement, "saml2:AuthzDecisionStatementType"))
				{	soap_flag_saml2__AuthzDecisionStatement--;
					continue;
				}
			}
			if (soap_flag_saml2__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", &a->saml2__AttributeStatement, "saml2:AttributeStatementType"))
				{	soap_flag_saml2__AttributeStatement--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml2__union_AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml2__union_AssertionType *p;
	size_t k = sizeof(struct __saml2__union_AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml2__union_AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml2__union_AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml2__union_AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml2__union_AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AssertionType(soap, tag ? tag : "-saml2:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_get___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAttributeValue = 0;
	a->saml2__AttributeValue = NULL;
	soap_default_string(soap, &a->Name);
	soap_default_string(soap, &a->NameFormat);
	soap_default_string(soap, &a->FriendlyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeType *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	if (a->NameFormat)
		soap_set_attr(soap, "NameFormat", soap_string2s(soap, a->NameFormat), 1);
	if (a->FriendlyName)
		soap_set_attr(soap, "FriendlyName", soap_string2s(soap, a->FriendlyName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeType), type))
		return soap->error;
	if (a->saml2__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			if (soap_outliteral(soap, "saml2:AttributeValue", (char*const*)(a->saml2__AttributeValue + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_in_saml2__AttributeType(struct soap *soap, const char *tag, struct saml2__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AttributeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameFormat", 1, 0), &a->NameFormat))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "FriendlyName", 1, 0), &a->FriendlyName))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AttributeValue", 1, NULL))
			{	if (a->saml2__AttributeValue == NULL)
				{	if (soap_blist_saml2__AttributeValue == NULL)
						soap_blist_saml2__AttributeValue = soap_alloc_block(soap);
					a->saml2__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml2__AttributeValue, sizeof(char *));
					if (a->saml2__AttributeValue == NULL)
						return NULL;
					*a->saml2__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml2:AttributeValue", (char**)a->saml2__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml2__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AttributeValue)
			soap_pop_block(soap, soap_blist_saml2__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml2__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml2__AttributeValue, NULL, 1);
		}
		else
		{	a->saml2__AttributeValue = NULL;
			if (soap_blist_saml2__AttributeValue)
				soap_end_block(soap, soap_blist_saml2__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeType, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AttributeType *p;
	size_t k = sizeof(struct saml2__AttributeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AttributeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AttributeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AttributeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AttributeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeType(soap, tag ? tag : "saml2:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_get_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AttributeStatementType = 0;
	a->__union_AttributeStatementType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
		{
			soap_serialize___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeStatementType), type))
		return soap->error;
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
			if (soap_out___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", -1, a->__union_AttributeStatementType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_in_saml2__AttributeStatementType(struct soap *soap, const char *tag, struct saml2__AttributeStatementType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AttributeStatementType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AttributeStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeStatementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AttributeStatementType == NULL)
				{	if (soap_blist___union_AttributeStatementType == NULL)
						soap_blist___union_AttributeStatementType = soap_alloc_block(soap);
					a->__union_AttributeStatementType = soap_block<struct __saml2__union_AttributeStatementType>::push(soap, soap_blist___union_AttributeStatementType);
					if (a->__union_AttributeStatementType == NULL)
						return NULL;
					soap_default___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType);
				}
				if (soap_in___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", a->__union_AttributeStatementType, "-saml2:union-AttributeStatementType"))
				{	a->__size_AttributeStatementType++;
					a->__union_AttributeStatementType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AttributeStatementType)
			soap_block<struct __saml2__union_AttributeStatementType>::pop(soap, soap_blist___union_AttributeStatementType);
		if (a->__size_AttributeStatementType)
		{	a->__union_AttributeStatementType = soap_new___saml2__union_AttributeStatementType(soap, a->__size_AttributeStatementType);
			if (!a->__union_AttributeStatementType)
				return NULL;
			soap_block<struct __saml2__union_AttributeStatementType>::save(soap, soap_blist___union_AttributeStatementType, a->__union_AttributeStatementType);
		}
		else
		{	a->__union_AttributeStatementType = NULL;
			if (soap_blist___union_AttributeStatementType)
				soap_block<struct __saml2__union_AttributeStatementType>::end(soap, soap_blist___union_AttributeStatementType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeStatementType, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AttributeStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AttributeStatementType *p;
	size_t k = sizeof(struct saml2__AttributeStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AttributeStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AttributeStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AttributeStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AttributeStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeStatementType(soap, tag ? tag : "saml2:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_get_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml2__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml2__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml2__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_in_saml2__EvidenceType(struct soap *soap, const char *tag, struct saml2__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__EvidenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EvidenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = soap_block<struct __saml2__union_EvidenceType>::push(soap, soap_blist___union_EvidenceType);
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml2__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml2__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml2:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_block<struct __saml2__union_EvidenceType>::pop(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = soap_new___saml2__union_EvidenceType(soap, a->__size_EvidenceType);
			if (!a->__union_EvidenceType)
				return NULL;
			soap_block<struct __saml2__union_EvidenceType>::save(soap, soap_blist___union_EvidenceType, a->__union_EvidenceType);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_block<struct __saml2__union_EvidenceType>::end(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EvidenceType, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__EvidenceType *p;
	size_t k = sizeof(struct saml2__EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EvidenceType(soap, tag ? tag : "saml2:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_get_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ActionType(struct soap *soap, struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ActionType(struct soap *soap, const char *tag, int id, const struct saml2__ActionType *a, const char *type)
{
	soap_set_attr(soap, "Namespace", a->Namespace ? soap_string2s(soap, a->Namespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_in_saml2__ActionType(struct soap *soap, const char *tag, struct saml2__ActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml2__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1, 1), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ActionType *p;
	size_t k = sizeof(struct saml2__ActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ActionType(soap, tag ? tag : "saml2:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_get_saml2__ActionType(struct soap *soap, struct saml2__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->saml2__Action = NULL;
	a->saml2__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml2__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml2__Action + i, SOAP_TYPE_saml2__ActionType);
			soap_serialize_saml2__ActionType(soap, a->saml2__Action + i);
		}
	}
	soap_serialize_PointerTosaml2__EvidenceType(soap, &a->saml2__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	soap_set_attr(soap, "Resource", a->Resource ? soap_string2s(soap, a->Resource) : "", 1);
	soap_set_attr(soap, "Decision", soap_saml2__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType), type))
		return soap->error;
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml2__ActionType(soap, "saml2:Action", -1, a->saml2__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", -1, &a->saml2__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_in_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Action = NULL;
	size_t soap_flag_saml2__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthzDecisionStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthzDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1, 1), &a->Resource))
		return NULL;
	if (soap_s2saml2__DecisionType(soap, soap_attr_value(soap, "Decision", 5, 1), &a->Decision))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Action", 1, NULL))
			{	if (a->saml2__Action == NULL)
				{	if (soap_blist_saml2__Action == NULL)
						soap_blist_saml2__Action = soap_alloc_block(soap);
					a->saml2__Action = soap_block<struct saml2__ActionType>::push(soap, soap_blist_saml2__Action);
					if (a->saml2__Action == NULL)
						return NULL;
					soap_default_saml2__ActionType(soap, a->saml2__Action);
				}
				soap_revert(soap);
				if (soap_in_saml2__ActionType(soap, "saml2:Action", a->saml2__Action, "saml2:ActionType"))
				{	a->__sizeAction++;
					a->saml2__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml2__Evidence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", &a->saml2__Evidence, "saml2:EvidenceType"))
				{	soap_flag_saml2__Evidence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Action)
			soap_block<struct saml2__ActionType>::pop(soap, soap_blist_saml2__Action);
		if (a->__sizeAction)
		{	a->saml2__Action = soap_new_saml2__ActionType(soap, a->__sizeAction);
			if (!a->saml2__Action)
				return NULL;
			soap_block<struct saml2__ActionType>::save(soap, soap_blist_saml2__Action, a->saml2__Action);
		}
		else
		{	a->saml2__Action = NULL;
			if (soap_blist_saml2__Action)
				soap_block<struct saml2__ActionType>::end(soap, soap_blist_saml2__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthzDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthzDecisionStatementType, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AuthzDecisionStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AuthzDecisionStatementType *p;
	size_t k = sizeof(struct saml2__AuthzDecisionStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AuthzDecisionStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AuthzDecisionStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AuthzDecisionStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AuthzDecisionStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthzDecisionStatementType(soap, tag ? tag : "saml2:AuthzDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_get_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthzDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AuthnContextClassRef);
	a->saml2__AuthnContextDecl = NULL;
	soap_default_string(soap, &a->saml2__AuthnContextDeclRef);
	a->saml2__AuthnContextDecl_ = NULL;
	soap_default_string(soap, &a->saml2__AuthnContextDeclRef_);
	a->__sizeAuthenticatingAuthority = 0;
	a->saml2__AuthenticatingAuthority = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextClassRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextDeclRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextDeclRef_);
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__AuthenticatingAuthority + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnContextType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnContextType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnContextType), type))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextClassRef", -1, (char*const*)&a->saml2__AuthnContextClassRef, ""))
		return soap->error;
	if (soap_outliteral(soap, "saml2:AuthnContextDecl", (char*const*)&a->saml2__AuthnContextDecl, NULL))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextDeclRef", -1, (char*const*)&a->saml2__AuthnContextDeclRef, ""))
		return soap->error;
	if (soap_outliteral(soap, "saml2:AuthnContextDecl", (char*const*)&a->saml2__AuthnContextDecl_, NULL))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextDeclRef", -1, (char*const*)&a->saml2__AuthnContextDeclRef_, ""))
		return soap->error;
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
			if (soap_out_string(soap, "saml2:AuthenticatingAuthority", -1, (char*const*)(a->saml2__AuthenticatingAuthority + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_in_saml2__AuthnContextType(struct soap *soap, const char *tag, struct saml2__AuthnContextType *a, const char *type)
{
	size_t soap_flag_saml2__AuthnContextClassRef = 1;
	size_t soap_flag_saml2__AuthnContextDecl = 1;
	size_t soap_flag_saml2__AuthnContextDeclRef = 1;
	size_t soap_flag_saml2__AuthnContextDecl_ = 1;
	size_t soap_flag_saml2__AuthnContextDeclRef_ = 1;
	struct soap_blist *soap_blist_saml2__AuthenticatingAuthority = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthnContextType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnContextType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AuthnContextClassRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextClassRef", (char**)&a->saml2__AuthnContextClassRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextClassRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDecl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml2:AuthnContextDecl", (char**)&a->saml2__AuthnContextDecl))
				{	soap_flag_saml2__AuthnContextDecl--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDeclRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextDeclRef", (char**)&a->saml2__AuthnContextDeclRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextDeclRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDecl_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml2:AuthnContextDecl", (char**)&a->saml2__AuthnContextDecl_))
				{	soap_flag_saml2__AuthnContextDecl_--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDeclRef_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextDeclRef", (char**)&a->saml2__AuthnContextDeclRef_, "xsd:string"))
				{	soap_flag_saml2__AuthnContextDeclRef_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AuthenticatingAuthority", 1, NULL))
			{	if (a->saml2__AuthenticatingAuthority == NULL)
				{	if (soap_blist_saml2__AuthenticatingAuthority == NULL)
						soap_blist_saml2__AuthenticatingAuthority = soap_alloc_block(soap);
					a->saml2__AuthenticatingAuthority = (char **)soap_push_block_max(soap, soap_blist_saml2__AuthenticatingAuthority, sizeof(char *));
					if (a->saml2__AuthenticatingAuthority == NULL)
						return NULL;
					*a->saml2__AuthenticatingAuthority = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:AuthenticatingAuthority", (char**)a->saml2__AuthenticatingAuthority, "xsd:string"))
				{	a->__sizeAuthenticatingAuthority++;
					a->saml2__AuthenticatingAuthority = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AuthenticatingAuthority)
			soap_pop_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		if (a->__sizeAuthenticatingAuthority)
		{	a->saml2__AuthenticatingAuthority = (char **)soap_save_block(soap, soap_blist_saml2__AuthenticatingAuthority, NULL, 1);
		}
		else
		{	a->saml2__AuthenticatingAuthority = NULL;
			if (soap_blist_saml2__AuthenticatingAuthority)
				soap_end_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnContextType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnContextType, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AuthnContextType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AuthnContextType *p;
	size_t k = sizeof(struct saml2__AuthnContextType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AuthnContextType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AuthnContextType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AuthnContextType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AuthnContextType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnContextType(soap, tag ? tag : "saml2:AuthnContextType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_get_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnContextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	soap_default_string(soap, &a->DNSName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectLocalityType *a, const char *type)
{
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	if (a->DNSName)
		soap_set_attr(soap, "DNSName", soap_string2s(soap, a->DNSName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_in_saml2__SubjectLocalityType(struct soap *soap, const char *tag, struct saml2__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectLocalityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 1, 0), &a->Address))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSName", 1, 0), &a->DNSName))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectLocalityType, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectLocalityType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectLocalityType *p;
	size_t k = sizeof(struct saml2__SubjectLocalityType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectLocalityType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectLocalityType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectLocalityType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectLocalityType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectLocalityType(soap, tag ? tag : "saml2:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_get_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__SubjectLocality = NULL;
	a->saml2__AuthnContext = NULL;
	soap_default_xsd__dateTime(soap, &a->AuthnInstant);
	soap_default_string(soap, &a->SessionIndex);
	a->SessionNotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__SubjectLocalityType(soap, &a->saml2__SubjectLocality);
	soap_serialize_PointerTosaml2__AuthnContextType(soap, &a->saml2__AuthnContext);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnStatementType *a, const char *type)
{
	soap_set_attr(soap, "AuthnInstant", soap_xsd__dateTime2s(soap, a->AuthnInstant), 1);
	if (a->SessionIndex)
		soap_set_attr(soap, "SessionIndex", soap_string2s(soap, a->SessionIndex), 1);
	if (a->SessionNotOnOrAfter)
	{	soap_set_attr(soap, "SessionNotOnOrAfter", soap_xsd__dateTime2s(soap, *a->SessionNotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnStatementType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", -1, &a->saml2__SubjectLocality, ""))
		return soap->error;
	if (!a->saml2__AuthnContext)
	{	if (soap_element_empty(soap, "saml2:AuthnContext"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", -1, &a->saml2__AuthnContext, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_in_saml2__AuthnStatementType(struct soap *soap, const char *tag, struct saml2__AuthnStatementType *a, const char *type)
{
	size_t soap_flag_saml2__SubjectLocality = 1;
	size_t soap_flag_saml2__AuthnContext = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthnStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnStatementType(soap, a);
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "AuthnInstant", 5, 1), &a->AuthnInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SessionIndex", 1, 0), &a->SessionIndex))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "SessionNotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->SessionNotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__dateTime(soap, t, a->SessionNotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", &a->saml2__SubjectLocality, "saml2:SubjectLocalityType"))
				{	soap_flag_saml2__SubjectLocality--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContext && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", &a->saml2__AuthnContext, "saml2:AuthnContextType"))
				{	soap_flag_saml2__AuthnContext--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__AuthnContext))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthnStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnStatementType, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AuthnStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AuthnStatementType *p;
	size_t k = sizeof(struct saml2__AuthnStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AuthnStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AuthnStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AuthnStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AuthnStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnStatementType(soap, tag ? tag : "saml2:AuthnStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_get_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_in_saml2__StatementAbstractType(struct soap *soap, const char *tag, struct saml2__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__StatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__StatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__StatementAbstractType, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__StatementAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__StatementAbstractType *p;
	size_t k = sizeof(struct saml2__StatementAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__StatementAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__StatementAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__StatementAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__StatementAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__StatementAbstractType(soap, tag ? tag : "saml2:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_get_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml2__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AdviceType(struct soap *soap, const char *tag, int id, const struct saml2__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml2__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_in_saml2__AdviceType(struct soap *soap, const char *tag, struct saml2__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AdviceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AdviceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = soap_block<struct __saml2__union_AdviceType>::push(soap, soap_blist___union_AdviceType);
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml2__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml2__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml2:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_block<struct __saml2__union_AdviceType>::pop(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = soap_new___saml2__union_AdviceType(soap, a->__size_AdviceType);
			if (!a->__union_AdviceType)
				return NULL;
			soap_block<struct __saml2__union_AdviceType>::save(soap, soap_blist___union_AdviceType, a->__union_AdviceType);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_block<struct __saml2__union_AdviceType>::end(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AdviceType, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AdviceType *p;
	size_t k = sizeof(struct saml2__AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AdviceType(soap, tag ? tag : "saml2:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_get_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
	soap_default_string(soap, &a->Count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__ProxyRestrictionType *a, const char *type)
{
	if (a->Count)
		soap_set_attr(soap, "Count", soap_string2s(soap, a->Count), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ProxyRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_in_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, struct saml2__ProxyRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ProxyRestrictionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ProxyRestrictionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Count", 1, 0), &a->Count))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ProxyRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ProxyRestrictionType, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ProxyRestrictionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ProxyRestrictionType *p;
	size_t k = sizeof(struct saml2__ProxyRestrictionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ProxyRestrictionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ProxyRestrictionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ProxyRestrictionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ProxyRestrictionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ProxyRestrictionType(soap, tag ? tag : "saml2:ProxyRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_get_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ProxyRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__OneTimeUseType(struct soap *soap, const char *tag, int id, const struct saml2__OneTimeUseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__OneTimeUseType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_in_saml2__OneTimeUseType(struct soap *soap, const char *tag, struct saml2__OneTimeUseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__OneTimeUseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__OneTimeUseType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__OneTimeUseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__OneTimeUseType, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__OneTimeUseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__OneTimeUseType *p;
	size_t k = sizeof(struct saml2__OneTimeUseType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__OneTimeUseType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__OneTimeUseType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__OneTimeUseType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__OneTimeUseType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__OneTimeUseType(soap, tag ? tag : "saml2:OneTimeUseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_get_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__OneTimeUseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__AudienceRestrictionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AudienceRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_in_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, struct saml2__AudienceRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AudienceRestrictionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AudienceRestrictionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AudienceRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AudienceRestrictionType, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AudienceRestrictionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AudienceRestrictionType *p;
	size_t k = sizeof(struct saml2__AudienceRestrictionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AudienceRestrictionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AudienceRestrictionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AudienceRestrictionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AudienceRestrictionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AudienceRestrictionType(soap, tag ? tag : "saml2:AudienceRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_get_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AudienceRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_in_saml2__ConditionAbstractType(struct soap *soap, const char *tag, struct saml2__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ConditionAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionAbstractType, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ConditionAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ConditionAbstractType *p;
	size_t k = sizeof(struct saml2__ConditionAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ConditionAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ConditionAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ConditionAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ConditionAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionAbstractType(soap, tag ? tag : "saml2:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_get_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml2__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_xsd__dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_xsd__dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml2__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_in_saml2__ConditionsType(struct soap *soap, const char *tag, struct saml2__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ConditionsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionsType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = soap_block<struct __saml2__union_ConditionsType>::push(soap, soap_blist___union_ConditionsType);
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml2__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml2__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml2:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_block<struct __saml2__union_ConditionsType>::pop(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = soap_new___saml2__union_ConditionsType(soap, a->__size_ConditionsType);
			if (!a->__union_ConditionsType)
				return NULL;
			soap_block<struct __saml2__union_ConditionsType>::save(soap, soap_blist___union_ConditionsType, a->__union_ConditionsType);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_block<struct __saml2__union_ConditionsType>::end(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionsType, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__ConditionsType *p;
	size_t k = sizeof(struct saml2__ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionsType(soap, tag ? tag : "saml2:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_get_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeds__KeyInfo = 0;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
		{
			soap_serialize_PointerTo_ds__KeyInfo(soap, a->ds__KeyInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType), type))
		return soap->error;
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
			if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, a->ds__KeyInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_in_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	struct soap_blist *soap_blist_ds__KeyInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__KeyInfoConfirmationDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__KeyInfoConfirmationDataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:KeyInfo", 1, NULL))
			{	if (a->ds__KeyInfo == NULL)
				{	if (soap_blist_ds__KeyInfo == NULL)
						soap_blist_ds__KeyInfo = soap_alloc_block(soap);
					a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_push_block_max(soap, soap_blist_ds__KeyInfo, sizeof(struct ds__KeyInfoType *));
					if (a->ds__KeyInfo == NULL)
						return NULL;
					*a->ds__KeyInfo = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", a->ds__KeyInfo, ""))
				{	a->__sizeds__KeyInfo++;
					a->ds__KeyInfo = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ds__KeyInfo)
			soap_pop_block(soap, soap_blist_ds__KeyInfo);
		if (a->__sizeds__KeyInfo)
		{	a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_save_block(soap, soap_blist_ds__KeyInfo, NULL, 1);
		}
		else
		{	a->ds__KeyInfo = NULL;
			if (soap_blist_ds__KeyInfo)
				soap_end_block(soap, soap_blist_ds__KeyInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeds__KeyInfo < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__KeyInfoConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__KeyInfoConfirmationDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__KeyInfoConfirmationDataType *p;
	size_t k = sizeof(struct saml2__KeyInfoConfirmationDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__KeyInfoConfirmationDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__KeyInfoConfirmationDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__KeyInfoConfirmationDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__KeyInfoConfirmationDataType(soap, tag ? tag : "saml2:KeyInfoConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_get_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
	soap_default_string(soap, &a->Recipient);
	soap_default_string(soap, &a->InResponseTo);
	soap_default_string(soap, &a->Address);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_xsd__dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_xsd__dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	if (a->InResponseTo)
		soap_set_attr(soap, "InResponseTo", soap_string2s(soap, a->InResponseTo), 1);
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectConfirmationDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationDataType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 1, 0), &a->Recipient))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "InResponseTo", 1, 0), &a->InResponseTo))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 1, 0), &a->Address))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationDataType, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectConfirmationDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectConfirmationDataType *p;
	size_t k = sizeof(struct saml2__SubjectConfirmationDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectConfirmationDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectConfirmationDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectConfirmationDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectConfirmationDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationDataType(soap, tag ? tag : "saml2:SubjectConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->saml2__SubjectConfirmationData = NULL;
	soap_default_string(soap, &a->Method);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	soap_serialize_PointerTosaml2__SubjectConfirmationDataType(soap, &a->saml2__SubjectConfirmationData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationType *a, const char *type)
{
	soap_set_attr(soap, "Method", a->Method ? soap_string2s(soap, a->Method) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", -1, &a->saml2__SubjectConfirmationData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	size_t soap_flag_saml2__SubjectConfirmationData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectConfirmationType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Method", 1, 1), &a->Method))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			}
			if (soap_flag_saml2__SubjectConfirmationData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", &a->saml2__SubjectConfirmationData, "saml2:SubjectConfirmationDataType"))
				{	soap_flag_saml2__SubjectConfirmationData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationType, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectConfirmationType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectConfirmationType *p;
	size_t k = sizeof(struct saml2__SubjectConfirmationType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectConfirmationType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectConfirmationType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectConfirmationType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectConfirmationType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationType(soap, tag ? tag : "saml2:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->__sizeSubjectConfirmation = 0;
	a->saml2__SubjectConfirmation = NULL;
	a->__sizeSubjectConfirmation_ = 0;
	a->saml2__SubjectConfirmation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
		{
			soap_embedded(soap, a->saml2__SubjectConfirmation + i, SOAP_TYPE_saml2__SubjectConfirmationType);
			soap_serialize_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation + i);
		}
	}
	if (a->saml2__SubjectConfirmation_)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation_; i++)
		{
			soap_embedded(soap, a->saml2__SubjectConfirmation_ + i, SOAP_TYPE_saml2__SubjectConfirmationType);
			soap_serialize_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
			if (soap_out_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", -1, a->saml2__SubjectConfirmation + i, ""))
				return soap->error;
	}
	if (a->saml2__SubjectConfirmation_)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation_; i++)
			if (soap_out_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", -1, a->saml2__SubjectConfirmation_ + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_in_saml2__SubjectType(struct soap *soap, const char *tag, struct saml2__SubjectType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	struct soap_blist *soap_blist_saml2__SubjectConfirmation = NULL;
	struct soap_blist *soap_blist_saml2__SubjectConfirmation_ = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:SubjectConfirmation", 1, NULL))
			{	if (a->saml2__SubjectConfirmation == NULL)
				{	if (soap_blist_saml2__SubjectConfirmation == NULL)
						soap_blist_saml2__SubjectConfirmation = soap_alloc_block(soap);
					a->saml2__SubjectConfirmation = soap_block<struct saml2__SubjectConfirmationType>::push(soap, soap_blist_saml2__SubjectConfirmation);
					if (a->saml2__SubjectConfirmation == NULL)
						return NULL;
					soap_default_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation);
				}
				soap_revert(soap);
				if (soap_in_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", a->saml2__SubjectConfirmation, "saml2:SubjectConfirmationType"))
				{	a->__sizeSubjectConfirmation++;
					a->saml2__SubjectConfirmation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:SubjectConfirmation", 1, NULL))
			{	if (a->saml2__SubjectConfirmation_ == NULL)
				{	if (soap_blist_saml2__SubjectConfirmation_ == NULL)
						soap_blist_saml2__SubjectConfirmation_ = soap_alloc_block(soap);
					a->saml2__SubjectConfirmation_ = soap_block<struct saml2__SubjectConfirmationType>::push(soap, soap_blist_saml2__SubjectConfirmation_);
					if (a->saml2__SubjectConfirmation_ == NULL)
						return NULL;
					soap_default_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation_);
				}
				soap_revert(soap);
				if (soap_in_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", a->saml2__SubjectConfirmation_, "saml2:SubjectConfirmationType"))
				{	a->__sizeSubjectConfirmation_++;
					a->saml2__SubjectConfirmation_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__SubjectConfirmation)
			soap_block<struct saml2__SubjectConfirmationType>::pop(soap, soap_blist_saml2__SubjectConfirmation);
		if (a->__sizeSubjectConfirmation)
		{	a->saml2__SubjectConfirmation = soap_new_saml2__SubjectConfirmationType(soap, a->__sizeSubjectConfirmation);
			if (!a->saml2__SubjectConfirmation)
				return NULL;
			soap_block<struct saml2__SubjectConfirmationType>::save(soap, soap_blist_saml2__SubjectConfirmation, a->saml2__SubjectConfirmation);
		}
		else
		{	a->saml2__SubjectConfirmation = NULL;
			if (soap_blist_saml2__SubjectConfirmation)
				soap_block<struct saml2__SubjectConfirmationType>::end(soap, soap_blist_saml2__SubjectConfirmation);
		}
		if (a->saml2__SubjectConfirmation_)
			soap_block<struct saml2__SubjectConfirmationType>::pop(soap, soap_blist_saml2__SubjectConfirmation_);
		if (a->__sizeSubjectConfirmation_)
		{	a->saml2__SubjectConfirmation_ = soap_new_saml2__SubjectConfirmationType(soap, a->__sizeSubjectConfirmation_);
			if (!a->saml2__SubjectConfirmation_)
				return NULL;
			soap_block<struct saml2__SubjectConfirmationType>::save(soap, soap_blist_saml2__SubjectConfirmation_, a->saml2__SubjectConfirmation_);
		}
		else
		{	a->saml2__SubjectConfirmation_ = NULL;
			if (soap_blist_saml2__SubjectConfirmation_)
				soap_block<struct saml2__SubjectConfirmationType>::end(soap, soap_blist_saml2__SubjectConfirmation_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectType, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__SubjectType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__SubjectType *p;
	size_t k = sizeof(struct saml2__SubjectType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__SubjectType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__SubjectType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__SubjectType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__SubjectType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectType(soap, tag ? tag : "saml2:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_get_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Issuer = NULL;
	a->ds__Signature = NULL;
	a->saml2__Subject = NULL;
	a->saml2__Conditions = NULL;
	a->saml2__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->ID);
	soap_default_xsd__dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__Issuer);
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml2__SubjectType(soap, &a->saml2__Subject);
	soap_serialize_PointerTosaml2__ConditionsType(soap, &a->saml2__Conditions);
	soap_serialize_PointerTosaml2__AdviceType(soap, &a->saml2__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml2__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AssertionType(struct soap *soap, const char *tag, int id, const struct saml2__AssertionType *a, const char *type)
{
	soap_set_attr(soap, "Version", a->Version ? soap_string2s(soap, a->Version) : "", 1);
	soap_set_attr(soap, "ID", a->ID ? soap_string2s(soap, a->ID) : "", 1);
	soap_set_attr(soap, "IssueInstant", soap_xsd__dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AssertionType), type))
		return soap->error;
	if (!a->saml2__Issuer)
	{	if (soap_element_empty(soap, "saml2:Issuer"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:Issuer", -1, &a->saml2__Issuer, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectType(soap, "saml2:Subject", -1, &a->saml2__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", -1, &a->saml2__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AdviceType(soap, "saml2:Advice", -1, &a->saml2__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml2__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_in_saml2__AssertionType(struct soap *soap, const char *tag, struct saml2__AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Issuer = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml2__Subject = 1;
	size_t soap_flag_saml2__Conditions = 1;
	size_t soap_flag_saml2__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AssertionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Version", 1, 1), &a->Version))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ID", 1, 1), &a->ID))
		return NULL;
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "IssueInstant", 5, 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Issuer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:Issuer", &a->saml2__Issuer, "saml2:NameIDType"))
				{	soap_flag_saml2__Issuer--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap_flag_saml2__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectType(soap, "saml2:Subject", &a->saml2__Subject, "saml2:SubjectType"))
				{	soap_flag_saml2__Subject--;
					continue;
				}
			}
			if (soap_flag_saml2__Conditions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", &a->saml2__Conditions, "saml2:ConditionsType"))
				{	soap_flag_saml2__Conditions--;
					continue;
				}
			}
			if (soap_flag_saml2__Advice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AdviceType(soap, "saml2:Advice", &a->saml2__Advice, "saml2:AdviceType"))
				{	soap_flag_saml2__Advice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = soap_block<struct __saml2__union_AssertionType>::push(soap, soap_blist___union_AssertionType);
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml2__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml2__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml2:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_block<struct __saml2__union_AssertionType>::pop(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = soap_new___saml2__union_AssertionType(soap, a->__size_AssertionType);
			if (!a->__union_AssertionType)
				return NULL;
			soap_block<struct __saml2__union_AssertionType>::save(soap, soap_blist___union_AssertionType, a->__union_AssertionType);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_block<struct __saml2__union_AssertionType>::end(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__Issuer))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AssertionType, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__AssertionType *p;
	size_t k = sizeof(struct saml2__AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AssertionType(soap, tag ? tag : "saml2:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_get_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	a->__sizexenc__EncryptedKey = 0;
	a->xenc__EncryptedKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
		{
			soap_serialize_PointerToxenc__EncryptedKeyType(soap, a->xenc__EncryptedKey + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EncryptedElementType(struct soap *soap, const char *tag, int id, const struct saml2__EncryptedElementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EncryptedElementType), type))
		return soap->error;
	if (soap_out_xenc__EncryptedDataType(soap, "xenc:EncryptedData", -1, &a->xenc__EncryptedData, ""))
		return soap->error;
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
			if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, a->xenc__EncryptedKey + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_in_saml2__EncryptedElementType(struct soap *soap, const char *tag, struct saml2__EncryptedElementType *a, const char *type)
{
	size_t soap_flag_xenc__EncryptedData = 1;
	struct soap_blist *soap_blist_xenc__EncryptedKey = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__EncryptedElementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EncryptedElementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xenc__EncryptedData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xenc__EncryptedDataType(soap, "xenc:EncryptedData", &a->xenc__EncryptedData, "xenc:EncryptedDataType"))
				{	soap_flag_xenc__EncryptedData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptedKey", 1, NULL))
			{	if (a->xenc__EncryptedKey == NULL)
				{	if (soap_blist_xenc__EncryptedKey == NULL)
						soap_blist_xenc__EncryptedKey = soap_alloc_block(soap);
					a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_push_block_max(soap, soap_blist_xenc__EncryptedKey, sizeof(struct xenc__EncryptedKeyType *));
					if (a->xenc__EncryptedKey == NULL)
						return NULL;
					*a->xenc__EncryptedKey = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	a->__sizexenc__EncryptedKey++;
					a->xenc__EncryptedKey = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->xenc__EncryptedKey)
			soap_pop_block(soap, soap_blist_xenc__EncryptedKey);
		if (a->__sizexenc__EncryptedKey)
		{	a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_save_block(soap, soap_blist_xenc__EncryptedKey, NULL, 1);
		}
		else
		{	a->xenc__EncryptedKey = NULL;
			if (soap_blist_xenc__EncryptedKey)
				soap_end_block(soap, soap_blist_xenc__EncryptedKey);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xenc__EncryptedData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__EncryptedElementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EncryptedElementType, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__EncryptedElementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__EncryptedElementType *p;
	size_t k = sizeof(struct saml2__EncryptedElementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__EncryptedElementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__EncryptedElementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__EncryptedElementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__EncryptedElementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EncryptedElementType(soap, tag ? tag : "saml2:EncryptedElementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_get_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EncryptedElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Format);
	soap_default_string(soap, &a->SPProvidedID);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__NameIDType(struct soap *soap, const char *tag, int id, const struct saml2__NameIDType *a, const char *type)
{
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	if (a->SPProvidedID)
		soap_set_attr(soap, "SPProvidedID", soap_string2s(soap, a->SPProvidedID), 1);
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_in_saml2__NameIDType(struct soap *soap, const char *tag, struct saml2__NameIDType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml2__NameIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__NameIDType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 1, 0), &a->Format))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPProvidedID", 1, 0), &a->SPProvidedID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 1, 0), &a->SPNameQualifier))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:NameIDType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__NameIDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__NameIDType *p;
	size_t k = sizeof(struct saml2__NameIDType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__NameIDType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__NameIDType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__NameIDType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__NameIDType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__NameIDType(soap, tag ? tag : "saml2:NameIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_get_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__NameIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__BaseIDAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_in_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__BaseIDAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__BaseIDAbstractType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 1, 0), &a->SPNameQualifier))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__BaseIDAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__BaseIDAbstractType, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml2__BaseIDAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml2__BaseIDAbstractType *p;
	size_t k = sizeof(struct saml2__BaseIDAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml2__BaseIDAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml2__BaseIDAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml2__BaseIDAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml2__BaseIDAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__BaseIDAbstractType(soap, tag ? tag : "saml2:BaseIDAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_get_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__BaseIDAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Attribute(struct soap *soap, const struct saml1__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Attribute(soap, tag ? tag : "saml1:Attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AttributeDesignator(struct soap *soap, const struct saml1__AttributeDesignatorType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AttributeDesignator(soap, tag ? tag : "saml1:AttributeDesignator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AttributeStatement(struct soap *soap, const struct saml1__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AttributeStatement(soap, tag ? tag : "saml1:AttributeStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Evidence(struct soap *soap, const struct saml1__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Evidence(soap, tag ? tag : "saml1:Evidence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Action(struct soap *soap, const struct saml1__ActionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Action(soap, tag ? tag : "saml1:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthorizationDecisionStatement(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthorizationDecisionStatement(soap, tag ? tag : "saml1:AuthorizationDecisionStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthorityBinding(struct soap *soap, const struct saml1__AuthorityBindingType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthorityBinding(soap, tag ? tag : "saml1:AuthorityBinding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectLocality(struct soap *soap, const struct saml1__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectLocality(soap, tag ? tag : "saml1:SubjectLocality", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthenticationStatement(struct soap *soap, const struct saml1__AuthenticationStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthenticationStatement(soap, tag ? tag : "saml1:AuthenticationStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectConfirmation(struct soap *soap, const struct saml1__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectConfirmation(soap, tag ? tag : "saml1:SubjectConfirmation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__NameIdentifier(struct soap *soap, const struct saml1__NameIdentifierType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__NameIdentifier(soap, tag ? tag : "saml1:NameIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Subject(struct soap *soap, const struct saml1__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Subject(soap, tag ? tag : "saml1:Subject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectStatement(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectStatement(soap, tag ? tag : "saml1:SubjectStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Statement(struct soap *soap, const struct saml1__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Statement(soap, tag ? tag : "saml1:Statement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Advice(struct soap *soap, const struct saml1__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Advice(soap, tag ? tag : "saml1:Advice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__DoNotCacheCondition(struct soap *soap, const struct saml1__DoNotCacheConditionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__DoNotCacheCondition(soap, tag ? tag : "saml1:DoNotCacheCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AudienceRestrictionCondition(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AudienceRestrictionCondition(soap, tag ? tag : "saml1:AudienceRestrictionCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Condition(struct soap *soap, const struct saml1__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Condition(soap, tag ? tag : "saml1:Condition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Conditions(struct soap *soap, const struct saml1__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Conditions(soap, tag ? tag : "saml1:Conditions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Assertion(struct soap *soap, const struct saml1__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Assertion(soap, tag ? tag : "saml1:Assertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_in___saml1__union_EvidenceType(struct soap *soap, const char *tag, struct __saml1__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_EvidenceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_EvidenceType *p;
	size_t k = sizeof(struct __saml1__union_EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_EvidenceType(soap, tag ? tag : "-saml1:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_get___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_in___saml1__union_AdviceType(struct soap *soap, const char *tag, struct __saml1__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AdviceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_AdviceType *p;
	size_t k = sizeof(struct __saml1__union_AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AdviceType(soap, tag ? tag : "-saml1:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_get___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__AudienceRestrictionCondition = NULL;
	a->saml1__DoNotCacheCondition = NULL;
	a->saml1__Condition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(soap, &a->saml1__AudienceRestrictionCondition);
	soap_serialize_PointerTosaml1__DoNotCacheConditionType(soap, &a->saml1__DoNotCacheCondition);
	soap_serialize_PointerTosaml1__ConditionAbstractType(soap, &a->saml1__Condition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml1__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", -1, &a->saml1__AudienceRestrictionCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", -1, &a->saml1__DoNotCacheCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", -1, &a->saml1__Condition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_in___saml1__union_ConditionsType(struct soap *soap, const char *tag, struct __saml1__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml1__AudienceRestrictionCondition = 1;
	size_t soap_flag_saml1__DoNotCacheCondition = 1;
	size_t soap_flag_saml1__Condition = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_ConditionsType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AudienceRestrictionCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", &a->saml1__AudienceRestrictionCondition, "saml1:AudienceRestrictionConditionType"))
				{	soap_flag_saml1__AudienceRestrictionCondition--;
					continue;
				}
			}
			if (soap_flag_saml1__DoNotCacheCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", &a->saml1__DoNotCacheCondition, "saml1:DoNotCacheConditionType"))
				{	soap_flag_saml1__DoNotCacheCondition--;
					continue;
				}
			}
			if (soap_flag_saml1__Condition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", &a->saml1__Condition, "saml1:ConditionAbstractType"))
				{	soap_flag_saml1__Condition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_ConditionsType *p;
	size_t k = sizeof(struct __saml1__union_ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_ConditionsType(soap, tag ? tag : "-saml1:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_get___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Statement = NULL;
	a->saml1__SubjectStatement = NULL;
	a->saml1__AuthenticationStatement = NULL;
	a->saml1__AuthorizationDecisionStatement = NULL;
	a->saml1__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__StatementAbstractType(soap, &a->saml1__Statement);
	soap_serialize_PointerTosaml1__SubjectStatementAbstractType(soap, &a->saml1__SubjectStatement);
	soap_serialize_PointerTosaml1__AuthenticationStatementType(soap, &a->saml1__AuthenticationStatement);
	soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(soap, &a->saml1__AuthorizationDecisionStatement);
	soap_serialize_PointerTosaml1__AttributeStatementType(soap, &a->saml1__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", -1, &a->saml1__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", -1, &a->saml1__SubjectStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", -1, &a->saml1__AuthenticationStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", -1, &a->saml1__AuthorizationDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", -1, &a->saml1__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_in___saml1__union_AssertionType(struct soap *soap, const char *tag, struct __saml1__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Statement = 1;
	size_t soap_flag_saml1__SubjectStatement = 1;
	size_t soap_flag_saml1__AuthenticationStatement = 1;
	size_t soap_flag_saml1__AuthorizationDecisionStatement = 1;
	size_t soap_flag_saml1__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AssertionType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Statement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", &a->saml1__Statement, "saml1:StatementAbstractType"))
				{	soap_flag_saml1__Statement--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", &a->saml1__SubjectStatement, "saml1:SubjectStatementAbstractType"))
				{	soap_flag_saml1__SubjectStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AuthenticationStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", &a->saml1__AuthenticationStatement, "saml1:AuthenticationStatementType"))
				{	soap_flag_saml1__AuthenticationStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AuthorizationDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", &a->saml1__AuthorizationDecisionStatement, "saml1:AuthorizationDecisionStatementType"))
				{	soap_flag_saml1__AuthorizationDecisionStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", &a->saml1__AttributeStatement, "saml1:AttributeStatementType"))
				{	soap_flag_saml1__AttributeStatement--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___saml1__union_AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __saml1__union_AssertionType *p;
	size_t k = sizeof(struct __saml1__union_AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___saml1__union_AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __saml1__union_AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __saml1__union_AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __saml1__union_AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AssertionType(soap, tag ? tag : "-saml1:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_get___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
	a->__sizeAttributeValue = 0;
	a->saml1__AttributeValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeType *a, const char *type)
{
	soap_set_attr(soap, "AttributeName", a->AttributeName ? soap_string2s(soap, a->AttributeName) : "", 1);
	soap_set_attr(soap, "AttributeNamespace", a->AttributeNamespace ? soap_string2s(soap, a->AttributeNamespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeType), type))
		return soap->error;
	if (a->saml1__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			if (soap_outliteral(soap, "saml1:AttributeValue", (char*const*)(a->saml1__AttributeValue + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_in_saml1__AttributeType(struct soap *soap, const char *tag, struct saml1__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1, 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1, 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AttributeValue", 1, NULL))
			{	if (a->saml1__AttributeValue == NULL)
				{	if (soap_blist_saml1__AttributeValue == NULL)
						soap_blist_saml1__AttributeValue = soap_alloc_block(soap);
					a->saml1__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml1__AttributeValue, sizeof(char *));
					if (a->saml1__AttributeValue == NULL)
						return NULL;
					*a->saml1__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml1:AttributeValue", (char**)a->saml1__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml1__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AttributeValue)
			soap_pop_block(soap, soap_blist_saml1__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml1__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml1__AttributeValue, NULL, 1);
		}
		else
		{	a->saml1__AttributeValue = NULL;
			if (soap_blist_saml1__AttributeValue)
				soap_end_block(soap, soap_blist_saml1__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAttributeValue < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeType, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AttributeType *p;
	size_t k = sizeof(struct saml1__AttributeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AttributeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AttributeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AttributeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AttributeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeType(soap, tag ? tag : "saml1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_get_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeDesignatorType *a, const char *type)
{
	soap_set_attr(soap, "AttributeName", a->AttributeName ? soap_string2s(soap, a->AttributeName) : "", 1);
	soap_set_attr(soap, "AttributeNamespace", a->AttributeNamespace ? soap_string2s(soap, a->AttributeNamespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeDesignatorType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_in_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, struct saml1__AttributeDesignatorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeDesignatorType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeDesignatorType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1, 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1, 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeDesignatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeDesignatorType, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AttributeDesignatorType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AttributeDesignatorType *p;
	size_t k = sizeof(struct saml1__AttributeDesignatorType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AttributeDesignatorType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AttributeDesignatorType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AttributeDesignatorType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AttributeDesignatorType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeDesignatorType(soap, tag ? tag : "saml1:AttributeDesignatorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_get_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeDesignatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAttribute = 0;
	a->saml1__Attribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
		{
			soap_embedded(soap, a->saml1__Attribute + i, SOAP_TYPE_saml1__AttributeType);
			soap_serialize_saml1__AttributeType(soap, a->saml1__Attribute + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
			if (soap_out_saml1__AttributeType(soap, "saml1:Attribute", -1, a->saml1__Attribute + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_in_saml1__AttributeStatementType(struct soap *soap, const char *tag, struct saml1__AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Attribute = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeStatementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Attribute", 1, NULL))
			{	if (a->saml1__Attribute == NULL)
				{	if (soap_blist_saml1__Attribute == NULL)
						soap_blist_saml1__Attribute = soap_alloc_block(soap);
					a->saml1__Attribute = soap_block<struct saml1__AttributeType>::push(soap, soap_blist_saml1__Attribute);
					if (a->saml1__Attribute == NULL)
						return NULL;
					soap_default_saml1__AttributeType(soap, a->saml1__Attribute);
				}
				soap_revert(soap);
				if (soap_in_saml1__AttributeType(soap, "saml1:Attribute", a->saml1__Attribute, "saml1:AttributeType"))
				{	a->__sizeAttribute++;
					a->saml1__Attribute = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Attribute)
			soap_block<struct saml1__AttributeType>::pop(soap, soap_blist_saml1__Attribute);
		if (a->__sizeAttribute)
		{	a->saml1__Attribute = soap_new_saml1__AttributeType(soap, a->__sizeAttribute);
			if (!a->saml1__Attribute)
				return NULL;
			soap_block<struct saml1__AttributeType>::save(soap, soap_blist_saml1__Attribute, a->saml1__Attribute);
		}
		else
		{	a->saml1__Attribute = NULL;
			if (soap_blist_saml1__Attribute)
				soap_block<struct saml1__AttributeType>::end(soap, soap_blist_saml1__Attribute);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAttribute < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeStatementType, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AttributeStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AttributeStatementType *p;
	size_t k = sizeof(struct saml1__AttributeStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AttributeStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AttributeStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AttributeStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AttributeStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeStatementType(soap, tag ? tag : "saml1:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_get_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml1__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml1__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml1__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_in_saml1__EvidenceType(struct soap *soap, const char *tag, struct saml1__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__EvidenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__EvidenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = soap_block<struct __saml1__union_EvidenceType>::push(soap, soap_blist___union_EvidenceType);
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml1__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml1__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml1:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_block<struct __saml1__union_EvidenceType>::pop(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = soap_new___saml1__union_EvidenceType(soap, a->__size_EvidenceType);
			if (!a->__union_EvidenceType)
				return NULL;
			soap_block<struct __saml1__union_EvidenceType>::save(soap, soap_blist___union_EvidenceType, a->__union_EvidenceType);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_block<struct __saml1__union_EvidenceType>::end(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__EvidenceType, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__EvidenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__EvidenceType *p;
	size_t k = sizeof(struct saml1__EvidenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__EvidenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__EvidenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__EvidenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__EvidenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__EvidenceType(soap, tag ? tag : "saml1:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_get_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ActionType(struct soap *soap, struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ActionType(struct soap *soap, const char *tag, int id, const struct saml1__ActionType *a, const char *type)
{
	if (a->Namespace)
		soap_set_attr(soap, "Namespace", soap_string2s(soap, a->Namespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_in_saml1__ActionType(struct soap *soap, const char *tag, struct saml1__ActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml1__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1, 0), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__ActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__ActionType *p;
	size_t k = sizeof(struct saml1__ActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__ActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__ActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__ActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__ActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ActionType(soap, tag ? tag : "saml1:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_get_saml1__ActionType(struct soap *soap, struct saml1__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAction = 0;
	a->saml1__Action = NULL;
	a->saml1__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml1__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml1__Action + i, SOAP_TYPE_saml1__ActionType);
			soap_serialize_saml1__ActionType(soap, a->saml1__Action + i);
		}
	}
	soap_serialize_PointerTosaml1__EvidenceType(soap, &a->saml1__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	soap_set_attr(soap, "Resource", a->Resource ? soap_string2s(soap, a->Resource) : "", 1);
	soap_set_attr(soap, "Decision", soap_saml1__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml1__ActionType(soap, "saml1:Action", -1, a->saml1__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", -1, &a->saml1__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_in_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Action = NULL;
	size_t soap_flag_saml1__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthorizationDecisionStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorizationDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1, 1), &a->Resource))
		return NULL;
	if (soap_s2saml1__DecisionType(soap, soap_attr_value(soap, "Decision", 5, 1), &a->Decision))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Action", 1, NULL))
			{	if (a->saml1__Action == NULL)
				{	if (soap_blist_saml1__Action == NULL)
						soap_blist_saml1__Action = soap_alloc_block(soap);
					a->saml1__Action = soap_block<struct saml1__ActionType>::push(soap, soap_blist_saml1__Action);
					if (a->saml1__Action == NULL)
						return NULL;
					soap_default_saml1__ActionType(soap, a->saml1__Action);
				}
				soap_revert(soap);
				if (soap_in_saml1__ActionType(soap, "saml1:Action", a->saml1__Action, "saml1:ActionType"))
				{	a->__sizeAction++;
					a->saml1__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__Evidence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", &a->saml1__Evidence, "saml1:EvidenceType"))
				{	soap_flag_saml1__Evidence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Action)
			soap_block<struct saml1__ActionType>::pop(soap, soap_blist_saml1__Action);
		if (a->__sizeAction)
		{	a->saml1__Action = soap_new_saml1__ActionType(soap, a->__sizeAction);
			if (!a->saml1__Action)
				return NULL;
			soap_block<struct saml1__ActionType>::save(soap, soap_blist_saml1__Action, a->saml1__Action);
		}
		else
		{	a->saml1__Action = NULL;
			if (soap_blist_saml1__Action)
				soap_block<struct saml1__ActionType>::end(soap, soap_blist_saml1__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthorizationDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AuthorizationDecisionStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AuthorizationDecisionStatementType *p;
	size_t k = sizeof(struct saml1__AuthorizationDecisionStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AuthorizationDecisionStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AuthorizationDecisionStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AuthorizationDecisionStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorizationDecisionStatementType(soap, tag ? tag : "saml1:AuthorizationDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_get_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->AuthorityKind);
	soap_default_string(soap, &a->Location);
	soap_default_string(soap, &a->Binding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorityBindingType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorityBindingType *a, const char *type)
{
	soap_set_attr(soap, "AuthorityKind", a->AuthorityKind ? soap__QName2s(soap, a->AuthorityKind) : "", 1);
	soap_set_attr(soap, "Location", a->Location ? soap_string2s(soap, a->Location) : "", 1);
	soap_set_attr(soap, "Binding", a->Binding ? soap_string2s(soap, a->Binding) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorityBindingType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_in_saml1__AuthorityBindingType(struct soap *soap, const char *tag, struct saml1__AuthorityBindingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthorityBindingType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorityBindingType(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "AuthorityKind", 2, 1), &a->AuthorityKind))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Location", 1, 1), &a->Location))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Binding", 1, 1), &a->Binding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorityBindingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorityBindingType, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AuthorityBindingType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AuthorityBindingType *p;
	size_t k = sizeof(struct saml1__AuthorityBindingType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AuthorityBindingType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AuthorityBindingType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AuthorityBindingType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AuthorityBindingType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorityBindingType(soap, tag ? tag : "saml1:AuthorityBindingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_get_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorityBindingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPAddress);
	soap_default_string(soap, &a->DNSAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectLocalityType *a, const char *type)
{
	if (a->IPAddress)
		soap_set_attr(soap, "IPAddress", soap_string2s(soap, a->IPAddress), 1);
	if (a->DNSAddress)
		soap_set_attr(soap, "DNSAddress", soap_string2s(soap, a->DNSAddress), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_in_saml1__SubjectLocalityType(struct soap *soap, const char *tag, struct saml1__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectLocalityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "IPAddress", 1, 0), &a->IPAddress))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSAddress", 1, 0), &a->DNSAddress))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectLocalityType, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectLocalityType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectLocalityType *p;
	size_t k = sizeof(struct saml1__SubjectLocalityType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectLocalityType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectLocalityType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectLocalityType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectLocalityType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectLocalityType(soap, tag ? tag : "saml1:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_get_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->saml1__SubjectLocality = NULL;
	a->__sizeAuthorityBinding = 0;
	a->saml1__AuthorityBinding = NULL;
	soap_default_string(soap, &a->AuthenticationMethod);
	soap_default_xsd__dateTime(soap, &a->AuthenticationInstant);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	soap_serialize_PointerTosaml1__SubjectLocalityType(soap, &a->saml1__SubjectLocality);
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
		{
			soap_embedded(soap, a->saml1__AuthorityBinding + i, SOAP_TYPE_saml1__AuthorityBindingType);
			soap_serialize_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthenticationStatementType *a, const char *type)
{
	soap_set_attr(soap, "AuthenticationMethod", a->AuthenticationMethod ? soap_string2s(soap, a->AuthenticationMethod) : "", 1);
	soap_set_attr(soap, "AuthenticationInstant", soap_xsd__dateTime2s(soap, a->AuthenticationInstant), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthenticationStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", -1, &a->saml1__SubjectLocality, ""))
		return soap->error;
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
			if (soap_out_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", -1, a->saml1__AuthorityBinding + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_in_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, struct saml1__AuthenticationStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	size_t soap_flag_saml1__SubjectLocality = 1;
	struct soap_blist *soap_blist_saml1__AuthorityBinding = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthenticationStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthenticationStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AuthenticationMethod", 1, 1), &a->AuthenticationMethod))
		return NULL;
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "AuthenticationInstant", 5, 1), &a->AuthenticationInstant))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", &a->saml1__SubjectLocality, "saml1:SubjectLocalityType"))
				{	soap_flag_saml1__SubjectLocality--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AuthorityBinding", 1, NULL))
			{	if (a->saml1__AuthorityBinding == NULL)
				{	if (soap_blist_saml1__AuthorityBinding == NULL)
						soap_blist_saml1__AuthorityBinding = soap_alloc_block(soap);
					a->saml1__AuthorityBinding = soap_block<struct saml1__AuthorityBindingType>::push(soap, soap_blist_saml1__AuthorityBinding);
					if (a->saml1__AuthorityBinding == NULL)
						return NULL;
					soap_default_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding);
				}
				soap_revert(soap);
				if (soap_in_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", a->saml1__AuthorityBinding, "saml1:AuthorityBindingType"))
				{	a->__sizeAuthorityBinding++;
					a->saml1__AuthorityBinding = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AuthorityBinding)
			soap_block<struct saml1__AuthorityBindingType>::pop(soap, soap_blist_saml1__AuthorityBinding);
		if (a->__sizeAuthorityBinding)
		{	a->saml1__AuthorityBinding = soap_new_saml1__AuthorityBindingType(soap, a->__sizeAuthorityBinding);
			if (!a->saml1__AuthorityBinding)
				return NULL;
			soap_block<struct saml1__AuthorityBindingType>::save(soap, soap_blist_saml1__AuthorityBinding, a->saml1__AuthorityBinding);
		}
		else
		{	a->saml1__AuthorityBinding = NULL;
			if (soap_blist_saml1__AuthorityBinding)
				soap_block<struct saml1__AuthorityBindingType>::end(soap, soap_blist_saml1__AuthorityBinding);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthenticationStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthenticationStatementType, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AuthenticationStatementType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AuthenticationStatementType *p;
	size_t k = sizeof(struct saml1__AuthenticationStatementType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AuthenticationStatementType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AuthenticationStatementType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AuthenticationStatementType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AuthenticationStatementType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthenticationStatementType(soap, tag ? tag : "saml1:AuthenticationStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_get_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthenticationStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfirmationMethod = 0;
	a->saml1__ConfirmationMethod = NULL;
	a->saml1__SubjectConfirmationData = NULL;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__ConfirmationMethod + i));
		}
	}
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectConfirmationType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectConfirmationType), type))
		return soap->error;
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
			if (soap_out_string(soap, "saml1:ConfirmationMethod", -1, (char*const*)(a->saml1__ConfirmationMethod + i), ""))
				return soap->error;
	}
	if (soap_outliteral(soap, "saml1:SubjectConfirmationData", (char*const*)&a->saml1__SubjectConfirmationData, NULL))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml1__SubjectConfirmationType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__ConfirmationMethod = NULL;
	size_t soap_flag_saml1__SubjectConfirmationData = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectConfirmationType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectConfirmationType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:ConfirmationMethod", 1, NULL))
			{	if (a->saml1__ConfirmationMethod == NULL)
				{	if (soap_blist_saml1__ConfirmationMethod == NULL)
						soap_blist_saml1__ConfirmationMethod = soap_alloc_block(soap);
					a->saml1__ConfirmationMethod = (char **)soap_push_block_max(soap, soap_blist_saml1__ConfirmationMethod, sizeof(char *));
					if (a->saml1__ConfirmationMethod == NULL)
						return NULL;
					*a->saml1__ConfirmationMethod = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:ConfirmationMethod", (char**)a->saml1__ConfirmationMethod, "xsd:string"))
				{	a->__sizeConfirmationMethod++;
					a->saml1__ConfirmationMethod = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmationData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml1:SubjectConfirmationData", (char**)&a->saml1__SubjectConfirmationData))
				{	soap_flag_saml1__SubjectConfirmationData--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__ConfirmationMethod)
			soap_pop_block(soap, soap_blist_saml1__ConfirmationMethod);
		if (a->__sizeConfirmationMethod)
		{	a->saml1__ConfirmationMethod = (char **)soap_save_block(soap, soap_blist_saml1__ConfirmationMethod, NULL, 1);
		}
		else
		{	a->saml1__ConfirmationMethod = NULL;
			if (soap_blist_saml1__ConfirmationMethod)
				soap_end_block(soap, soap_blist_saml1__ConfirmationMethod);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfirmationMethod < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectConfirmationType, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectConfirmationType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectConfirmationType *p;
	size_t k = sizeof(struct saml1__SubjectConfirmationType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectConfirmationType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectConfirmationType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectConfirmationType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectConfirmationType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectConfirmationType(soap, tag ? tag : "saml1:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->Format);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__NameIdentifierType(struct soap *soap, const char *tag, int id, const struct saml1__NameIdentifierType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_in_saml1__NameIdentifierType(struct soap *soap, const char *tag, struct saml1__NameIdentifierType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml1__NameIdentifierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__NameIdentifierType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 1, 0), &a->Format))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:NameIdentifierType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__NameIdentifierType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__NameIdentifierType *p;
	size_t k = sizeof(struct saml1__NameIdentifierType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__NameIdentifierType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__NameIdentifierType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__NameIdentifierType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__NameIdentifierType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__NameIdentifierType(soap, tag ? tag : "saml1:NameIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_get_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__NameIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__NameIdentifier = NULL;
	a->saml1__SubjectConfirmation = NULL;
	a->saml1__SubjectConfirmation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__NameIdentifierType(soap, &a->saml1__NameIdentifier);
	soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, &a->saml1__SubjectConfirmation);
	soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, &a->saml1__SubjectConfirmation_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", -1, &a->saml1__NameIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", -1, &a->saml1__SubjectConfirmation, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", -1, &a->saml1__SubjectConfirmation_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_in_saml1__SubjectType(struct soap *soap, const char *tag, struct saml1__SubjectType *a, const char *type)
{
	size_t soap_flag_saml1__NameIdentifier = 1;
	size_t soap_flag_saml1__SubjectConfirmation = 1;
	size_t soap_flag_saml1__SubjectConfirmation_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__NameIdentifier && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", &a->saml1__NameIdentifier, "saml1:NameIdentifierType"))
				{	soap_flag_saml1__NameIdentifier--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", &a->saml1__SubjectConfirmation, "saml1:SubjectConfirmationType"))
				{	soap_flag_saml1__SubjectConfirmation--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmation_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", &a->saml1__SubjectConfirmation_, "saml1:SubjectConfirmationType"))
				{	soap_flag_saml1__SubjectConfirmation_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectType, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectType *p;
	size_t k = sizeof(struct saml1__SubjectType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectType(soap, tag ? tag : "saml1:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_get_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject"))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_in_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectStatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectStatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectStatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectStatementAbstractType, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__SubjectStatementAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__SubjectStatementAbstractType *p;
	size_t k = sizeof(struct saml1__SubjectStatementAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__SubjectStatementAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__SubjectStatementAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__SubjectStatementAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__SubjectStatementAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectStatementAbstractType(soap, tag ? tag : "saml1:SubjectStatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_get_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectStatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_in_saml1__StatementAbstractType(struct soap *soap, const char *tag, struct saml1__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__StatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__StatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__StatementAbstractType, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__StatementAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__StatementAbstractType *p;
	size_t k = sizeof(struct saml1__StatementAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__StatementAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__StatementAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__StatementAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__StatementAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__StatementAbstractType(soap, tag ? tag : "saml1:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_get_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml1__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AdviceType(struct soap *soap, const char *tag, int id, const struct saml1__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml1__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_in_saml1__AdviceType(struct soap *soap, const char *tag, struct saml1__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AdviceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AdviceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = soap_block<struct __saml1__union_AdviceType>::push(soap, soap_blist___union_AdviceType);
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml1__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml1__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml1:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_block<struct __saml1__union_AdviceType>::pop(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = soap_new___saml1__union_AdviceType(soap, a->__size_AdviceType);
			if (!a->__union_AdviceType)
				return NULL;
			soap_block<struct __saml1__union_AdviceType>::save(soap, soap_blist___union_AdviceType, a->__union_AdviceType);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_block<struct __saml1__union_AdviceType>::end(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AdviceType, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AdviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AdviceType *p;
	size_t k = sizeof(struct saml1__AdviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AdviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AdviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AdviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AdviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AdviceType(soap, tag ? tag : "saml1:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_get_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, int id, const struct saml1__DoNotCacheConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DoNotCacheConditionType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_in_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, struct saml1__DoNotCacheConditionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__DoNotCacheConditionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__DoNotCacheConditionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__DoNotCacheConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DoNotCacheConditionType, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__DoNotCacheConditionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__DoNotCacheConditionType *p;
	size_t k = sizeof(struct saml1__DoNotCacheConditionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__DoNotCacheConditionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__DoNotCacheConditionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__DoNotCacheConditionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__DoNotCacheConditionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DoNotCacheConditionType(soap, tag ? tag : "saml1:DoNotCacheConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_get_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DoNotCacheConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml1__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, int id, const struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType), type))
		return soap->error;
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml1:Audience", -1, (char*const*)(a->saml1__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_in_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AudienceRestrictionConditionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AudienceRestrictionConditionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Audience", 1, NULL))
			{	if (a->saml1__Audience == NULL)
				{	if (soap_blist_saml1__Audience == NULL)
						soap_blist_saml1__Audience = soap_alloc_block(soap);
					a->saml1__Audience = (char **)soap_push_block_max(soap, soap_blist_saml1__Audience, sizeof(char *));
					if (a->saml1__Audience == NULL)
						return NULL;
					*a->saml1__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:Audience", (char**)a->saml1__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml1__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Audience)
			soap_pop_block(soap, soap_blist_saml1__Audience);
		if (a->__sizeAudience)
		{	a->saml1__Audience = (char **)soap_save_block(soap, soap_blist_saml1__Audience, NULL, 1);
		}
		else
		{	a->saml1__Audience = NULL;
			if (soap_blist_saml1__Audience)
				soap_end_block(soap, soap_blist_saml1__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AudienceRestrictionConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AudienceRestrictionConditionType, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AudienceRestrictionConditionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AudienceRestrictionConditionType *p;
	size_t k = sizeof(struct saml1__AudienceRestrictionConditionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AudienceRestrictionConditionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AudienceRestrictionConditionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AudienceRestrictionConditionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AudienceRestrictionConditionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AudienceRestrictionConditionType(soap, tag ? tag : "saml1:AudienceRestrictionConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_get_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AudienceRestrictionConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_in_saml1__ConditionAbstractType(struct soap *soap, const char *tag, struct saml1__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__ConditionAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionAbstractType, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__ConditionAbstractType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__ConditionAbstractType *p;
	size_t k = sizeof(struct saml1__ConditionAbstractType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__ConditionAbstractType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__ConditionAbstractType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__ConditionAbstractType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__ConditionAbstractType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionAbstractType(soap, tag ? tag : "saml1:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_get_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml1__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_xsd__dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_xsd__dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml1__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_in_saml1__ConditionsType(struct soap *soap, const char *tag, struct saml1__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__ConditionsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionsType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = soap_block<struct __saml1__union_ConditionsType>::push(soap, soap_blist___union_ConditionsType);
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml1__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml1__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml1:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_block<struct __saml1__union_ConditionsType>::pop(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = soap_new___saml1__union_ConditionsType(soap, a->__size_ConditionsType);
			if (!a->__union_ConditionsType)
				return NULL;
			soap_block<struct __saml1__union_ConditionsType>::save(soap, soap_blist___union_ConditionsType, a->__union_ConditionsType);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_block<struct __saml1__union_ConditionsType>::end(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionsType, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__ConditionsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__ConditionsType *p;
	size_t k = sizeof(struct saml1__ConditionsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__ConditionsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__ConditionsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__ConditionsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__ConditionsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionsType(soap, tag ? tag : "saml1:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_get_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Conditions = NULL;
	a->saml1__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->MajorVersion);
	soap_default_string(soap, &a->MinorVersion);
	soap_default_string(soap, &a->AssertionID);
	soap_default_string(soap, &a->Issuer);
	soap_default_xsd__dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__ConditionsType(soap, &a->saml1__Conditions);
	soap_serialize_PointerTosaml1__AdviceType(soap, &a->saml1__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml1__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AssertionType(struct soap *soap, const char *tag, int id, const struct saml1__AssertionType *a, const char *type)
{
	soap_set_attr(soap, "MajorVersion", a->MajorVersion ? soap_string2s(soap, a->MajorVersion) : "", 1);
	soap_set_attr(soap, "MinorVersion", a->MinorVersion ? soap_string2s(soap, a->MinorVersion) : "", 1);
	soap_set_attr(soap, "AssertionID", a->AssertionID ? soap_string2s(soap, a->AssertionID) : "", 1);
	soap_set_attr(soap, "Issuer", a->Issuer ? soap_string2s(soap, a->Issuer) : "", 1);
	soap_set_attr(soap, "IssueInstant", soap_xsd__dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AssertionType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", -1, &a->saml1__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AdviceType(soap, "saml1:Advice", -1, &a->saml1__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml1__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_in_saml1__AssertionType(struct soap *soap, const char *tag, struct saml1__AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Conditions = 1;
	size_t soap_flag_saml1__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AssertionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MajorVersion", 1, 1), &a->MajorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MinorVersion", 1, 1), &a->MinorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AssertionID", 1, 1), &a->AssertionID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Issuer", 1, 1), &a->Issuer))
		return NULL;
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "IssueInstant", 5, 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Conditions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", &a->saml1__Conditions, "saml1:ConditionsType"))
				{	soap_flag_saml1__Conditions--;
					continue;
				}
			}
			if (soap_flag_saml1__Advice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AdviceType(soap, "saml1:Advice", &a->saml1__Advice, "saml1:AdviceType"))
				{	soap_flag_saml1__Advice--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = soap_block<struct __saml1__union_AssertionType>::push(soap, soap_blist___union_AssertionType);
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml1__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml1__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml1:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_block<struct __saml1__union_AssertionType>::pop(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = soap_new___saml1__union_AssertionType(soap, a->__size_AssertionType);
			if (!a->__union_AssertionType)
				return NULL;
			soap_block<struct __saml1__union_AssertionType>::save(soap, soap_blist___union_AssertionType, a->__union_AssertionType);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_block<struct __saml1__union_AssertionType>::end(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AssertionType, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_saml1__AssertionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct saml1__AssertionType *p;
	size_t k = sizeof(struct saml1__AssertionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_saml1__AssertionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct saml1__AssertionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct saml1__AssertionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct saml1__AssertionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AssertionType(soap, tag ? tag : "saml1:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_get_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct timeval * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct timeval *p;
	size_t k = sizeof(struct timeval);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct timeval);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct timeval, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct timeval location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__dateTime(struct soap *soap, const struct timeval *a, const char *tag, const char *type)
{
	if (soap_out_xsd__dateTime(soap, tag ? tag : "xsd:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timeval * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, struct timeval *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_DerivedKeyTokenType = -1;
	a->Length = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType);
	soap_serialize_PointerToULONG64(soap, &a->Length);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
		return soap->error;
	if (soap_out_PointerToULONG64(soap, "wsc:Length", -1, &a->Length, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_in___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	size_t soap_flag_union_DerivedKeyTokenType = 1;
	size_t soap_flag_Length = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsc__DerivedKeyTokenType_sequence*)soap_id_enter(soap, "", a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsc__DerivedKeyTokenType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsc__union_DerivedKeyTokenType(soap, &a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
				{	soap_flag_union_DerivedKeyTokenType = 0;
					continue;
				}
			}
			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToULONG64(soap, "wsc:Length", &a->Length, "xsd:unsignedLong"))
				{	soap_flag_Length--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsc__DerivedKeyTokenType_sequence(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsc__DerivedKeyTokenType_sequence *p;
	size_t k = sizeof(struct __wsc__DerivedKeyTokenType_sequence);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsc__DerivedKeyTokenType_sequence);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsc__DerivedKeyTokenType_sequence, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsc__DerivedKeyTokenType_sequence location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *tag, const char *type)
{
	if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag ? tag : "-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_get___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__PropertiesType(struct soap *soap, const char *tag, int id, const struct wsc__PropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__PropertiesType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_in_wsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__PropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__PropertiesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__PropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__PropertiesType *p;
	size_t k = sizeof(struct wsc__PropertiesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsc__PropertiesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsc__PropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsc__PropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__PropertiesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__PropertiesType(soap, tag ? tag : "wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_get_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__SecurityTokenReference = NULL;
	a->Properties = NULL;
	a->__DerivedKeyTokenType_sequence = NULL;
	soap_default_string(soap, &a->Label);
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__PropertiesType(soap, &a->Properties);
	soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, &a->__DerivedKeyTokenType_sequence);
	soap_serialize_string(soap, (char*const*)&a->Label);
	soap_serialize_string(soap, (char*const*)&a->Nonce);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, int id, const struct wsc__DerivedKeyTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__DerivedKeyTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__PropertiesType(soap, "wsc:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", -1, &a->__DerivedKeyTokenType_sequence, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Label", -1, (char*const*)&a->Label, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Nonce", -1, (char*const*)&a->Nonce, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_in_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, struct wsc__DerivedKeyTokenType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_Properties = 1;
	size_t soap_flag___DerivedKeyTokenType_sequence = 1;
	size_t soap_flag_Label = 1;
	size_t soap_flag_Nonce = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__DerivedKeyTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__DerivedKeyTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 0), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsc__PropertiesType(soap, "wsc:Properties", &a->Properties, "wsc:PropertiesType"))
				{	soap_flag_Properties--;
					continue;
				}
			}
			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Label", (char**)&a->Label, "xsd:string"))
				{	soap_flag_Label--;
					continue;
				}
			}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Nonce", (char**)&a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			}
			if (soap_flag___DerivedKeyTokenType_sequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", &a->__DerivedKeyTokenType_sequence, "-wsc:DerivedKeyTokenType-sequence"))
				{	soap_flag___DerivedKeyTokenType_sequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__DerivedKeyTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__DerivedKeyTokenType *p;
	size_t k = sizeof(struct wsc__DerivedKeyTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsc__DerivedKeyTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsc__DerivedKeyTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsc__DerivedKeyTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__DerivedKeyTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__DerivedKeyTokenType(soap, tag ? tag : "wsc:DerivedKeyTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_get_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__DerivedKeyTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Identifier);
	soap_default_string(soap, &a->Instance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_serialize_string(soap, (char*const*)&a->Instance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, const struct wsc__SecurityContextTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__SecurityContextTokenType), type))
		return soap->error;
	if (soap_out_string(soap, "wsc:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Instance", -1, (char*const*)&a->Instance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_in_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Instance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__SecurityContextTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__SecurityContextTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Instance", (char**)&a->Instance, "xsd:string"))
				{	soap_flag_Instance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__SecurityContextTokenType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__SecurityContextTokenType *p;
	size_t k = sizeof(struct wsc__SecurityContextTokenType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsc__SecurityContextTokenType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsc__SecurityContextTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsc__SecurityContextTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__SecurityContextTokenType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__SecurityContextTokenType(soap, tag ? tag : "wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_get_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __xenc__union_ReferenceList*)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___xenc__union_ReferenceList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __xenc__union_ReferenceList *p;
	size_t k = sizeof(struct __xenc__union_ReferenceList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___xenc__union_ReferenceList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __xenc__union_ReferenceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __xenc__union_ReferenceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __xenc__union_ReferenceList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out___xenc__union_ReferenceList(soap, tag ? tag : "-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _xenc__ReferenceList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_alloc_block(soap);
					a->__union_ReferenceList = soap_block<struct __xenc__union_ReferenceList>::push(soap, soap_blist___union_ReferenceList);
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_block<struct __xenc__union_ReferenceList>::pop(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
		{	a->__union_ReferenceList = soap_new___xenc__union_ReferenceList(soap, a->__size_ReferenceList);
			if (!a->__union_ReferenceList)
				return NULL;
			soap_block<struct __xenc__union_ReferenceList>::save(soap, soap_blist___union_ReferenceList, a->__union_ReferenceList);
		}
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_block<struct __xenc__union_ReferenceList>::end(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xenc__ReferenceList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _xenc__ReferenceList *p;
	size_t k = sizeof(struct _xenc__ReferenceList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__xenc__ReferenceList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _xenc__ReferenceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _xenc__ReferenceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _xenc__ReferenceList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out__xenc__ReferenceList(soap, tag ? tag : "xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", soap_string2s(soap, a->Target), 1);
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionPropertyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 1, 0), &a->Target))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionPropertyType *p;
	size_t k = sizeof(struct xenc__EncryptionPropertyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptionPropertyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptionPropertyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptionPropertyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionPropertyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertyType(soap, tag ? tag : "xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionPropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_alloc_block(soap);
					a->EncryptionProperty = soap_block<struct xenc__EncryptionPropertyType>::push(soap, soap_blist_EncryptionProperty);
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_block<struct xenc__EncryptionPropertyType>::pop(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
		{	a->EncryptionProperty = soap_new_xenc__EncryptionPropertyType(soap, a->__sizeEncryptionProperty);
			if (!a->EncryptionProperty)
				return NULL;
			soap_block<struct xenc__EncryptionPropertyType>::save(soap, soap_blist_EncryptionProperty, a->EncryptionProperty);
		}
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_block<struct xenc__EncryptionPropertyType>::end(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionPropertiesType *p;
	size_t k = sizeof(struct xenc__EncryptionPropertiesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptionPropertiesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptionPropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptionPropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionPropertiesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag ? tag : "xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	soap_set_attr(soap, "URI", a->URI ? soap_string2s(soap, a->URI) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__ReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 1), &a->URI))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__ReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__ReferenceType *p;
	size_t k = sizeof(struct xenc__ReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__ReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__ReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__ReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__ReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__ReferenceType(soap, tag ? tag : "xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, (char*const*)&a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__AgreementMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:KA-Nonce", (char**)&a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__AgreementMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__AgreementMethodType *p;
	size_t k = sizeof(struct xenc__AgreementMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__AgreementMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__AgreementMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__AgreementMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__AgreementMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__AgreementMethodType(soap, tag ? tag : "xenc:AgreementMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData"))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedDataType *p;
	size_t k = sizeof(struct xenc__EncryptedDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptedDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptedDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptedDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedDataType(soap, tag ? tag : "xenc:EncryptedDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__TransformsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__TransformsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__TransformsType *p;
	size_t k = sizeof(struct xenc__TransformsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__TransformsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__TransformsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__TransformsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__TransformsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__TransformsType(soap, tag ? tag : "xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	soap_set_attr(soap, "URI", a->URI ? soap_string2s(soap, a->URI) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__CipherReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 1), &a->URI))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__CipherReferenceType *p;
	size_t k = sizeof(struct xenc__CipherReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__CipherReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__CipherReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__CipherReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__CipherReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherReferenceType(soap, tag ? tag : "xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, (char*const*)&a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__CipherDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:CipherValue", (char**)&a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__CipherDataType *p;
	size_t k = sizeof(struct xenc__CipherDataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__CipherDataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__CipherDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__CipherDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__CipherDataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherDataType(soap, tag ? tag : "xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->ds__DigestMethod = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, (char*const*)&a->OAEPparams);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->ds__DigestMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, (char*const*)&a->OAEPparams, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->ds__DigestMethod, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag_ds__DigestMethod = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:OAEPparams", (char**)&a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			}
			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->ds__DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_ds__DigestMethod--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionMethodType *p;
	size_t k = sizeof(struct xenc__EncryptionMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptionMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptionMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptionMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionMethodType(soap, tag ? tag : "xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData"))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedType *p;
	size_t k = sizeof(struct xenc__EncryptedType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptedType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptedType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptedType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedType(soap, tag ? tag : "xenc:EncryptedType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Modulus);
	soap_serialize_string(soap, (char*const*)&a->Exponent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (!a->Modulus)
	{	if (soap_element_empty(soap, "ds:Modulus"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Modulus", -1, (char*const*)&a->Modulus, ""))
		return soap->error;
	if (!a->Exponent)
	{	if (soap_element_empty(soap, "ds:Exponent"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Exponent", -1, (char*const*)&a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__RSAKeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Modulus", (char**)&a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Exponent", (char**)&a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Modulus || !a->Exponent))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RSAKeyValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__RSAKeyValueType *p;
	size_t k = sizeof(struct ds__RSAKeyValueType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__RSAKeyValueType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__RSAKeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__RSAKeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__RSAKeyValueType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RSAKeyValueType(soap, tag ? tag : "ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->G);
	soap_serialize_string(soap, (char*const*)&a->Y);
	soap_serialize_string(soap, (char*const*)&a->J);
	soap_serialize_string(soap, (char*const*)&a->P);
	soap_serialize_string(soap, (char*const*)&a->Q);
	soap_serialize_string(soap, (char*const*)&a->Seed);
	soap_serialize_string(soap, (char*const*)&a->PgenCounter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, (char*const*)&a->G, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_empty(soap, "ds:Y"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Y", -1, (char*const*)&a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, (char*const*)&a->J, ""))
		return soap->error;
	if (!a->P)
	{	if (soap_element_empty(soap, "ds:P"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:P", -1, (char*const*)&a->P, ""))
		return soap->error;
	if (!a->Q)
	{	if (soap_element_empty(soap, "ds:Q"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Q", -1, (char*const*)&a->Q, ""))
		return soap->error;
	if (!a->Seed)
	{	if (soap_element_empty(soap, "ds:Seed"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Seed", -1, (char*const*)&a->Seed, ""))
		return soap->error;
	if (!a->PgenCounter)
	{	if (soap_element_empty(soap, "ds:PgenCounter"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:PgenCounter", -1, (char*const*)&a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__DSAKeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:G", (char**)&a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Y", (char**)&a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:J", (char**)&a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:P", (char**)&a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Q", (char**)&a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Seed", (char**)&a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:PgenCounter", (char**)&a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Y || !a->P || !a->Q || !a->Seed || !a->PgenCounter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DSAKeyValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__DSAKeyValueType *p;
	size_t k = sizeof(struct ds__DSAKeyValueType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__DSAKeyValueType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__DSAKeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__DSAKeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__DSAKeyValueType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DSAKeyValueType(soap, tag ? tag : "ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_string(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->X509IssuerName);
	soap_serialize_string(soap, (char*const*)&a->X509SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (!a->X509IssuerName)
	{	if (soap_element_empty(soap, "ds:X509IssuerName"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:X509IssuerName", -1, (char*const*)&a->X509IssuerName, ""))
		return soap->error;
	if (!a->X509SerialNumber)
	{	if (soap_element_empty(soap, "ds:X509SerialNumber"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:X509SerialNumber", -1, (char*const*)&a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__X509IssuerSerialType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509IssuerName", (char**)&a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			}
			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SerialNumber", (char**)&a->X509SerialNumber, "xsd:string"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->X509IssuerName || !a->X509SerialNumber))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509IssuerSerialType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__X509IssuerSerialType *p;
	size_t k = sizeof(struct ds__X509IssuerSerialType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__X509IssuerSerialType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__X509IssuerSerialType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__X509IssuerSerialType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__X509IssuerSerialType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509IssuerSerialType(soap, tag ? tag : "ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__KeyInfo(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	if (soap_out__ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__RetrievalMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RetrievalMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__RetrievalMethodType *p;
	size_t k = sizeof(struct ds__RetrievalMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__RetrievalMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__RetrievalMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__RetrievalMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__RetrievalMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RetrievalMethodType(soap, tag ? tag : "ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__KeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__KeyValueType *p;
	size_t k = sizeof(struct ds__KeyValueType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__KeyValueType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__KeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__KeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__KeyValueType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyValueType(soap, tag ? tag : "ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__DigestMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DigestMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__DigestMethodType *p;
	size_t k = sizeof(struct ds__DigestMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__DigestMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__DigestMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__DigestMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__DigestMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DigestMethodType(soap, tag ? tag : "ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__Transform(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out__ds__Transform(soap, tag ? tag : "ds:Transform", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__TransformType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 0), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__TransformType *p;
	size_t k = sizeof(struct ds__TransformType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__TransformType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__TransformType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__TransformType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__TransformType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformType(soap, tag ? tag : "ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", soap_string2s(soap, a->PrefixList), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _c14n__InclusiveNamespaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 1, 0), &a->PrefixList))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__c14n__InclusiveNamespaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _c14n__InclusiveNamespaces *p;
	size_t k = sizeof(struct _c14n__InclusiveNamespaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__c14n__InclusiveNamespaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _c14n__InclusiveNamespaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _c14n__InclusiveNamespaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _c14n__InclusiveNamespaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	if (soap_out__c14n__InclusiveNamespaces(soap, tag ? tag : "c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__TransformsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_alloc_block(soap);
					a->Transform = soap_block<struct ds__TransformType>::push(soap, soap_blist_Transform);
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_block<struct ds__TransformType>::pop(soap, soap_blist_Transform);
		if (a->__sizeTransform)
		{	a->Transform = soap_new_ds__TransformType(soap, a->__sizeTransform);
			if (!a->Transform)
				return NULL;
			soap_block<struct ds__TransformType>::save(soap, soap_blist_Transform, a->Transform);
		}
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_block<struct ds__TransformType>::end(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__TransformsType *p;
	size_t k = sizeof(struct ds__TransformsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__TransformsType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__TransformsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__TransformsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__TransformsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformsType(soap, tag ? tag : "ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, (char*const*)&a->DigestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (!a->DigestMethod)
	{	if (soap_element_empty(soap, "ds:DigestMethod"))
			return soap->error;
	}
	else if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (!a->DigestValue)
	{	if (soap_element_empty(soap, "ds:DigestValue"))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:DigestValue", -1, (char*const*)&a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__ReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:DigestValue", (char**)&a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DigestMethod || !a->DigestValue))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__ReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__ReferenceType *p;
	size_t k = sizeof(struct ds__ReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__ReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__ReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__ReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__ReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_ds__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignatureMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignatureMethodType *p;
	size_t k = sizeof(struct ds__SignatureMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__SignatureMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__SignatureMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__SignatureMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignatureMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureMethodType(soap, tag ? tag : "ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__CanonicalizationMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__CanonicalizationMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__CanonicalizationMethodType *p;
	size_t k = sizeof(struct ds__CanonicalizationMethodType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__CanonicalizationMethodType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__CanonicalizationMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__CanonicalizationMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__CanonicalizationMethodType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__CanonicalizationMethodType(soap, tag ? tag : "ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__Signature(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	if (soap_out__ds__Signature(soap, tag ? tag : "ds:Signature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (!a->CanonicalizationMethod)
	{	if (soap_element_empty(soap, "ds:CanonicalizationMethod"))
			return soap->error;
	}
	else if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (!a->SignatureMethod)
	{	if (soap_element_empty(soap, "ds:SignatureMethod"))
			return soap->error;
	}
	else if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignedInfoType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_alloc_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block_max(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
		{	a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		}
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CanonicalizationMethod || !a->SignatureMethod))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignedInfoType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignedInfoType *p;
	size_t k = sizeof(struct ds__SignedInfoType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__SignedInfoType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__SignedInfoType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__SignedInfoType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignedInfoType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignedInfoType(soap, tag ? tag : "ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default__ds__SignatureValue(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize__ds__SignatureValue(soap, (char*const*)&a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out__ds__SignatureValue(soap, "ds:SignatureValue", -1, (char*const*)&a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignatureType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__ds__SignatureValue(soap, "ds:SignatureValue", (char**)&a->SignatureValue, ""))
				{	soap_flag_SignatureValue--;
					continue;
				}
			}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignatureType *p;
	size_t k = sizeof(struct ds__SignatureType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__SignatureType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__SignatureType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__SignatureType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignatureType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureType(soap, tag ? tag : "ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, (char*const*)&a->CarriedKeyName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData"))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, (char*const*)&a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedKeyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 1, 0), &a->Recipient))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:CarriedKeyName", (char**)&a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedKeyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedKeyType *p;
	size_t k = sizeof(struct xenc__EncryptedKeyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xenc__EncryptedKeyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct xenc__EncryptedKeyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct xenc__EncryptedKeyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedKeyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->xenc__EncryptedKey = NULL;
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_string(soap, (char*const*)&a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, (char*const*)&a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__KeyInfoType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			}
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:KeyName", (char**)&a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyInfoType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__KeyInfoType *p;
	size_t k = sizeof(struct ds__KeyInfoType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__KeyInfoType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__KeyInfoType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__KeyInfoType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__KeyInfoType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyInfoType(soap, tag ? tag : "ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, (char*const*)&a->X509SKI);
	soap_serialize_string(soap, (char*const*)&a->X509SubjectName);
	soap_serialize_string(soap, (char*const*)&a->X509Certificate);
	soap_serialize_string(soap, (char*const*)&a->X509CRL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, (char*const*)&a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, (char*const*)&a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, (char*const*)&a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, (char*const*)&a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__X509DataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SKI", (char**)&a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SubjectName", (char**)&a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509Certificate", (char**)&a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509CRL", (char**)&a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509DataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__X509DataType *p;
	size_t k = sizeof(struct ds__X509DataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ds__X509DataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ds__X509DataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ds__X509DataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__X509DataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509DataType(soap, tag ? tag : "ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	a->ds__X509Data = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->wsc__Instance);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
	soap_serialize_PointerTods__X509DataType(soap, &a->ds__X509Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->wsc__Instance)
		soap_set_attr(soap, "wsc:Instance", soap_string2s(soap, a->wsc__Instance), 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", soap_string2s(soap, a->Usage), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->ds__X509Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	size_t soap_flag_ds__X509Data = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__SecurityTokenReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsc:Instance", 1, 0), &a->wsc__Instance))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 1, 0), &a->Usage))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			}
			if (soap_flag_ds__X509Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->ds__X509Data, "ds:X509DataType"))
				{	soap_flag_ds__X509Data--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__SecurityTokenReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__SecurityTokenReference *p;
	size_t k = sizeof(struct _wsse__SecurityTokenReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__SecurityTokenReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__SecurityTokenReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__SecurityTokenReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__SecurityTokenReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__SecurityTokenReference(soap, tag ? tag : "wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__KeyIdentifier(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__KeyIdentifier *p;
	size_t k = sizeof(struct _wsse__KeyIdentifier);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__KeyIdentifier, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__KeyIdentifier);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__KeyIdentifier, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__KeyIdentifier location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	if (soap_out__wsse__KeyIdentifier(soap, tag ? tag : "wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Embedded*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Embedded(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Embedded *p;
	size_t k = sizeof(struct _wsse__Embedded);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Embedded, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Embedded);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Embedded, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Embedded location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Embedded(soap, tag ? tag : "wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Reference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Reference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Reference *p;
	size_t k = sizeof(struct _wsse__Reference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Reference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Reference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Reference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Reference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Reference(soap, tag ? tag : "wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__BinarySecurityToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__BinarySecurityToken *p;
	size_t k = sizeof(struct _wsse__BinarySecurityToken);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__BinarySecurityToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__BinarySecurityToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__BinarySecurityToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__BinarySecurityToken location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__BinarySecurityToken(soap, tag ? tag : "wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Password(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Password *p;
	size_t k = sizeof(struct _wsse__Password);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__Password, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__Password);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__Password, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Password location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Password(soap, tag ? tag : "wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	a->Nonce = NULL;
	soap_default_string(soap, &a->Salt);
	a->Iteration = NULL;
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_PointerTowsse__EncodedString(soap, &a->Nonce);
	soap_serialize_string(soap, (char*const*)&a->Salt);
	soap_serialize_PointerTounsignedInt(soap, &a->Iteration);
	soap_serialize_string(soap, (char*const*)&a->wsu__Created);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_PointerTowsse__EncodedString(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Salt", -1, (char*const*)&a->Salt, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsse:Iteration", -1, &a->Iteration, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_Salt = 1;
	size_t soap_flag_Iteration = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__UsernameToken*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsse:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_Nonce && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsse__EncodedString(soap, "wsse:Nonce", &a->Nonce, "wsse:EncodedString"))
				{	soap_flag_Nonce--;
					continue;
				}
			}
			if (soap_flag_Salt && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsse:Salt", (char**)&a->Salt, "xsd:string"))
				{	soap_flag_Salt--;
					continue;
				}
			}
			if (soap_flag_Iteration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wsse:Iteration", &a->Iteration, "xsd:unsignedInt"))
				{	soap_flag_Iteration--;
					continue;
				}
			}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Created", (char**)&a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__UsernameToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__UsernameToken *p;
	size_t k = sizeof(struct _wsse__UsernameToken);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsse__UsernameToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsse__UsernameToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsse__UsernameToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__UsernameToken location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__UsernameToken(soap, tag ? tag : "wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->EncodingType);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__EncodedString(struct soap *soap, const char *tag, int id, const struct wsse__EncodedString *a, const char *type)
{
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_in_wsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsse__EncodedString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsse__EncodedString(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsse:EncodedString"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsse__EncodedString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsse__EncodedString *p;
	size_t k = sizeof(struct wsse__EncodedString);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsse__EncodedString, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsse__EncodedString);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsse__EncodedString, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsse__EncodedString location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a, const char *tag, const char *type)
{
	if (soap_out_wsse__EncodedString(soap, tag ? tag : "wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_get_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Created);
	soap_serialize_string(soap, (char*const*)&a->Expires);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, (char*const*)&a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsu__Timestamp*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Created", (char**)&a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Expires", (char**)&a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsu__Timestamp(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsu__Timestamp *p;
	size_t k = sizeof(struct _wsu__Timestamp);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsu__Timestamp, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _wsu__Timestamp);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _wsu__Timestamp, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsu__Timestamp location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	if (soap_out__wsu__Timestamp(soap, tag ? tag : "wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCertificateWithPin(struct soap *soap, struct __ns1__GetCertificateWithPin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetCertificateWithPin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCertificateWithPin(struct soap *soap, const struct __ns1__GetCertificateWithPin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__GetCertificateWithPin(soap, &a->ns3__GetCertificateWithPin);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCertificateWithPin(struct soap *soap, const char *tag, int id, const struct __ns1__GetCertificateWithPin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__GetCertificateWithPin(soap, "ns3:GetCertificateWithPin", -1, &a->ns3__GetCertificateWithPin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCertificateWithPin * SOAP_FMAC4 soap_in___ns1__GetCertificateWithPin(struct soap *soap, const char *tag, struct __ns1__GetCertificateWithPin *a, const char *type)
{
	size_t soap_flag_ns3__GetCertificateWithPin = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetCertificateWithPin*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCertificateWithPin, sizeof(struct __ns1__GetCertificateWithPin), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCertificateWithPin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetCertificateWithPin && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__GetCertificateWithPin(soap, "ns3:GetCertificateWithPin", &a->ns3__GetCertificateWithPin, ""))
				{	soap_flag_ns3__GetCertificateWithPin--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetCertificateWithPin * SOAP_FMAC2 soap_instantiate___ns1__GetCertificateWithPin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCertificateWithPin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetCertificateWithPin *p;
	size_t k = sizeof(struct __ns1__GetCertificateWithPin);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetCertificateWithPin, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetCertificateWithPin);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetCertificateWithPin, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetCertificateWithPin location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCertificateWithPin(struct soap *soap, const struct __ns1__GetCertificateWithPin *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetCertificateWithPin(soap, tag ? tag : "-ns1:GetCertificateWithPin", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCertificateWithPin * SOAP_FMAC4 soap_get___ns1__GetCertificateWithPin(struct soap *soap, struct __ns1__GetCertificateWithPin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCertificateWithPin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ForceSMS(struct soap *soap, struct __ns1__ForceSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__ForceSMS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ForceSMS(struct soap *soap, const struct __ns1__ForceSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__ForceSMS(soap, &a->ns3__ForceSMS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ForceSMS(struct soap *soap, const char *tag, int id, const struct __ns1__ForceSMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__ForceSMS(soap, "ns3:ForceSMS", -1, &a->ns3__ForceSMS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ForceSMS * SOAP_FMAC4 soap_in___ns1__ForceSMS(struct soap *soap, const char *tag, struct __ns1__ForceSMS *a, const char *type)
{
	size_t soap_flag_ns3__ForceSMS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ForceSMS*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ForceSMS, sizeof(struct __ns1__ForceSMS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ForceSMS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__ForceSMS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__ForceSMS(soap, "ns3:ForceSMS", &a->ns3__ForceSMS, ""))
				{	soap_flag_ns3__ForceSMS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ForceSMS * SOAP_FMAC2 soap_instantiate___ns1__ForceSMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ForceSMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ForceSMS *p;
	size_t k = sizeof(struct __ns1__ForceSMS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ForceSMS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ForceSMS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ForceSMS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ForceSMS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ForceSMS(struct soap *soap, const struct __ns1__ForceSMS *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ForceSMS(soap, tag ? tag : "-ns1:ForceSMS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ForceSMS * SOAP_FMAC4 soap_get___ns1__ForceSMS(struct soap *soap, struct __ns1__ForceSMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ForceSMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CCMovelMultipleSign(struct soap *soap, struct __ns1__CCMovelMultipleSign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CCMovelMultipleSign = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CCMovelMultipleSign(struct soap *soap, const struct __ns1__CCMovelMultipleSign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__CCMovelMultipleSign(soap, &a->ns3__CCMovelMultipleSign);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CCMovelMultipleSign(struct soap *soap, const char *tag, int id, const struct __ns1__CCMovelMultipleSign *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__CCMovelMultipleSign(soap, "ns3:CCMovelMultipleSign", -1, &a->ns3__CCMovelMultipleSign, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCMovelMultipleSign * SOAP_FMAC4 soap_in___ns1__CCMovelMultipleSign(struct soap *soap, const char *tag, struct __ns1__CCMovelMultipleSign *a, const char *type)
{
	size_t soap_flag_ns3__CCMovelMultipleSign = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CCMovelMultipleSign*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CCMovelMultipleSign, sizeof(struct __ns1__CCMovelMultipleSign), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CCMovelMultipleSign(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CCMovelMultipleSign && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__CCMovelMultipleSign(soap, "ns3:CCMovelMultipleSign", &a->ns3__CCMovelMultipleSign, ""))
				{	soap_flag_ns3__CCMovelMultipleSign--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CCMovelMultipleSign * SOAP_FMAC2 soap_instantiate___ns1__CCMovelMultipleSign(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CCMovelMultipleSign(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CCMovelMultipleSign *p;
	size_t k = sizeof(struct __ns1__CCMovelMultipleSign);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CCMovelMultipleSign, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CCMovelMultipleSign);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CCMovelMultipleSign, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CCMovelMultipleSign location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CCMovelMultipleSign(struct soap *soap, const struct __ns1__CCMovelMultipleSign *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CCMovelMultipleSign(soap, tag ? tag : "-ns1:CCMovelMultipleSign", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCMovelMultipleSign * SOAP_FMAC4 soap_get___ns1__CCMovelMultipleSign(struct soap *soap, struct __ns1__CCMovelMultipleSign *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CCMovelMultipleSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ValidateOtp(struct soap *soap, struct __ns1__ValidateOtp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__ValidateOtp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ValidateOtp(struct soap *soap, const struct __ns1__ValidateOtp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__ValidateOtp(soap, &a->ns3__ValidateOtp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ValidateOtp(struct soap *soap, const char *tag, int id, const struct __ns1__ValidateOtp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__ValidateOtp(soap, "ns3:ValidateOtp", -1, &a->ns3__ValidateOtp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateOtp * SOAP_FMAC4 soap_in___ns1__ValidateOtp(struct soap *soap, const char *tag, struct __ns1__ValidateOtp *a, const char *type)
{
	size_t soap_flag_ns3__ValidateOtp = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ValidateOtp*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ValidateOtp, sizeof(struct __ns1__ValidateOtp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ValidateOtp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__ValidateOtp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__ValidateOtp(soap, "ns3:ValidateOtp", &a->ns3__ValidateOtp, ""))
				{	soap_flag_ns3__ValidateOtp--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ValidateOtp * SOAP_FMAC2 soap_instantiate___ns1__ValidateOtp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ValidateOtp(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ValidateOtp *p;
	size_t k = sizeof(struct __ns1__ValidateOtp);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ValidateOtp, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ValidateOtp);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ValidateOtp, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ValidateOtp location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ValidateOtp(struct soap *soap, const struct __ns1__ValidateOtp *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ValidateOtp(soap, tag ? tag : "-ns1:ValidateOtp", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateOtp * SOAP_FMAC4 soap_get___ns1__ValidateOtp(struct soap *soap, struct __ns1__ValidateOtp *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ValidateOtp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCertificate(struct soap *soap, struct __ns1__GetCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCertificate(struct soap *soap, const struct __ns1__GetCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__GetCertificate(soap, &a->ns3__GetCertificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCertificate(struct soap *soap, const char *tag, int id, const struct __ns1__GetCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__GetCertificate(soap, "ns3:GetCertificate", -1, &a->ns3__GetCertificate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCertificate * SOAP_FMAC4 soap_in___ns1__GetCertificate(struct soap *soap, const char *tag, struct __ns1__GetCertificate *a, const char *type)
{
	size_t soap_flag_ns3__GetCertificate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetCertificate*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCertificate, sizeof(struct __ns1__GetCertificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCertificate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetCertificate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__GetCertificate(soap, "ns3:GetCertificate", &a->ns3__GetCertificate, ""))
				{	soap_flag_ns3__GetCertificate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetCertificate * SOAP_FMAC2 soap_instantiate___ns1__GetCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCertificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetCertificate *p;
	size_t k = sizeof(struct __ns1__GetCertificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetCertificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetCertificate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetCertificate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetCertificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCertificate(struct soap *soap, const struct __ns1__GetCertificate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetCertificate(soap, tag ? tag : "-ns1:GetCertificate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCertificate * SOAP_FMAC4 soap_get___ns1__GetCertificate(struct soap *soap, struct __ns1__GetCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CCMovelSign(struct soap *soap, struct __ns1__CCMovelSign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CCMovelSign = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CCMovelSign(struct soap *soap, const struct __ns1__CCMovelSign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__CCMovelSign(soap, &a->ns3__CCMovelSign);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CCMovelSign(struct soap *soap, const char *tag, int id, const struct __ns1__CCMovelSign *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__CCMovelSign(soap, "ns3:CCMovelSign", -1, &a->ns3__CCMovelSign, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCMovelSign * SOAP_FMAC4 soap_in___ns1__CCMovelSign(struct soap *soap, const char *tag, struct __ns1__CCMovelSign *a, const char *type)
{
	size_t soap_flag_ns3__CCMovelSign = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CCMovelSign*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CCMovelSign, sizeof(struct __ns1__CCMovelSign), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CCMovelSign(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CCMovelSign && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__CCMovelSign(soap, "ns3:CCMovelSign", &a->ns3__CCMovelSign, ""))
				{	soap_flag_ns3__CCMovelSign--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CCMovelSign * SOAP_FMAC2 soap_instantiate___ns1__CCMovelSign(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CCMovelSign(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CCMovelSign *p;
	size_t k = sizeof(struct __ns1__CCMovelSign);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CCMovelSign, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CCMovelSign);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CCMovelSign, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CCMovelSign location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CCMovelSign(struct soap *soap, const struct __ns1__CCMovelSign *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CCMovelSign(soap, tag ? tag : "-ns1:CCMovelSign", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CCMovelSign * SOAP_FMAC4 soap_get___ns1__CCMovelSign(struct soap *soap, struct __ns1__CCMovelSign *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CCMovelSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		soap_embedded(soap, &a->Generation, SOAP_TYPE_ULONG64);
		break;
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		soap_embedded(soap, &a->Offset, SOAP_TYPE_ULONG64);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		return soap_out_ULONG64(soap, "wsc:Generation", -1, &a->Generation, "");
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		return soap_out_ULONG64(soap, "wsc:Offset", -1, &a->Offset, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wsc__union_DerivedKeyTokenType * SOAP_FMAC4 soap_in__wsc__union_DerivedKeyTokenType(struct soap *soap, int *choice, union _wsc__union_DerivedKeyTokenType *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Security(soap, tag ? tag : "wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureType(soap, tag ? tag : "ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__SecurityContextTokenType))
		soap_serialize_wsc__SecurityContextTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, struct wsc__SecurityContextTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__SecurityContextTokenType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__SecurityContextTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_in_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__SecurityContextTokenType **)soap_malloc(soap, sizeof(struct wsc__SecurityContextTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__SecurityContextTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, tag ? tag : "wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_get_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag ? tag : "wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag ? tag : "wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag ? tag : "wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthenticatingAuthority(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthenticatingAuthority(soap, tag ? tag : "saml2:AuthenticatingAuthority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContextDeclRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContextDeclRef(soap, tag ? tag : "saml2:AuthnContextDeclRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContextClassRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContextClassRef(soap, tag ? tag : "saml2:AuthnContextClassRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Audience(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__Audience(soap, tag ? tag : "saml2:Audience", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AssertionURIRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AssertionURIRef(soap, tag ? tag : "saml2:AssertionURIRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AssertionIDRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AssertionIDRef(soap, tag ? tag : "saml2:AssertionIDRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ds__KeyInfo))
		soap_serialize_PointerTo_ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ds__KeyInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType *** SOAP_FMAC4 soap_in_PointerToPointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType ***)soap_malloc(soap, sizeof(struct ds__KeyInfoType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType *** SOAP_FMAC4 soap_get_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AttributeStatementType))
		soap_serialize___saml2__union_AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, const char *tag, int id, struct __saml2__union_AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, const char *tag, struct __saml2__union_AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AttributeStatementType **)soap_malloc(soap, sizeof(struct __saml2__union_AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AttributeStatementType(soap, tag ? tag : "-saml2:union-AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AttributeType))
		soap_serialize_saml2__AttributeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AttributeType(struct soap *soap, const char *tag, int id, struct saml2__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AttributeType ** SOAP_FMAC4 soap_in_PointerTosaml2__AttributeType(struct soap *soap, const char *tag, struct saml2__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AttributeType **)soap_malloc(soap, sizeof(struct saml2__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AttributeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AttributeType(soap, tag ? tag : "saml2:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeType ** SOAP_FMAC4 soap_get_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__EvidenceType))
		soap_serialize_saml2__EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__EvidenceType(struct soap *soap, const char *tag, int id, struct saml2__EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__EvidenceType ** SOAP_FMAC4 soap_in_PointerTosaml2__EvidenceType(struct soap *soap, const char *tag, struct saml2__EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__EvidenceType **)soap_malloc(soap, sizeof(struct saml2__EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__EvidenceType(soap, tag ? tag : "saml2:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EvidenceType ** SOAP_FMAC4 soap_get_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ActionType))
		soap_serialize_saml2__ActionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ActionType(struct soap *soap, const char *tag, int id, struct saml2__ActionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ActionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ActionType ** SOAP_FMAC4 soap_in_PointerTosaml2__ActionType(struct soap *soap, const char *tag, struct saml2__ActionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ActionType **)soap_malloc(soap, sizeof(struct saml2__ActionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ActionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ActionType(soap, tag ? tag : "saml2:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ActionType ** SOAP_FMAC4 soap_get_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthnContextType))
		soap_serialize_saml2__AuthnContextType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthnContextType(struct soap *soap, const char *tag, int id, struct saml2__AuthnContextType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthnContextType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthnContextType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthnContextType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthnContextType(struct soap *soap, const char *tag, struct saml2__AuthnContextType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthnContextType **)soap_malloc(soap, sizeof(struct saml2__AuthnContextType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthnContextType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnContextType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthnContextType(soap, tag ? tag : "saml2:AuthnContextType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnContextType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthnContextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectLocalityType))
		soap_serialize_saml2__SubjectLocalityType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectLocalityType(struct soap *soap, const char *tag, int id, struct saml2__SubjectLocalityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectLocalityType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectLocalityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectLocalityType(struct soap *soap, const char *tag, struct saml2__SubjectLocalityType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectLocalityType **)soap_malloc(soap, sizeof(struct saml2__SubjectLocalityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectLocalityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectLocalityType(soap, tag ? tag : "saml2:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_EvidenceType))
		soap_serialize___saml2__union_EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_EvidenceType(struct soap *soap, const char *tag, int id, struct __saml2__union_EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_EvidenceType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_EvidenceType(struct soap *soap, const char *tag, struct __saml2__union_EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_EvidenceType **)soap_malloc(soap, sizeof(struct __saml2__union_EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_EvidenceType(soap, tag ? tag : "-saml2:union-EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_EvidenceType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AdviceType))
		soap_serialize___saml2__union_AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AdviceType(struct soap *soap, const char *tag, int id, struct __saml2__union_AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AdviceType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AdviceType(struct soap *soap, const char *tag, struct __saml2__union_AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AdviceType **)soap_malloc(soap, sizeof(struct __saml2__union_AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AdviceType(soap, tag ? tag : "-saml2:union-AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AdviceType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AssertionType))
		soap_serialize_saml2__AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AssertionType(struct soap *soap, const char *tag, int id, struct saml2__AssertionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AssertionType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_saml2__AssertionType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct saml2__AssertionType ** SOAP_FMAC4 soap_in_PointerTosaml2__AssertionType(struct soap *soap, const char *tag, struct saml2__AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AssertionType **)soap_malloc(soap, sizeof(struct saml2__AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AssertionType(soap, tag ? tag : "saml2:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AssertionType ** SOAP_FMAC4 soap_get_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_ConditionsType))
		soap_serialize___saml2__union_ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_ConditionsType(struct soap *soap, const char *tag, int id, struct __saml2__union_ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_ConditionsType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_ConditionsType(struct soap *soap, const char *tag, struct __saml2__union_ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_ConditionsType **)soap_malloc(soap, sizeof(struct __saml2__union_ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_ConditionsType(soap, tag ? tag : "-saml2:union-ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_ConditionsType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ProxyRestrictionType))
		soap_serialize_saml2__ProxyRestrictionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ProxyRestrictionType(struct soap *soap, const char *tag, int id, struct saml2__ProxyRestrictionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ProxyRestrictionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ProxyRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType ** SOAP_FMAC4 soap_in_PointerTosaml2__ProxyRestrictionType(struct soap *soap, const char *tag, struct saml2__ProxyRestrictionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ProxyRestrictionType **)soap_malloc(soap, sizeof(struct saml2__ProxyRestrictionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ProxyRestrictionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ProxyRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ProxyRestrictionType(soap, tag ? tag : "saml2:ProxyRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType ** SOAP_FMAC4 soap_get_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ProxyRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__OneTimeUseType))
		soap_serialize_saml2__OneTimeUseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__OneTimeUseType(struct soap *soap, const char *tag, int id, struct saml2__OneTimeUseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__OneTimeUseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__OneTimeUseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__OneTimeUseType ** SOAP_FMAC4 soap_in_PointerTosaml2__OneTimeUseType(struct soap *soap, const char *tag, struct saml2__OneTimeUseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__OneTimeUseType **)soap_malloc(soap, sizeof(struct saml2__OneTimeUseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__OneTimeUseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__OneTimeUseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__OneTimeUseType(soap, tag ? tag : "saml2:OneTimeUseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__OneTimeUseType ** SOAP_FMAC4 soap_get_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__OneTimeUseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AudienceRestrictionType))
		soap_serialize_saml2__AudienceRestrictionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AudienceRestrictionType(struct soap *soap, const char *tag, int id, struct saml2__AudienceRestrictionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AudienceRestrictionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AudienceRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType ** SOAP_FMAC4 soap_in_PointerTosaml2__AudienceRestrictionType(struct soap *soap, const char *tag, struct saml2__AudienceRestrictionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AudienceRestrictionType **)soap_malloc(soap, sizeof(struct saml2__AudienceRestrictionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AudienceRestrictionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AudienceRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AudienceRestrictionType(soap, tag ? tag : "saml2:AudienceRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType ** SOAP_FMAC4 soap_get_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AudienceRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ConditionAbstractType))
		soap_serialize_saml2__ConditionAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ConditionAbstractType(struct soap *soap, const char *tag, int id, struct saml2__ConditionAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ConditionAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ConditionAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__ConditionAbstractType(struct soap *soap, const char *tag, struct saml2__ConditionAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ConditionAbstractType **)soap_malloc(soap, sizeof(struct saml2__ConditionAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ConditionAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ConditionAbstractType(soap, tag ? tag : "saml2:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectConfirmationDataType))
		soap_serialize_saml2__SubjectConfirmationDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, struct saml2__SubjectConfirmationDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectConfirmationDataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectConfirmationDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectConfirmationDataType **)soap_malloc(soap, sizeof(struct saml2__SubjectConfirmationDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectConfirmationDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, tag ? tag : "saml2:SubjectConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectConfirmationType))
		soap_serialize_saml2__SubjectConfirmationType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct saml2__SubjectConfirmationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectConfirmationType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectConfirmationType **)soap_malloc(soap, sizeof(struct saml2__SubjectConfirmationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectConfirmationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectConfirmationType(soap, tag ? tag : "saml2:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__EncryptedElementType))
		soap_serialize_saml2__EncryptedElementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__EncryptedElementType(struct soap *soap, const char *tag, int id, struct saml2__EncryptedElementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__EncryptedElementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__EncryptedElementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__EncryptedElementType ** SOAP_FMAC4 soap_in_PointerTosaml2__EncryptedElementType(struct soap *soap, const char *tag, struct saml2__EncryptedElementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__EncryptedElementType **)soap_malloc(soap, sizeof(struct saml2__EncryptedElementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__EncryptedElementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__EncryptedElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, tag ? tag : "saml2:EncryptedElementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EncryptedElementType ** SOAP_FMAC4 soap_get_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__EncryptedElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__BaseIDAbstractType))
		soap_serialize_saml2__BaseIDAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__BaseIDAbstractType(struct soap *soap, const char *tag, int id, struct saml2__BaseIDAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__BaseIDAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__BaseIDAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__BaseIDAbstractType(struct soap *soap, const char *tag, struct saml2__BaseIDAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__BaseIDAbstractType **)soap_malloc(soap, sizeof(struct saml2__BaseIDAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__BaseIDAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__BaseIDAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, tag ? tag : "saml2:BaseIDAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__BaseIDAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AssertionType))
		soap_serialize___saml2__union_AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AssertionType(struct soap *soap, const char *tag, int id, struct __saml2__union_AssertionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AssertionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AssertionType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AssertionType(struct soap *soap, const char *tag, struct __saml2__union_AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AssertionType **)soap_malloc(soap, sizeof(struct __saml2__union_AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AssertionType(soap, tag ? tag : "-saml2:union-AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AssertionType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AttributeStatementType))
		soap_serialize_saml2__AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AttributeStatementType(struct soap *soap, const char *tag, int id, struct saml2__AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AttributeStatementType(struct soap *soap, const char *tag, struct saml2__AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AttributeStatementType **)soap_malloc(soap, sizeof(struct saml2__AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AttributeStatementType(soap, tag ? tag : "saml2:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthzDecisionStatementType))
		soap_serialize_saml2__AuthzDecisionStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, struct saml2__AuthzDecisionStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthzDecisionStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthzDecisionStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct saml2__AuthzDecisionStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthzDecisionStatementType **)soap_malloc(soap, sizeof(struct saml2__AuthzDecisionStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthzDecisionStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthzDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, tag ? tag : "saml2:AuthzDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthnStatementType))
		soap_serialize_saml2__AuthnStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthnStatementType(struct soap *soap, const char *tag, int id, struct saml2__AuthnStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthnStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthnStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthnStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthnStatementType(struct soap *soap, const char *tag, struct saml2__AuthnStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthnStatementType **)soap_malloc(soap, sizeof(struct saml2__AuthnStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthnStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthnStatementType(soap, tag ? tag : "saml2:AuthnStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthnStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__StatementAbstractType))
		soap_serialize_saml2__StatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__StatementAbstractType(struct soap *soap, const char *tag, int id, struct saml2__StatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__StatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__StatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__StatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__StatementAbstractType(struct soap *soap, const char *tag, struct saml2__StatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__StatementAbstractType **)soap_malloc(soap, sizeof(struct saml2__StatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__StatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__StatementAbstractType(soap, tag ? tag : "saml2:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__StatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AdviceType))
		soap_serialize_saml2__AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AdviceType(struct soap *soap, const char *tag, int id, struct saml2__AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AdviceType ** SOAP_FMAC4 soap_in_PointerTosaml2__AdviceType(struct soap *soap, const char *tag, struct saml2__AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AdviceType **)soap_malloc(soap, sizeof(struct saml2__AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AdviceType(soap, tag ? tag : "saml2:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AdviceType ** SOAP_FMAC4 soap_get_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ConditionsType))
		soap_serialize_saml2__ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ConditionsType(struct soap *soap, const char *tag, int id, struct saml2__ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ConditionsType ** SOAP_FMAC4 soap_in_PointerTosaml2__ConditionsType(struct soap *soap, const char *tag, struct saml2__ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ConditionsType **)soap_malloc(soap, sizeof(struct saml2__ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ConditionsType(soap, tag ? tag : "saml2:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionsType ** SOAP_FMAC4 soap_get_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectType))
		soap_serialize_saml2__SubjectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectType(struct soap *soap, const char *tag, int id, struct saml2__SubjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectType(struct soap *soap, const char *tag, struct saml2__SubjectType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectType **)soap_malloc(soap, sizeof(struct saml2__SubjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectType(soap, tag ? tag : "saml2:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__NameIDType))
		soap_serialize_saml2__NameIDType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__NameIDType(struct soap *soap, const char *tag, int id, struct saml2__NameIDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__NameIDType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__NameIDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__NameIDType ** SOAP_FMAC4 soap_in_PointerTosaml2__NameIDType(struct soap *soap, const char *tag, struct saml2__NameIDType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__NameIDType **)soap_malloc(soap, sizeof(struct saml2__NameIDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__NameIDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__NameIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__NameIDType(soap, tag ? tag : "saml2:NameIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__NameIDType ** SOAP_FMAC4 soap_get_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__NameIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToxenc__EncryptedKeyType))
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToxenc__EncryptedKeyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType *** SOAP_FMAC4 soap_in_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType ***)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerToxenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType *** SOAP_FMAC4 soap_get_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__ConfirmationMethod(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__ConfirmationMethod(soap, tag ? tag : "saml1:ConfirmationMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Audience(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__Audience(soap, tag ? tag : "saml1:Audience", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AssertionIDReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__AssertionIDReference(soap, tag ? tag : "saml1:AssertionIDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AttributeType))
		soap_serialize_saml1__AttributeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AttributeType(struct soap *soap, const char *tag, int id, struct saml1__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AttributeType ** SOAP_FMAC4 soap_in_PointerTosaml1__AttributeType(struct soap *soap, const char *tag, struct saml1__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AttributeType **)soap_malloc(soap, sizeof(struct saml1__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AttributeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AttributeType(soap, tag ? tag : "saml1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeType ** SOAP_FMAC4 soap_get_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__EvidenceType))
		soap_serialize_saml1__EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__EvidenceType(struct soap *soap, const char *tag, int id, struct saml1__EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__EvidenceType ** SOAP_FMAC4 soap_in_PointerTosaml1__EvidenceType(struct soap *soap, const char *tag, struct saml1__EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__EvidenceType **)soap_malloc(soap, sizeof(struct saml1__EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__EvidenceType(soap, tag ? tag : "saml1:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__EvidenceType ** SOAP_FMAC4 soap_get_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ActionType))
		soap_serialize_saml1__ActionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ActionType(struct soap *soap, const char *tag, int id, struct saml1__ActionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ActionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ActionType ** SOAP_FMAC4 soap_in_PointerTosaml1__ActionType(struct soap *soap, const char *tag, struct saml1__ActionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ActionType **)soap_malloc(soap, sizeof(struct saml1__ActionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ActionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ActionType(soap, tag ? tag : "saml1:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ActionType ** SOAP_FMAC4 soap_get_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthorityBindingType))
		soap_serialize_saml1__AuthorityBindingType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthorityBindingType(struct soap *soap, const char *tag, int id, struct saml1__AuthorityBindingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthorityBindingType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthorityBindingType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthorityBindingType(struct soap *soap, const char *tag, struct saml1__AuthorityBindingType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthorityBindingType **)soap_malloc(soap, sizeof(struct saml1__AuthorityBindingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthorityBindingType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorityBindingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthorityBindingType(soap, tag ? tag : "saml1:AuthorityBindingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthorityBindingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectLocalityType))
		soap_serialize_saml1__SubjectLocalityType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectLocalityType(struct soap *soap, const char *tag, int id, struct saml1__SubjectLocalityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectLocalityType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectLocalityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectLocalityType(struct soap *soap, const char *tag, struct saml1__SubjectLocalityType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectLocalityType **)soap_malloc(soap, sizeof(struct saml1__SubjectLocalityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectLocalityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectLocalityType(soap, tag ? tag : "saml1:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectType))
		soap_serialize_saml1__SubjectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectType(struct soap *soap, const char *tag, int id, struct saml1__SubjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectType(struct soap *soap, const char *tag, struct saml1__SubjectType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectType **)soap_malloc(soap, sizeof(struct saml1__SubjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectType(soap, tag ? tag : "saml1:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_EvidenceType))
		soap_serialize___saml1__union_EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_EvidenceType(struct soap *soap, const char *tag, int id, struct __saml1__union_EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_EvidenceType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_EvidenceType(struct soap *soap, const char *tag, struct __saml1__union_EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_EvidenceType **)soap_malloc(soap, sizeof(struct __saml1__union_EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_EvidenceType(soap, tag ? tag : "-saml1:union-EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_EvidenceType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectConfirmationType))
		soap_serialize_saml1__SubjectConfirmationType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct saml1__SubjectConfirmationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectConfirmationType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml1__SubjectConfirmationType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectConfirmationType **)soap_malloc(soap, sizeof(struct saml1__SubjectConfirmationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectConfirmationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, tag ? tag : "saml1:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__NameIdentifierType))
		soap_serialize_saml1__NameIdentifierType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__NameIdentifierType(struct soap *soap, const char *tag, int id, struct saml1__NameIdentifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__NameIdentifierType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__NameIdentifierType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__NameIdentifierType ** SOAP_FMAC4 soap_in_PointerTosaml1__NameIdentifierType(struct soap *soap, const char *tag, struct saml1__NameIdentifierType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__NameIdentifierType **)soap_malloc(soap, sizeof(struct saml1__NameIdentifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__NameIdentifierType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__NameIdentifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__NameIdentifierType(soap, tag ? tag : "saml1:NameIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__NameIdentifierType ** SOAP_FMAC4 soap_get_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__NameIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_AdviceType))
		soap_serialize___saml1__union_AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_AdviceType(struct soap *soap, const char *tag, int id, struct __saml1__union_AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_AdviceType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_AdviceType(struct soap *soap, const char *tag, struct __saml1__union_AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_AdviceType **)soap_malloc(soap, sizeof(struct __saml1__union_AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_AdviceType(soap, tag ? tag : "-saml1:union-AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_AdviceType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AssertionType))
		soap_serialize_saml1__AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AssertionType(struct soap *soap, const char *tag, int id, struct saml1__AssertionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AssertionType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_saml1__AssertionType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct saml1__AssertionType ** SOAP_FMAC4 soap_in_PointerTosaml1__AssertionType(struct soap *soap, const char *tag, struct saml1__AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AssertionType **)soap_malloc(soap, sizeof(struct saml1__AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AssertionType(soap, tag ? tag : "saml1:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AssertionType ** SOAP_FMAC4 soap_get_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__dateTime(struct soap *soap, struct timeval *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__dateTime))
		soap_serialize_xsd__dateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__dateTime(struct soap *soap, const char *tag, int id, struct timeval *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct timeval ** SOAP_FMAC4 soap_in_PointerToxsd__dateTime(struct soap *soap, const char *tag, struct timeval **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct timeval **)soap_malloc(soap, sizeof(struct timeval *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct timeval **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(struct timeval), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__dateTime(struct soap *soap, struct timeval *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__dateTime(soap, tag ? tag : "xsd:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timeval ** SOAP_FMAC4 soap_get_PointerToxsd__dateTime(struct soap *soap, struct timeval **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_ConditionsType))
		soap_serialize___saml1__union_ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_ConditionsType(struct soap *soap, const char *tag, int id, struct __saml1__union_ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_ConditionsType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_ConditionsType(struct soap *soap, const char *tag, struct __saml1__union_ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_ConditionsType **)soap_malloc(soap, sizeof(struct __saml1__union_ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_ConditionsType(soap, tag ? tag : "-saml1:union-ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_ConditionsType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ConditionAbstractType))
		soap_serialize_saml1__ConditionAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ConditionAbstractType(struct soap *soap, const char *tag, int id, struct saml1__ConditionAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ConditionAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ConditionAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__ConditionAbstractType(struct soap *soap, const char *tag, struct saml1__ConditionAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ConditionAbstractType **)soap_malloc(soap, sizeof(struct saml1__ConditionAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ConditionAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ConditionAbstractType(soap, tag ? tag : "saml1:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__DoNotCacheConditionType))
		soap_serialize_saml1__DoNotCacheConditionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, const char *tag, int id, struct saml1__DoNotCacheConditionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__DoNotCacheConditionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__DoNotCacheConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType ** SOAP_FMAC4 soap_in_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, const char *tag, struct saml1__DoNotCacheConditionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__DoNotCacheConditionType **)soap_malloc(soap, sizeof(struct saml1__DoNotCacheConditionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__DoNotCacheConditionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__DoNotCacheConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__DoNotCacheConditionType(soap, tag ? tag : "saml1:DoNotCacheConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType ** SOAP_FMAC4 soap_get_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__DoNotCacheConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AudienceRestrictionConditionType))
		soap_serialize_saml1__AudienceRestrictionConditionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, int id, struct saml1__AudienceRestrictionConditionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AudienceRestrictionConditionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AudienceRestrictionConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType ** SOAP_FMAC4 soap_in_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, struct saml1__AudienceRestrictionConditionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AudienceRestrictionConditionType **)soap_malloc(soap, sizeof(struct saml1__AudienceRestrictionConditionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AudienceRestrictionConditionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AudienceRestrictionConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, tag ? tag : "saml1:AudienceRestrictionConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType ** SOAP_FMAC4 soap_get_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__Signature))
		soap_serialize__ds__Signature(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__Signature(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__Signature, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ds__Signature(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTo_ds__Signature(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__Signature(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__Signature, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ds__Signature(soap, tag ? tag : "ds:Signature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__Signature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_AssertionType))
		soap_serialize___saml1__union_AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_AssertionType(struct soap *soap, const char *tag, int id, struct __saml1__union_AssertionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_AssertionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_AssertionType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_AssertionType(struct soap *soap, const char *tag, struct __saml1__union_AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_AssertionType **)soap_malloc(soap, sizeof(struct __saml1__union_AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_AssertionType(soap, tag ? tag : "-saml1:union-AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_AssertionType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AttributeStatementType))
		soap_serialize_saml1__AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AttributeStatementType(struct soap *soap, const char *tag, int id, struct saml1__AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AttributeStatementType(struct soap *soap, const char *tag, struct saml1__AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AttributeStatementType **)soap_malloc(soap, sizeof(struct saml1__AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AttributeStatementType(soap, tag ? tag : "saml1:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType))
		soap_serialize_saml1__AuthorizationDecisionStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, int id, struct saml1__AuthorizationDecisionStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthorizationDecisionStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, struct saml1__AuthorizationDecisionStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthorizationDecisionStatementType **)soap_malloc(soap, sizeof(struct saml1__AuthorizationDecisionStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorizationDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag ? tag : "saml1:AuthorizationDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthenticationStatementType))
		soap_serialize_saml1__AuthenticationStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthenticationStatementType(struct soap *soap, const char *tag, int id, struct saml1__AuthenticationStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthenticationStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthenticationStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthenticationStatementType(struct soap *soap, const char *tag, struct saml1__AuthenticationStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthenticationStatementType **)soap_malloc(soap, sizeof(struct saml1__AuthenticationStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthenticationStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthenticationStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthenticationStatementType(soap, tag ? tag : "saml1:AuthenticationStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthenticationStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectStatementAbstractType))
		soap_serialize_saml1__SubjectStatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, int id, struct saml1__SubjectStatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectStatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectStatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, struct saml1__SubjectStatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectStatementAbstractType **)soap_malloc(soap, sizeof(struct saml1__SubjectStatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectStatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectStatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, tag ? tag : "saml1:SubjectStatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__StatementAbstractType))
		soap_serialize_saml1__StatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__StatementAbstractType(struct soap *soap, const char *tag, int id, struct saml1__StatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__StatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__StatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__StatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__StatementAbstractType(struct soap *soap, const char *tag, struct saml1__StatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__StatementAbstractType **)soap_malloc(soap, sizeof(struct saml1__StatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__StatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__StatementAbstractType(soap, tag ? tag : "saml1:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__StatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AdviceType))
		soap_serialize_saml1__AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AdviceType(struct soap *soap, const char *tag, int id, struct saml1__AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AdviceType ** SOAP_FMAC4 soap_in_PointerTosaml1__AdviceType(struct soap *soap, const char *tag, struct saml1__AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AdviceType **)soap_malloc(soap, sizeof(struct saml1__AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AdviceType(soap, tag ? tag : "saml1:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AdviceType ** SOAP_FMAC4 soap_get_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ConditionsType))
		soap_serialize_saml1__ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ConditionsType(struct soap *soap, const char *tag, int id, struct saml1__ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ConditionsType ** SOAP_FMAC4 soap_in_PointerTosaml1__ConditionsType(struct soap *soap, const char *tag, struct saml1__ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ConditionsType **)soap_malloc(soap, sizeof(struct saml1__ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ConditionsType(soap, tag ? tag : "saml1:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionsType ** SOAP_FMAC4 soap_get_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence))
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_malloc(soap, sizeof(struct __wsc__DerivedKeyTokenType_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag ? tag : "-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_get_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToULONG64(struct soap *soap, ULONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ULONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToULONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ULONG64, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ULONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerToULONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ULONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ULONG64, sizeof(ULONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToULONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerToULONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__PropertiesType))
		soap_serialize_wsc__PropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, int id, struct wsc__PropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__PropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__PropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_in_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__PropertiesType **)soap_malloc(soap, sizeof(struct wsc__PropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__PropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__PropertiesType(soap, tag ? tag : "wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_get_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeOpenEnumType(soap, tag ? tag : "wsc:FaultCodeOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsc__FaultCodeOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag ? tag : "xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
		soap_serialize___xenc__union_ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag ? tag : "-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__ReferenceType(soap, tag ? tag : "xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
		soap_serialize_xenc__EncryptionPropertyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag ? tag : "xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__TransformsType(soap, tag ? tag : "xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag ? tag : "xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag ? tag : "xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherDataType(soap, tag ? tag : "xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag ? tag : "xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag ? tag : "ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag ? tag : "ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag ? tag : "ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformType(soap, tag ? tag : "ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DigestMethodType(soap, tag ? tag : "ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformsType(soap, tag ? tag : "ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureMethodType(soap, tag ? tag : "ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag ? tag : "ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag ? tag : "wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag ? tag : "ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyValueType(soap, tag ? tag : "ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag ? tag : "c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyInfoType(soap, tag ? tag : "ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignedInfoType(soap, tag ? tag : "ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__SignatureValue(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__ds__SignatureValue(soap, tag ? tag : "ds:SignatureValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509DataType(soap, tag ? tag : "ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Embedded(soap, tag ? tag : "wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag ? tag : "wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Reference(soap, tag ? tag : "wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsse__EncodedString))
		soap_serialize_wsse__EncodedString(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsse__EncodedString(struct soap *soap, const char *tag, int id, struct wsse__EncodedString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsse__EncodedString, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsse__EncodedString(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_in_PointerTowsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsse__EncodedString **)soap_malloc(soap, sizeof(struct wsse__EncodedString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsse__EncodedString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsse__EncodedString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsse__EncodedString(soap, tag ? tag : "wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_get_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Password(soap, tag ? tag : "wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetCertificateWithPin(struct soap *soap, _ns3__GetCertificateWithPin *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetCertificateWithPin))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetCertificateWithPin(struct soap *soap, const char *tag, int id, _ns3__GetCertificateWithPin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetCertificateWithPin, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__GetCertificateWithPin ? type : NULL);
}

SOAP_FMAC3 _ns3__GetCertificateWithPin ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetCertificateWithPin(struct soap *soap, const char *tag, _ns3__GetCertificateWithPin **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetCertificateWithPin **)soap_malloc(soap, sizeof(_ns3__GetCertificateWithPin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetCertificateWithPin *)soap_instantiate__ns3__GetCertificateWithPin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__GetCertificateWithPin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetCertificateWithPin, sizeof(_ns3__GetCertificateWithPin), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetCertificateWithPin(struct soap *soap, _ns3__GetCertificateWithPin *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__GetCertificateWithPin(soap, tag ? tag : "ns3:GetCertificateWithPin", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetCertificateWithPin ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetCertificateWithPin(struct soap *soap, _ns3__GetCertificateWithPin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetCertificateWithPin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__ForceSMS(struct soap *soap, _ns3__ForceSMS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__ForceSMS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__ForceSMS(struct soap *soap, const char *tag, int id, _ns3__ForceSMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__ForceSMS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__ForceSMS ? type : NULL);
}

SOAP_FMAC3 _ns3__ForceSMS ** SOAP_FMAC4 soap_in_PointerTo_ns3__ForceSMS(struct soap *soap, const char *tag, _ns3__ForceSMS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__ForceSMS **)soap_malloc(soap, sizeof(_ns3__ForceSMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__ForceSMS *)soap_instantiate__ns3__ForceSMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__ForceSMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__ForceSMS, sizeof(_ns3__ForceSMS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__ForceSMS(struct soap *soap, _ns3__ForceSMS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__ForceSMS(soap, tag ? tag : "ns3:ForceSMS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__ForceSMS ** SOAP_FMAC4 soap_get_PointerTo_ns3__ForceSMS(struct soap *soap, _ns3__ForceSMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__ForceSMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CCMovelMultipleSign(struct soap *soap, _ns3__CCMovelMultipleSign *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CCMovelMultipleSign))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CCMovelMultipleSign(struct soap *soap, const char *tag, int id, _ns3__CCMovelMultipleSign *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CCMovelMultipleSign, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__CCMovelMultipleSign ? type : NULL);
}

SOAP_FMAC3 _ns3__CCMovelMultipleSign ** SOAP_FMAC4 soap_in_PointerTo_ns3__CCMovelMultipleSign(struct soap *soap, const char *tag, _ns3__CCMovelMultipleSign **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CCMovelMultipleSign **)soap_malloc(soap, sizeof(_ns3__CCMovelMultipleSign *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CCMovelMultipleSign *)soap_instantiate__ns3__CCMovelMultipleSign(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__CCMovelMultipleSign **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CCMovelMultipleSign, sizeof(_ns3__CCMovelMultipleSign), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CCMovelMultipleSign(struct soap *soap, _ns3__CCMovelMultipleSign *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__CCMovelMultipleSign(soap, tag ? tag : "ns3:CCMovelMultipleSign", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__CCMovelMultipleSign ** SOAP_FMAC4 soap_get_PointerTo_ns3__CCMovelMultipleSign(struct soap *soap, _ns3__CCMovelMultipleSign **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CCMovelMultipleSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__ValidateOtp(struct soap *soap, _ns3__ValidateOtp *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__ValidateOtp))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__ValidateOtp(struct soap *soap, const char *tag, int id, _ns3__ValidateOtp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__ValidateOtp, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__ValidateOtp ? type : NULL);
}

SOAP_FMAC3 _ns3__ValidateOtp ** SOAP_FMAC4 soap_in_PointerTo_ns3__ValidateOtp(struct soap *soap, const char *tag, _ns3__ValidateOtp **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__ValidateOtp **)soap_malloc(soap, sizeof(_ns3__ValidateOtp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__ValidateOtp *)soap_instantiate__ns3__ValidateOtp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__ValidateOtp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__ValidateOtp, sizeof(_ns3__ValidateOtp), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__ValidateOtp(struct soap *soap, _ns3__ValidateOtp *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__ValidateOtp(soap, tag ? tag : "ns3:ValidateOtp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__ValidateOtp ** SOAP_FMAC4 soap_get_PointerTo_ns3__ValidateOtp(struct soap *soap, _ns3__ValidateOtp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__ValidateOtp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetCertificate(struct soap *soap, _ns3__GetCertificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetCertificate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetCertificate(struct soap *soap, const char *tag, int id, _ns3__GetCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetCertificate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__GetCertificate ? type : NULL);
}

SOAP_FMAC3 _ns3__GetCertificate ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetCertificate(struct soap *soap, const char *tag, _ns3__GetCertificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetCertificate **)soap_malloc(soap, sizeof(_ns3__GetCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetCertificate *)soap_instantiate__ns3__GetCertificate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__GetCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetCertificate, sizeof(_ns3__GetCertificate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetCertificate(struct soap *soap, _ns3__GetCertificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__GetCertificate(soap, tag ? tag : "ns3:GetCertificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetCertificate ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetCertificate(struct soap *soap, _ns3__GetCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CCMovelSign(struct soap *soap, _ns3__CCMovelSign *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CCMovelSign))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CCMovelSign(struct soap *soap, const char *tag, int id, _ns3__CCMovelSign *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CCMovelSign, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__CCMovelSign ? type : NULL);
}

SOAP_FMAC3 _ns3__CCMovelSign ** SOAP_FMAC4 soap_in_PointerTo_ns3__CCMovelSign(struct soap *soap, const char *tag, _ns3__CCMovelSign **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CCMovelSign **)soap_malloc(soap, sizeof(_ns3__CCMovelSign *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CCMovelSign *)soap_instantiate__ns3__CCMovelSign(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__CCMovelSign **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CCMovelSign, sizeof(_ns3__CCMovelSign), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CCMovelSign(struct soap *soap, _ns3__CCMovelSign *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__CCMovelSign(soap, tag ? tag : "ns3:CCMovelSign", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__CCMovelSign ** SOAP_FMAC4 soap_get_PointerTo_ns3__CCMovelSign(struct soap *soap, _ns3__CCMovelSign **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CCMovelSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__HashStructure(struct soap *soap, ns5__HashStructure *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__HashStructure))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__HashStructure(struct soap *soap, const char *tag, int id, ns5__HashStructure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__HashStructure, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__HashStructure ? type : NULL);
}

SOAP_FMAC3 ns5__HashStructure ** SOAP_FMAC4 soap_in_PointerTons5__HashStructure(struct soap *soap, const char *tag, ns5__HashStructure **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__HashStructure **)soap_malloc(soap, sizeof(ns5__HashStructure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__HashStructure *)soap_instantiate_ns5__HashStructure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__HashStructure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__HashStructure, sizeof(ns5__HashStructure), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__HashStructure(struct soap *soap, ns5__HashStructure *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__HashStructure(soap, tag ? tag : "ns5:HashStructure", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__HashStructure ** SOAP_FMAC4 soap_get_PointerTons5__HashStructure(struct soap *soap, ns5__HashStructure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__HashStructure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ArrayOfHashStructure(struct soap *soap, ns5__ArrayOfHashStructure *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ArrayOfHashStructure))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ArrayOfHashStructure(struct soap *soap, const char *tag, int id, ns5__ArrayOfHashStructure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ArrayOfHashStructure, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ArrayOfHashStructure ? type : NULL);
}

SOAP_FMAC3 ns5__ArrayOfHashStructure ** SOAP_FMAC4 soap_in_PointerTons5__ArrayOfHashStructure(struct soap *soap, const char *tag, ns5__ArrayOfHashStructure **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ArrayOfHashStructure **)soap_malloc(soap, sizeof(ns5__ArrayOfHashStructure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ArrayOfHashStructure *)soap_instantiate_ns5__ArrayOfHashStructure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ArrayOfHashStructure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ArrayOfHashStructure, sizeof(ns5__ArrayOfHashStructure), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ArrayOfHashStructure(struct soap *soap, ns5__ArrayOfHashStructure *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ArrayOfHashStructure(soap, tag ? tag : "ns5:ArrayOfHashStructure", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ArrayOfHashStructure ** SOAP_FMAC4 soap_get_PointerTons5__ArrayOfHashStructure(struct soap *soap, ns5__ArrayOfHashStructure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ArrayOfHashStructure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__MultipleSignRequest(struct soap *soap, ns5__MultipleSignRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__MultipleSignRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__MultipleSignRequest(struct soap *soap, const char *tag, int id, ns5__MultipleSignRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__MultipleSignRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__MultipleSignRequest ? type : NULL);
}

SOAP_FMAC3 ns5__MultipleSignRequest ** SOAP_FMAC4 soap_in_PointerTons5__MultipleSignRequest(struct soap *soap, const char *tag, ns5__MultipleSignRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__MultipleSignRequest **)soap_malloc(soap, sizeof(ns5__MultipleSignRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__MultipleSignRequest *)soap_instantiate_ns5__MultipleSignRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__MultipleSignRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__MultipleSignRequest, sizeof(ns5__MultipleSignRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__MultipleSignRequest(struct soap *soap, ns5__MultipleSignRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__MultipleSignRequest(soap, tag ? tag : "ns5:MultipleSignRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__MultipleSignRequest ** SOAP_FMAC4 soap_get_PointerTons5__MultipleSignRequest(struct soap *soap, ns5__MultipleSignRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__MultipleSignRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SignResponse(struct soap *soap, ns5__SignResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SignResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SignResponse(struct soap *soap, const char *tag, int id, ns5__SignResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SignResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SignResponse ? type : NULL);
}

SOAP_FMAC3 ns5__SignResponse ** SOAP_FMAC4 soap_in_PointerTons5__SignResponse(struct soap *soap, const char *tag, ns5__SignResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SignResponse **)soap_malloc(soap, sizeof(ns5__SignResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SignResponse *)soap_instantiate_ns5__SignResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SignResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SignResponse, sizeof(ns5__SignResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SignResponse(struct soap *soap, ns5__SignResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SignResponse(soap, tag ? tag : "ns5:SignResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SignResponse ** SOAP_FMAC4 soap_get_PointerTons5__SignResponse(struct soap *soap, ns5__SignResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SignResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_xsd__base64Binary, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xsd__base64Binary ? type : NULL);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SignStatus(struct soap *soap, ns5__SignStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SignStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SignStatus(struct soap *soap, const char *tag, int id, ns5__SignStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SignStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SignStatus ? type : NULL);
}

SOAP_FMAC3 ns5__SignStatus ** SOAP_FMAC4 soap_in_PointerTons5__SignStatus(struct soap *soap, const char *tag, ns5__SignStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SignStatus **)soap_malloc(soap, sizeof(ns5__SignStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SignStatus *)soap_instantiate_ns5__SignStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SignStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SignStatus, sizeof(ns5__SignStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SignStatus(struct soap *soap, ns5__SignStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SignStatus(soap, tag ? tag : "ns5:SignStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SignStatus ** SOAP_FMAC4 soap_get_PointerTons5__SignStatus(struct soap *soap, ns5__SignStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SignStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SignRequest(struct soap *soap, ns5__SignRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SignRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SignRequest(struct soap *soap, const char *tag, int id, ns5__SignRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SignRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SignRequest ? type : NULL);
}

SOAP_FMAC3 ns5__SignRequest ** SOAP_FMAC4 soap_in_PointerTons5__SignRequest(struct soap *soap, const char *tag, ns5__SignRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SignRequest **)soap_malloc(soap, sizeof(ns5__SignRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SignRequest *)soap_instantiate_ns5__SignRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SignRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SignRequest, sizeof(ns5__SignRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SignRequest(struct soap *soap, ns5__SignRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SignRequest(soap, tag ? tag : "ns5:SignRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SignRequest ** SOAP_FMAC4 soap_get_PointerTons5__SignRequest(struct soap *soap, ns5__SignRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SignRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__HashStructure(struct soap *soap, std::vector<ns5__HashStructure *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__HashStructure(struct soap *soap, const std::vector<ns5__HashStructure *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__HashStructure *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__HashStructure(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__HashStructure(struct soap *soap, const char *tag, int id, const std::vector<ns5__HashStructure *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__HashStructure *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__HashStructure(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__HashStructure *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__HashStructure(struct soap *soap, const char *tag, std::vector<ns5__HashStructure *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__HashStructure(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns5__HashStructure *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns5__HashStructure, SOAP_TYPE_std__vectorTemplateOfPointerTons5__HashStructure, sizeof(ns5__HashStructure), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__HashStructure(soap, tag, NULL, "ns5:HashStructure"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__HashStructure(soap, tag, &n, "ns5:HashStructure"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__HashStructure *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__HashStructure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__HashStructure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__HashStructure *> *p;
	size_t k = sizeof(std::vector<ns5__HashStructure *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons5__HashStructure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns5__HashStructure *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns5__HashStructure *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__HashStructure *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
